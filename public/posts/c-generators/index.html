<!doctype html>

<html lang="en">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <title>Mailund on the Internet</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="The HTML5 Herald" />
  <meta name="author" content="" />
  

  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/7.0.0/normalize.min.css" />

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />

<link rel="stylesheet" type="text/css" href="http://localhost:1313/css/styles.css" />
<link rel="stylesheet" href="https://cdn.rawgit.com/tonsky/FiraCode/1.205/distr/fira_code.css">

 
       <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Droid Sans" type="text/css" media="all" />
     
       <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Fira Mono" type="text/css" media="all" />
     

 <style>
 body {
     font-family: 'Droid Sans';
 }
 code {
    font-family: 'Fira Code';
 }
 </style>

 <script type="text/javascript" async
   src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
   MathJax.Hub.Queue(function() {
     
     
     
     var all = MathJax.Hub.getAllJax(), i;
     for(i = 0; i < all.length; i += 1) {
         all[i].SourceElement().parentNode.className += ' has-jax';
     }
   });

   MathJax.Hub.Config({
   
   TeX: { equationNumbers: { autoNumber: "AMS" } }
   });
   MathJax.Hub.Config({
   tex2jax: {
     inlineMath: [['$$','$$'], ['\\(','\\)']],
     displayMath: [['$$$','$$$']],
     processEscapes: true,
     processEnvironments: true,
     skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
     TeX: { equationNumbers: { autoNumber: "AMS" },
          extensions: ["AMSmath.js", "AMSsymbols.js"] }
   }
   });
 </script>

      <script async src="https://www.googletagmanager.com/gtag/js?id=386493837"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', '386493837');
        }
      </script>
</head>

<body>
  <div id="container">
    <header>
      <h1>
                <a href="http://localhost:1313/">Mailund on the Internet</a>
            </h1>

      <ul id="social-media">
                
      </ul>
      
      <p><em>On Writing, Science, Programming and more</em></p>
      

    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="" href="http://localhost:1313/about/">
                <i class="fa-li fa  fa-lg"></i><span>About</span>
            </a>
        </li>
        
        <li>
            <a class="" href="http://localhost:1313/posts">
                <i class="fa-li fa  fa-lg"></i><span>Posts</span>
            </a>
        </li>
        
        <li>
            <a class="" href="http://localhost:1313/books/">
                <i class="fa-li fa  fa-lg"></i><span>Books</span>
            </a>
        </li>
        
        <li>
            <a class="" href="http://localhost:1313/fiction/">
                <i class="fa-li fa  fa-lg"></i><span>Fiction</span>
            </a>
        </li>
        
        <li>
            <a class="" href="http://localhost:1313/publications/">
                <i class="fa-li fa  fa-lg"></i><span>Publications</span>
            </a>
        </li>
        
        <li>
            <a class="" href="http://localhost:1313/software/">
                <i class="fa-li fa  fa-lg"></i><span>Software</span>
            </a>
        </li>
        
    </ul>
</nav>

    <main>




<article>

    <h1>Generators in C</h1>

    
        <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2018-11-23T14:02:40&#43;01:00">Nov 23, 2018</time>
        </li>
        
        
        <li>
            Categories: 
            <em>
                
                    
                    <a href="http://localhost:1313/categories/programming/">Programming</a>
                
            </em>
        </li>
        

        
        <li>
            <em>
                
                    
                    <a href="http://localhost:1313/tags/c/">#c</a>
                
                    , 
                    <a href="http://localhost:1313/tags/programming/">#programming</a>
                
            </em>
        </li>
        

        <li>17 min read</li>
    </ul>
</aside>
    

    <p>Now that I am almost done with <a href="https://amzn.to/2pngZQ0"><em>The Joys of Hashing</em></a>, I am looking at the material I made last year for our <a href="https://kursuskatalog.au.dk/da/course/72431/Genome-Scale-Algorithms"><em>Genome-scale Algorithms</em> class</a>. I implemented a toy read mapper as an example for the final project. I wrote several different approaches to mapping, from generating all strings at a certain edit distance to a read and doing exact matching to branch-and-bound using BWT.</p>
<p>In the implementation, there were a few design decisions there that I was never quite happy with. I didn’t have time to fix them, though. We will teach the next class in the spring, and now I have a few weeks to improve the code.</p>
<p>One thing I particularly disliked with the implementation was the control-flow—several places I need to iterate through reads or matches or such. So, I have functions for that. To combine these iterations with my program, I used callbacks.</p>
<p>This approach is not a bad idea in some languages. If you have closures, it is a natural approach—you call an iteration algorithm with a closure that does what it does in the scope where you use the iterator.</p>
<p>Unfortunately, I used C, and there are no closures there. That makes it very hard to follow what the program does. So, instead, I wanted something similar to Python’s generators. There, you can write a function that iterates over a sequence of objects and returns control-flow to the caller for each of them, and when called again, continues with the iteration.</p>
<p>You cannot do this directly in C, but you can wrap the iteration state in a <code>struct</code> and use that. It is not unlike how <code>FILE</code> pointers are used to work with streams.</p>
<p>I rewrote a couple of functions today to experiment with it.</p>
<h3 id="reading-fastq-files">Reading FASTQ files</h3>
<p>A simple example is iterating through reads in a FASTQ file. In my implementation from last year, I defined a callback that is called with each read and a function that iterates through a FASTQ file. The interface looks like this:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">typedef</span> void (*fastq_read_callback_func)(
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *read_name,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *read,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *quality,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">void</span> * callback_data
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> scan_fastq(
</span></span><span style="display:flex;"><span>    FILE *file,
</span></span><span style="display:flex;"><span>    fastq_read_callback_func
</span></span><span style="display:flex;"><span>    callback,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">void</span> * callback_data
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>I implemented the function like this:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> scan_fastq(
</span></span><span style="display:flex;"><span>    FILE *file,
</span></span><span style="display:flex;"><span>    fastq_read_callback_func callback,
</span></span><span style="display:flex;"><span>     <span style="color:#000080;font-weight:bold">void</span> * callback_data
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">char</span> buffer[MAX_LINE_SIZE];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">while</span> (fgets(buffer, MAX_LINE_SIZE, file) != <span style="color:#00f">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">char</span> *name = strtok(buffer+<span style="color:#00f">1</span>, <span style="color:#00f">&#34;</span><span style="color:#00f">\n</span><span style="color:#00f">&#34;</span>);
</span></span><span style="display:flex;"><span>        fgets(buffer, MAX_LINE_SIZE, file);
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">char</span> *seq = strtok(buffer, <span style="color:#00f">&#34;</span><span style="color:#00f">\n</span><span style="color:#00f">&#34;</span>);
</span></span><span style="display:flex;"><span>        fgets(buffer, MAX_LINE_SIZE, file);
</span></span><span style="display:flex;"><span>        fgets(buffer, MAX_LINE_SIZE, file);
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">char</span> *qual = strtok(buffer, <span style="color:#00f">&#34;</span><span style="color:#00f">\n</span><span style="color:#00f">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        callback(name, seq, qual, callback_data);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        free(name);
</span></span><span style="display:flex;"><span>        free(seq);
</span></span><span style="display:flex;"><span>        free(qual);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>To get a generator instead, I need to wrap the iteration state, and I need a structure to return reads.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">struct</span> fastq_iter {
</span></span><span style="display:flex;"><span>    FILE *file;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">char</span> *buffer;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">struct</span> fastq_record {
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *name;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *sequence;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *quality;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>I could make the second struct an opaque structure by putting it in the .c file and work with pointers to it in the interface, but so far I have put it in the header so I can allocate iterators on the stack. I expose the structure, but you are not supposed to mess with it—if you do, you will get punished if I change it. So, I might change that design.</p>
<p>As it stands right now, I have a function that initialises the iterator and one that frees resources from it. They both take the iterator as a parameter.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> fastq_init_iter(
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> fastq_iter *iter,
</span></span><span style="display:flex;"><span>    FILE *file
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> fastq_dealloc_iter(
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> fastq_iter *iter
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>I put the file-stream in the iterator and allocate a buffer for it. Since the file object can be any stream, I do not want to allocate it for the iterator, so I do not touch it when I free iterator resources either. But, of courses, I do need to free the buffer.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> fastq_init_iter(
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> fastq_iter *iter,
</span></span><span style="display:flex;"><span>    FILE *file
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>    iter-&gt;file = file;
</span></span><span style="display:flex;"><span>    iter-&gt;buffer = malloc(MAX_LINE_SIZE);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> fastq_dealloc_iter(
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> fastq_iter *iter
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>    free(iter-&gt;buffer);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>To iterate over reads, I use this function:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">bool</span> fastq_next_record(
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> fastq_iter *iter,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> fastq_record *record
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>    FILE *file = iter-&gt;file;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">char</span> *buffer = iter-&gt;buffer;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">if</span> (fgets(buffer, MAX_LINE_SIZE, file)) {
</span></span><span style="display:flex;"><span>        record-&gt;name = string_copy(strtok(buffer+<span style="color:#00f">1</span>, <span style="color:#00f">&#34;</span><span style="color:#00f">\n</span><span style="color:#00f">&#34;</span>));
</span></span><span style="display:flex;"><span>        fgets(buffer, MAX_LINE_SIZE, file);
</span></span><span style="display:flex;"><span>        record-&gt;sequence = string_copy(strtok(buffer, <span style="color:#00f">&#34;</span><span style="color:#00f">\n</span><span style="color:#00f">&#34;</span>));
</span></span><span style="display:flex;"><span>        fgets(buffer, MAX_LINE_SIZE, file);
</span></span><span style="display:flex;"><span>        fgets(buffer, MAX_LINE_SIZE, file);
</span></span><span style="display:flex;"><span>        record-&gt;quality = string_copy(strtok(buffer, <span style="color:#00f">&#34;</span><span style="color:#00f">\n</span><span style="color:#00f">&#34;</span>));
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">return</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It does the same as the callback function but it uses the iterator for all the state, and it returns <code>true</code> when it generates an object—and puts it in the <code>record</code> structure. When there are no more objects, it returns <code>false</code>.</p>
<p>A simple program that iterates through a file of reads and prints them out again—a specialised <code>cat</code> if you will, can look like this:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#008080">#include</span> <span style="color:#008080">&lt;stdlib.h&gt;</span><span style="color:#008080">
</span></span></span><span style="display:flex;"><span><span style="color:#008080">#include</span> <span style="color:#008080">&lt;stdio.h&gt;</span><span style="color:#008080">
</span></span></span><span style="display:flex;"><span><span style="color:#008080">#include</span> <span style="color:#008080">&lt;fastq.h&gt;</span><span style="color:#008080">
</span></span></span><span style="display:flex;"><span><span style="color:#008080"></span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">int</span> main(<span style="color:#000080;font-weight:bold">int</span> argc, <span style="color:#000080;font-weight:bold">char</span> *argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">if</span> (argc != <span style="color:#00f">2</span>) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#00f">&#34;needs one argument</span><span style="color:#00f">\n</span><span style="color:#00f">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">return</span> EXIT_FAILURE;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    FILE *input = fopen(argv[<span style="color:#00f">1</span>], <span style="color:#00f">&#34;r&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> fastq_iter iter;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> fastq_record record;
</span></span><span style="display:flex;"><span>    fastq_init_iter(&amp;iter, input);
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">while</span> (fastq_next_record(&amp;iter, &amp;record)) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#00f">&#34;@%s</span><span style="color:#00f">\n</span><span style="color:#00f">&#34;</span>, record.name);
</span></span><span style="display:flex;"><span>        printf(<span style="color:#00f">&#34;%s</span><span style="color:#00f">\n</span><span style="color:#00f">&#34;</span>, record.sequence);
</span></span><span style="display:flex;"><span>        printf(<span style="color:#00f">&#34;+</span><span style="color:#00f">\n</span><span style="color:#00f">&#34;</span>);
</span></span><span style="display:flex;"><span>        printf(<span style="color:#00f">&#34;%s</span><span style="color:#00f">\n</span><span style="color:#00f">&#34;</span>, record.quality);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    fastq_dealloc_iter(&amp;iter);
</span></span><span style="display:flex;"><span>    fclose(input);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="exact-pattern-matching">Exact pattern matching</h3>
<p>Another example of iteration is pattern matching, i.e. finding all occurrences of one string, <code>pattern</code>, in another, <code>text</code>. I have implemented different algorithms for this. Below I have listed a naive algorithm—one that tries to match the pattern at each index in the text—and the <a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm">Knuth-Morris-Pratt algorithm</a>. The callback versions have the same interface.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">typedef</span> void (*match_callback_func)(
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">size_t</span> index, 
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">void</span> * data
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> naive_exact_match(
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *text, <span style="color:#000080;font-weight:bold">size_t</span> n,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *pattern, <span style="color:#000080;font-weight:bold">size_t</span> m,
</span></span><span style="display:flex;"><span>    match_callback_func callback, 
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">void</span> *callback_data
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> knuth_morris_pratt(
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *text, <span style="color:#000080;font-weight:bold">size_t</span> n,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *pattern, <span style="color:#000080;font-weight:bold">size_t</span> m,
</span></span><span style="display:flex;"><span>    match_callback_func callback, 
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">void</span> *callback_data
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>The state in the iterations differs, though. The naive algorithm only needs to know the index in the text we have reached to match a pattern:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> naive_exact_match(
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *text, <span style="color:#000080;font-weight:bold">size_t</span> n,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *pattern, <span style="color:#000080;font-weight:bold">size_t</span> m,
</span></span><span style="display:flex;"><span>    match_callback_func callback,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">void</span> *callback_data
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">if</span> (m &gt; n) {
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-style:italic">// This is necessary because n and m are unsigned so the
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#080;font-style:italic">// &#34;j &lt; n - m + 1&#34; loop test can suffer from an overflow.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#000080;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">for</span> (<span style="color:#000080;font-weight:bold">size_t</span> j = <span style="color:#00f">0</span>; j &lt;= n - m; j++) {
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">size_t</span> i = <span style="color:#00f">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">while</span> (i &lt; m &amp;&amp; text[j+i] == pattern[i]) {
</span></span><span style="display:flex;"><span>            i++;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">if</span> (i == m) {
</span></span><span style="display:flex;"><span>            callback(j, callback_data);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The KMP algorithm also needs a border array.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> knuth_morris_pratt(    
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *text, <span style="color:#000080;font-weight:bold">size_t</span> n,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *pattern, <span style="color:#000080;font-weight:bold">size_t</span> m,
</span></span><span style="display:flex;"><span>    match_callback_func callback,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">void</span> *callback_data
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">if</span> (m &gt; n) {
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-style:italic">// This is necessary because n and m are unsigned so the
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#080;font-style:italic">// &#34;j &lt; n - m + 1&#34; loop test can suffer from an overflow.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#000080;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">// preprocessing
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    <span style="color:#000080;font-weight:bold">size_t</span> prefixtab[m];
</span></span><span style="display:flex;"><span>    prefixtab[<span style="color:#00f">0</span>] = <span style="color:#00f">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">for</span> (<span style="color:#000080;font-weight:bold">size_t</span> i = <span style="color:#00f">1</span>; i &lt; m; ++i) {
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">size_t</span> k = prefixtab[i-<span style="color:#00f">1</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">while</span> (k &gt; <span style="color:#00f">0</span> &amp;&amp; pattern[i] != pattern[k])
</span></span><span style="display:flex;"><span>            k = prefixtab[k-<span style="color:#00f">1</span>];
</span></span><span style="display:flex;"><span>        prefixtab[i] = (pattern[i] == pattern[k]) ? k + <span style="color:#00f">1</span> : <span style="color:#00f">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">// matching
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    <span style="color:#000080;font-weight:bold">size_t</span> j = <span style="color:#00f">0</span>, q = <span style="color:#00f">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">size_t</span> max_match_len = n - m + <span style="color:#00f">1</span>; <span style="color:#080;font-style:italic">// same as for the naive algorithm
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    <span style="color:#080;font-style:italic">// here we compensate for j pointing q into match
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    <span style="color:#000080;font-weight:bold">while</span> (j &lt; max_match_len + q) {
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">while</span> (q &lt; m &amp;&amp; text[j] == pattern[q]) {
</span></span><span style="display:flex;"><span>            q++; j++;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">if</span> (q == m) {
</span></span><span style="display:flex;"><span>            callback(j - m, callback_data);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">if</span> (q == <span style="color:#00f">0</span>) {
</span></span><span style="display:flex;"><span>            j++;
</span></span><span style="display:flex;"><span>        } <span style="color:#000080;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>            q = prefixtab[q-<span style="color:#00f">1</span>];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The generator functions need a structure for returning each match. I could use an integer here, but for consistency, I have used a struct.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">struct</span> match {
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">size_t</span> pos;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>The interface to the two algorithms is the same but since I need more state in the KMP algorithm, the iterator structures differ, so I cannot use the same functions. So, I have these functions for the naive algorithm:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">struct</span> match_naive_iter {
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *text;    <span style="color:#000080;font-weight:bold">size_t</span> n;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *pattern; <span style="color:#000080;font-weight:bold">size_t</span> m;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">size_t</span> current_index;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> match_init_naive_iter(
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> match_naive_iter *iter,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *text, <span style="color:#000080;font-weight:bold">size_t</span> n,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *pattern, <span style="color:#000080;font-weight:bold">size_t</span> m
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">bool</span> next_naive_match(
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> match_naive_iter *iter,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> match *match
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> match_dealloc_naive_iter(
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> match_naive_iter *iter
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>And I have these functions for KMP.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">struct</span> match_kmp_iter {
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *text;    <span style="color:#000080;font-weight:bold">size_t</span> n;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *pattern; <span style="color:#000080;font-weight:bold">size_t</span> m;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">size_t</span> *prefixtab;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">size_t</span> max_match_len;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">size_t</span> j, q;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> match_init_kmp_iter(
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> match_kmp_iter *iter,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *text, <span style="color:#000080;font-weight:bold">size_t</span> n,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *pattern, <span style="color:#000080;font-weight:bold">size_t</span> m
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">bool</span> next_kmp_match(
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> match_kmp_iter *iter,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> match *match
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> match_dealloc_kmp_iter(
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> match_kmp_iter *iter
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>I do the sanity test in the iterator initialisation instead of the generators:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> match_init_naive_iter(
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> match_naive_iter *iter,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *text, <span style="color:#000080;font-weight:bold">size_t</span> n,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *pattern, <span style="color:#000080;font-weight:bold">size_t</span> m
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">// This is necessary because n and m are unsigned so the
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    <span style="color:#080;font-style:italic">// &#34;j &lt; n - m + 1&#34; loop test can suffer from an overflow.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    assert(m &lt;= n);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    iter-&gt;text = text;       iter-&gt;n = n;
</span></span><span style="display:flex;"><span>    iter-&gt;pattern = pattern; iter-&gt;m = m;
</span></span><span style="display:flex;"><span>    iter-&gt;current_index = <span style="color:#00f">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> match_init_kmp_iter(
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> match_kmp_iter *iter,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *text, <span style="color:#000080;font-weight:bold">size_t</span> n,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *pattern, <span style="color:#000080;font-weight:bold">size_t</span> m
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">// This is necessary because n and m are unsigned so the
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    <span style="color:#080;font-style:italic">// &#34;j &lt; n - m + 1&#34; loop test can suffer from an overflow.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    assert(m &lt;= n);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    iter-&gt;text = text;       iter-&gt;n = n;
</span></span><span style="display:flex;"><span>    iter-&gt;pattern = pattern; iter-&gt;m = m;
</span></span><span style="display:flex;"><span>    iter-&gt;j = <span style="color:#00f">0</span>;             iter-&gt;q = <span style="color:#00f">0</span>;
</span></span><span style="display:flex;"><span>    iter-&gt;max_match_len = n - m + <span style="color:#00f">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    iter-&gt;prefixtab = malloc(m);
</span></span><span style="display:flex;"><span>    iter-&gt;prefixtab[<span style="color:#00f">0</span>] = <span style="color:#00f">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">for</span> (<span style="color:#000080;font-weight:bold">size_t</span> i = <span style="color:#00f">1</span>; i &lt; m; ++i) {
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">size_t</span> k = iter-&gt;prefixtab[i-<span style="color:#00f">1</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">while</span> (k &gt; <span style="color:#00f">0</span> &amp;&amp; pattern[i] != pattern[k])
</span></span><span style="display:flex;"><span>            k = iter-&gt;prefixtab[k-<span style="color:#00f">1</span>];
</span></span><span style="display:flex;"><span>        iter-&gt;prefixtab[i] = (pattern[i] == pattern[k]) ? k + <span style="color:#00f">1</span> : <span style="color:#00f">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In the KMP iterator initialisation, I build the border array as well.</p>
<p>The function for freeing resources for the naive algorithm does do anything, but I have it for consistency (and in case I need to free something at a later time).</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> match_dealloc_naive_iter(
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> match_naive_iter *iter
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">// nothing to do here...
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>}
</span></span></code></pre></div><p>For the KMP deallocator, I need to free the border array.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> match_dealloc_kmp_iter(
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> match_kmp_iter *iter
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>    free(iter-&gt;prefixtab);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>With the iterator states, the generators look precisely like the callback versions.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">bool</span> next_naive_match(
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> match_naive_iter *iter,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> match *match
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">size_t</span> n = iter-&gt;n, m = iter-&gt;m;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *text = iter-&gt;text;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *pattern = iter-&gt;pattern;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">for</span> (<span style="color:#000080;font-weight:bold">size_t</span> j = iter-&gt;current_index; j &lt;= n - m; j++) {
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">size_t</span> i = <span style="color:#00f">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">while</span> (i &lt; m &amp;&amp; text[j+i] == pattern[i]) {
</span></span><span style="display:flex;"><span>            i++;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">if</span> (i == m) {
</span></span><span style="display:flex;"><span>            <span style="color:#080;font-style:italic">//callback(j, callback_data);
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>            iter-&gt;current_index = j + <span style="color:#00f">1</span>;
</span></span><span style="display:flex;"><span>            match-&gt;pos = j;
</span></span><span style="display:flex;"><span>            <span style="color:#000080;font-weight:bold">return</span> true;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">bool</span> next_kmp_match(
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> match_kmp_iter *iter,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> match *match
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">// aliases to make the code easier to read... but
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    <span style="color:#080;font-style:italic">// remember to update the actual integers before
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    <span style="color:#080;font-style:italic">// yielding to the caller...
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    <span style="color:#000080;font-weight:bold">size_t</span> j = iter-&gt;j;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">size_t</span> q = iter-&gt;q;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">size_t</span> m = iter-&gt;m;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">size_t</span> max_match_index = iter-&gt;max_match_len;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *text = iter-&gt;text;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *pattern = iter-&gt;pattern;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">// here we compensate for j pointing q into match
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    <span style="color:#000080;font-weight:bold">while</span> (j &lt; max_match_index + q) {
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">while</span> (q &lt; m &amp;&amp; text[j] == pattern[q]) {
</span></span><span style="display:flex;"><span>            q++; j++;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">if</span> (q == m) {
</span></span><span style="display:flex;"><span>            <span style="color:#080;font-style:italic">// yield
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>            <span style="color:#000080;font-weight:bold">if</span> (q == <span style="color:#00f">0</span>) j++;
</span></span><span style="display:flex;"><span>            <span style="color:#000080;font-weight:bold">else</span> q = iter-&gt;prefixtab[q-<span style="color:#00f">1</span>];
</span></span><span style="display:flex;"><span>            iter-&gt;j = j; iter-&gt;q = q;
</span></span><span style="display:flex;"><span>            match-&gt;pos = j - m;
</span></span><span style="display:flex;"><span>            <span style="color:#000080;font-weight:bold">return</span> true;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">if</span> (q == <span style="color:#00f">0</span>) {
</span></span><span style="display:flex;"><span>            j++;
</span></span><span style="display:flex;"><span>        } <span style="color:#000080;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>            q = iter-&gt;prefixtab[q-<span style="color:#00f">1</span>];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="handling-recursion">Handling recursion</h3>
<p>To do approximate matching, I wrote a function that generates all strings at a maximum distance from a pattern. I know that this is a very inefficient approach to approximative matching, but I used it for pedagogical reasons.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">typedef</span> void (*edits_callback_func)(
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *string,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *cigar,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">void</span> * data
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> generate_all_neighbours(
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *pattern,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *alphabet,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">int</span> max_edit_distance,
</span></span><span style="display:flex;"><span>    edits_callback_func callback,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">void</span> *callback_data
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>A natural way to implement the function is using recursion, and I already added a bit of state for that. I do not update most of it, however. I use it mainly to store pointers to buffers I use to generate patterns and CIGAR-strings for the edits. I modify the buffers in the recursion, and the structure keeps the beginning of the buffers so I can use them when reporting a string.</p>
<p>The code listing below is a bit long, but it is simple enough. I try all edits in the recursion and report a string whenever I reach the base cases of the recursion.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">struct</span> recursive_constant_data {
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *buffer_front;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *cigar_front;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *alphabet;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">char</span> *simplify_cigar_buffer;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> generate_all_neighbours(
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *pattern,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *alphabet,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">int</span> max_edit_distance,
</span></span><span style="display:flex;"><span>    edits_callback_func callback,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">void</span> *callback_data
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">size_t</span> n = strlen(pattern) + max_edit_distance + <span style="color:#00f">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">char</span> buffer[n];
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">char</span> cigar[n], cigar_buffer[n];
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> recursive_constant_data data = { 
</span></span><span style="display:flex;"><span>        buffer, cigar, alphabet, cigar_buffer 
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    recursive_generator(
</span></span><span style="display:flex;"><span>        pattern, 
</span></span><span style="display:flex;"><span>        buffer, 
</span></span><span style="display:flex;"><span>        cigar, 
</span></span><span style="display:flex;"><span>        max_edit_distance, 
</span></span><span style="display:flex;"><span>        &amp;data,
</span></span><span style="display:flex;"><span>        callback, 
</span></span><span style="display:flex;"><span>        callback_data
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">void</span> recursive_generator(
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *pattern, <span style="color:#000080;font-weight:bold">char</span> *buffer, <span style="color:#000080;font-weight:bold">char</span> *cigar,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">int</span> max_edit_distance,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> recursive_constant_data *data,
</span></span><span style="display:flex;"><span>    edits_callback_func callback,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">void</span> *callback_data
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">if</span> (*pattern == <span style="color:#800080">&#39;\0&#39;</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-style:italic">// no more pattern to match ... terminate the buffer and call back
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        *buffer = <span style="color:#800080">&#39;\0&#39;</span>;
</span></span><span style="display:flex;"><span>        *cigar = <span style="color:#800080">&#39;\0&#39;</span>;
</span></span><span style="display:flex;"><span>        simplify_cigar(data-&gt;cigar_front, data-&gt;simplify_cigar_buffer);
</span></span><span style="display:flex;"><span>        callback(data-&gt;buffer_front, data-&gt;simplify_cigar_buffer, callback_data);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    } <span style="color:#000080;font-weight:bold">else</span> <span style="color:#000080;font-weight:bold">if</span> (max_edit_distance == <span style="color:#00f">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-style:italic">// we can&#39;t edit any more, so just move pattern to buffer and call back
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#000080;font-weight:bold">size_t</span> rest = strlen(pattern);
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">for</span> (<span style="color:#000080;font-weight:bold">size_t</span> i = <span style="color:#00f">0</span>; i &lt; rest; ++i) {
</span></span><span style="display:flex;"><span>            buffer[i] = pattern[i];
</span></span><span style="display:flex;"><span>            cigar[i] = <span style="color:#800080">&#39;M&#39;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        buffer[rest] = cigar[rest] = <span style="color:#800080">&#39;\0&#39;</span>;
</span></span><span style="display:flex;"><span>        simplify_cigar(data-&gt;cigar_front, data-&gt;simplify_cigar_buffer);
</span></span><span style="display:flex;"><span>        callback(data-&gt;buffer_front, data-&gt;simplify_cigar_buffer, callback_data);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    } <span style="color:#000080;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-style:italic">// --- time to recurse --------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#080;font-style:italic">// deletion
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        *cigar = <span style="color:#800080">&#39;I&#39;</span>;
</span></span><span style="display:flex;"><span>        recursive_generator(pattern + <span style="color:#00f">1</span>, buffer, cigar + <span style="color:#00f">1</span>,
</span></span><span style="display:flex;"><span>                            max_edit_distance - <span style="color:#00f">1</span>, data,
</span></span><span style="display:flex;"><span>                            callback, callback_data);
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-style:italic">// insertion
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#000080;font-weight:bold">for</span> (<span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *a = data-&gt;alphabet; *a; a++) {
</span></span><span style="display:flex;"><span>            *buffer = *a;
</span></span><span style="display:flex;"><span>            *cigar = <span style="color:#800080">&#39;D&#39;</span>;
</span></span><span style="display:flex;"><span>            recursive_generator(pattern, buffer + <span style="color:#00f">1</span>, cigar + <span style="color:#00f">1</span>,
</span></span><span style="display:flex;"><span>                                max_edit_distance - <span style="color:#00f">1</span>, data,
</span></span><span style="display:flex;"><span>                                callback, callback_data);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-style:italic">// match / substitution
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#000080;font-weight:bold">for</span> (<span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *a = data-&gt;alphabet; *a; a++) {
</span></span><span style="display:flex;"><span>            <span style="color:#000080;font-weight:bold">if</span> (*a == *pattern) {
</span></span><span style="display:flex;"><span>                *buffer = *a;
</span></span><span style="display:flex;"><span>                *cigar = <span style="color:#800080">&#39;M&#39;</span>;
</span></span><span style="display:flex;"><span>                recursive_generator(pattern + <span style="color:#00f">1</span>, buffer + <span style="color:#00f">1</span>, cigar + <span style="color:#00f">1</span>,
</span></span><span style="display:flex;"><span>                                    max_edit_distance, data,
</span></span><span style="display:flex;"><span>                                    callback, callback_data);
</span></span><span style="display:flex;"><span>            } <span style="color:#000080;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>                *buffer = *a;
</span></span><span style="display:flex;"><span>                *cigar = <span style="color:#800080">&#39;M&#39;</span>;
</span></span><span style="display:flex;"><span>                recursive_generator(pattern + <span style="color:#00f">1</span>, buffer + <span style="color:#00f">1</span>, cigar + <span style="color:#00f">1</span>,
</span></span><span style="display:flex;"><span>                                    max_edit_distance - <span style="color:#00f">1</span>, data,
</span></span><span style="display:flex;"><span>                                    callback, callback_data);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In the recursion, what I do is this: I create a pattern for all the edits, and then I construct a string that contains all the edits operations. For example, two deletions and two matches will give me the edit string <code>DDMM</code>. Yes, it looks strange that two insertions are recorded at two deletions, but this is because the operations are relative to the <code>text</code> string and not the <code>pattern</code>, so insertions and deletions are switched.</p>
<p>What the <code>simplify_cigar</code> function does is translating the string with the individual edit operations into a CIGAR string. Maybe the name isn’t that well chosen, but that is what I called it. A better name could be <code>edits_to_cigar</code> or something like that. Anyway, in a CIGAR string, two deletions and two matches are recorded as <code>2D2M</code>. The function does that translation.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> simplify_cigar(<span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *cigar, <span style="color:#000080;font-weight:bold">char</span> *buffer)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">while</span> (*cigar) {
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *next = scan(cigar);
</span></span><span style="display:flex;"><span>        buffer = buffer + sprintf(buffer, <span style="color:#00f">&#34;%lu%c&#34;</span>, next - cigar, *cigar);
</span></span><span style="display:flex;"><span>        cigar = next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    *buffer = <span style="color:#800080">&#39;\0&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>To handle recursion in an iterator, I need an explicit stack. I use a stack frame structure for this.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">struct</span> edit_iter_frame;
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">struct</span> edit_iter {
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *pattern;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *alphabet;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">char</span> *buffer;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">char</span> *cigar;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">char</span> *simplify_cigar_buffer;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> edit_iter_frame *frames;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">struct</span> edit_pattern {
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *pattern;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *cigar;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> edit_init_iter(
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> edit_iter *iter,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *pattern,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *alphabet,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">int</span> max_edit_distance
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">bool</span> edit_next_pattern(
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> edit_iter *iter,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> edit_pattern *result
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> edit_dealloc_iter(
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> edit_iter *iter
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>Where it gets a little complicated is that I need several recursions when in the edit cases. If I had persistent frame data—that is, if I never modified data that would give me side effects—I could push frames to the stack. Unfortunately, that is not the case here. I modify the buffers in the recursions, so the frames I push onto the stack are modified between the push and the pop.</p>
<p>Because of this, I need to modify the buffers just before I recurse; I cannot push a frame to the stack and handle the frames one a time.</p>
<p>I am not sure this is the most elegant way to handle it, but what I did was this: I split the recursions into two steps. The first generates the recursive calls, and the second modifies the buffers and push a frame to the stack for running the first step recursively.</p>
<p>I defined opcodes for the different operations and structures for storing the state of the operations like this:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">enum</span> edit_op {
</span></span><span style="display:flex;"><span>    EXECUTE,
</span></span><span style="display:flex;"><span>    DELETION,
</span></span><span style="display:flex;"><span>    INSERTION,
</span></span><span style="display:flex;"><span>    MATCH
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">struct</span> deletion_info {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">// No extra info
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>};
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">struct</span> insertion_info {
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">char</span> a;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">struct</span> match_info {
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">char</span> a;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>The <code>EXECUTE</code> operation pushes the different edits to the stack; the other operations modify the state and push the <code>EXECUTE</code> operation for the recursions onto the stack.</p>
<p>The stack frames contain the opcodes, the data associated with them, and the program state I need for each frame:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">struct</span> edit_iter_frame {
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">enum</span> edit_op op;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">union</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">struct</span> deletion_info  d;
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">struct</span> insertion_info i;
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">struct</span> match_info     m;
</span></span><span style="display:flex;"><span>    } op_data;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *pattern_front;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">char</span> *buffer_front;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">char</span> *cigar_front;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">int</span> max_dist;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> edit_iter_frame *next;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>I wrote a function for pushing stack frames. It doesn’t set the entire state for the frames—I would need separate functions for each operation if I want to add the operation data with the frame. Instead, I will update the frame after I have pushed it. Maybe not that pretty, but that is where I am right now.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">struct</span> edit_iter_frame *
</span></span><span style="display:flex;"><span>push_edit_iter_frame(
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">enum</span> edit_op op,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *pattern_front,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">char</span> *buffer_front,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">char</span> *cigar_front,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">int</span> max_dist,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> edit_iter_frame *next
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> edit_iter_frame *frame =
</span></span><span style="display:flex;"><span>        malloc(<span style="color:#000080;font-weight:bold">sizeof</span>(<span style="color:#000080;font-weight:bold">struct</span> edit_iter_frame));
</span></span><span style="display:flex;"><span>    frame-&gt;op = op;
</span></span><span style="display:flex;"><span>    frame-&gt;pattern_front = pattern_front;
</span></span><span style="display:flex;"><span>    frame-&gt;buffer_front = buffer_front;
</span></span><span style="display:flex;"><span>    frame-&gt;cigar_front = cigar_front,
</span></span><span style="display:flex;"><span>    frame-&gt;max_dist = max_dist;
</span></span><span style="display:flex;"><span>    frame-&gt;next = next;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">return</span> frame;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>When I initialise the iterator, I push an <code>EXECUTE</code> frame to the stack. It will push the first operation-recursions onto the stack when I start the generator.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> edit_init_iter(
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> edit_iter *iter,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *pattern,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *alphabet,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">int</span> max_edit_distance
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">size_t</span> n = strlen(pattern) + max_edit_distance + <span style="color:#00f">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    iter-&gt;pattern = pattern;
</span></span><span style="display:flex;"><span>    iter-&gt;alphabet = alphabet;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    iter-&gt;buffer = malloc(n); iter-&gt;buffer[n - <span style="color:#00f">1</span>] = <span style="color:#800080">&#39;\0&#39;</span>;
</span></span><span style="display:flex;"><span>    iter-&gt;cigar = malloc(n);  iter-&gt;cigar[n - <span style="color:#00f">1</span>] = <span style="color:#800080">&#39;\0&#39;</span>;
</span></span><span style="display:flex;"><span>    iter-&gt;simplify_cigar_buffer = malloc(n);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    iter-&gt;frames = push_edit_iter_frame(
</span></span><span style="display:flex;"><span>        EXECUTE,
</span></span><span style="display:flex;"><span>        iter-&gt;pattern,
</span></span><span style="display:flex;"><span>        iter-&gt;buffer,
</span></span><span style="display:flex;"><span>        iter-&gt;cigar,
</span></span><span style="display:flex;"><span>        max_edit_distance,
</span></span><span style="display:flex;"><span>        <span style="color:#00f">0</span>
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>When I deallocate an iterator, I free the buffers.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> edit_dealloc_iter(<span style="color:#000080;font-weight:bold">struct</span> edit_iter *iter)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    free(iter-&gt;buffer);
</span></span><span style="display:flex;"><span>    free(iter-&gt;cigar);
</span></span><span style="display:flex;"><span>    free(iter-&gt;simplify_cigar_buffer);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now, for the generator, I report that I am finished when there are no more stack frames. Otherwise, I check if I have reached a base case in the recursion and if so, I report a string. Otherwise, I figure out which operation I need to do in a <code>switch</code>. An <code>EXECUTE</code> operation means that I need to push the different recursion frames to the stack. The other operations mean I need to update the buffers and then push an <code>EXECUTE</code> operation to execute the operation.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">bool</span> edit_next_pattern(
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> edit_iter *iter,
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">struct</span> edit_pattern *result
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>    assert(iter);
</span></span><span style="display:flex;"><span>    assert(result);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">if</span> (iter-&gt;frames == <span style="color:#00f">0</span>) <span style="color:#000080;font-weight:bold">return</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">// pop top frame
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    <span style="color:#000080;font-weight:bold">struct</span> edit_iter_frame *frame = iter-&gt;frames;
</span></span><span style="display:flex;"><span>    iter-&gt;frames = frame-&gt;next;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *pattern = frame-&gt;pattern_front;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">char</span> *buffer = frame-&gt;buffer_front;
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">char</span> *cigar = frame-&gt;cigar_front;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">if</span> (*pattern == <span style="color:#800080">&#39;\0&#39;</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-style:italic">// no more pattern to match ... terminate the buffer and call back
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        *buffer = <span style="color:#800080">&#39;\0&#39;</span>;
</span></span><span style="display:flex;"><span>        *cigar = <span style="color:#800080">&#39;\0&#39;</span>;
</span></span><span style="display:flex;"><span>        simplify_cigar(iter-&gt;cigar, iter-&gt;simplify_cigar_buffer);
</span></span><span style="display:flex;"><span>        result-&gt;pattern = iter-&gt;buffer;
</span></span><span style="display:flex;"><span>        result-&gt;cigar = iter-&gt;simplify_cigar_buffer;
</span></span><span style="display:flex;"><span>        free(frame);
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">return</span> true;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    } <span style="color:#000080;font-weight:bold">else</span> <span style="color:#000080;font-weight:bold">if</span> (frame-&gt;max_dist == <span style="color:#00f">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-style:italic">// we can&#39;t edit any more, so just move pattern to buffer and call back
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#000080;font-weight:bold">size_t</span> rest = strlen(pattern);
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">for</span> (<span style="color:#000080;font-weight:bold">size_t</span> i = <span style="color:#00f">0</span>; i &lt; rest; ++i) {
</span></span><span style="display:flex;"><span>              buffer[i] = pattern[i];
</span></span><span style="display:flex;"><span>              cigar[i] = <span style="color:#800080">&#39;M&#39;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        buffer[rest] = cigar[rest] = <span style="color:#800080">&#39;\0&#39;</span>;
</span></span><span style="display:flex;"><span>        simplify_cigar(iter-&gt;cigar, iter-&gt;simplify_cigar_buffer);
</span></span><span style="display:flex;"><span>        result-&gt;pattern = iter-&gt;buffer;
</span></span><span style="display:flex;"><span>        result-&gt;cigar = iter-&gt;simplify_cigar_buffer;
</span></span><span style="display:flex;"><span>        free(frame);
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">return</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">switch</span> (frame-&gt;op) {
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">case</span> EXECUTE:
</span></span><span style="display:flex;"><span>            <span style="color:#000080;font-weight:bold">for</span> (<span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *a = iter-&gt;alphabet; *a; a++) {
</span></span><span style="display:flex;"><span>                iter-&gt;frames = push_edit_iter_frame(
</span></span><span style="display:flex;"><span>                    INSERTION,
</span></span><span style="display:flex;"><span>                    frame-&gt;pattern_front,
</span></span><span style="display:flex;"><span>                    frame-&gt;buffer_front,
</span></span><span style="display:flex;"><span>                    frame-&gt;cigar_front,
</span></span><span style="display:flex;"><span>                    frame-&gt;max_dist,
</span></span><span style="display:flex;"><span>                    iter-&gt;frames
</span></span><span style="display:flex;"><span>                );
</span></span><span style="display:flex;"><span>                iter-&gt;frames-&gt;op_data.i.a = *a;
</span></span><span style="display:flex;"><span>                iter-&gt;frames = push_edit_iter_frame(
</span></span><span style="display:flex;"><span>                    MATCH,
</span></span><span style="display:flex;"><span>                    frame-&gt;pattern_front,
</span></span><span style="display:flex;"><span>                    frame-&gt;buffer_front,
</span></span><span style="display:flex;"><span>                    frame-&gt;cigar_front,
</span></span><span style="display:flex;"><span>                    frame-&gt;max_dist,
</span></span><span style="display:flex;"><span>                    iter-&gt;frames
</span></span><span style="display:flex;"><span>                );
</span></span><span style="display:flex;"><span>                iter-&gt;frames-&gt;op_data.m.a = *a;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            iter-&gt;frames = push_edit_iter_frame(
</span></span><span style="display:flex;"><span>                DELETION,
</span></span><span style="display:flex;"><span>                frame-&gt;pattern_front,
</span></span><span style="display:flex;"><span>                frame-&gt;buffer_front,
</span></span><span style="display:flex;"><span>                frame-&gt;cigar_front,
</span></span><span style="display:flex;"><span>                frame-&gt;max_dist,
</span></span><span style="display:flex;"><span>                iter-&gt;frames
</span></span><span style="display:flex;"><span>            );
</span></span><span style="display:flex;"><span>            <span style="color:#000080;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">case</span> DELETION:
</span></span><span style="display:flex;"><span>            *cigar = <span style="color:#800080">&#39;I&#39;</span>;
</span></span><span style="display:flex;"><span>            iter-&gt;frames = push_edit_iter_frame(
</span></span><span style="display:flex;"><span>                EXECUTE,
</span></span><span style="display:flex;"><span>                frame-&gt;pattern_front + <span style="color:#00f">1</span>,
</span></span><span style="display:flex;"><span>                frame-&gt;buffer_front,
</span></span><span style="display:flex;"><span>                frame-&gt;cigar_front + <span style="color:#00f">1</span>,
</span></span><span style="display:flex;"><span>                frame-&gt;max_dist - <span style="color:#00f">1</span>,
</span></span><span style="display:flex;"><span>                iter-&gt;frames
</span></span><span style="display:flex;"><span>            );
</span></span><span style="display:flex;"><span>            <span style="color:#000080;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">case</span> INSERTION:
</span></span><span style="display:flex;"><span>            *buffer = frame-&gt;op_data.i.a;
</span></span><span style="display:flex;"><span>            *cigar = <span style="color:#800080">&#39;D&#39;</span>;
</span></span><span style="display:flex;"><span>            iter-&gt;frames = push_edit_iter_frame(
</span></span><span style="display:flex;"><span>                EXECUTE,
</span></span><span style="display:flex;"><span>                frame-&gt;pattern_front,
</span></span><span style="display:flex;"><span>                frame-&gt;buffer_front + <span style="color:#00f">1</span>,
</span></span><span style="display:flex;"><span>                frame-&gt;cigar_front + <span style="color:#00f">1</span>,
</span></span><span style="display:flex;"><span>                frame-&gt;max_dist - <span style="color:#00f">1</span>,
</span></span><span style="display:flex;"><span>                iter-&gt;frames
</span></span><span style="display:flex;"><span>            );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#000080;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">case</span> MATCH:
</span></span><span style="display:flex;"><span>            <span style="color:#000080;font-weight:bold">if</span> (frame-&gt;op_data.m.a == *pattern) {
</span></span><span style="display:flex;"><span>                *buffer = frame-&gt;op_data.m.a;
</span></span><span style="display:flex;"><span>                *cigar = <span style="color:#800080">&#39;M&#39;</span>;
</span></span><span style="display:flex;"><span>                iter-&gt;frames = push_edit_iter_frame(
</span></span><span style="display:flex;"><span>                    EXECUTE,
</span></span><span style="display:flex;"><span>                    frame-&gt;pattern_front + <span style="color:#00f">1</span>,
</span></span><span style="display:flex;"><span>                    frame-&gt;buffer_front + <span style="color:#00f">1</span>,
</span></span><span style="display:flex;"><span>                    frame-&gt;cigar_front + <span style="color:#00f">1</span>,
</span></span><span style="display:flex;"><span>                    frame-&gt;max_dist,
</span></span><span style="display:flex;"><span>                    iter-&gt;frames
</span></span><span style="display:flex;"><span>                );
</span></span><span style="display:flex;"><span>            } <span style="color:#000080;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>                *buffer = frame-&gt;op_data.m.a;
</span></span><span style="display:flex;"><span>                *cigar = <span style="color:#800080">&#39;M&#39;</span>;
</span></span><span style="display:flex;"><span>                iter-&gt;frames = push_edit_iter_frame(
</span></span><span style="display:flex;"><span>                    EXECUTE,
</span></span><span style="display:flex;"><span>                    frame-&gt;pattern_front + <span style="color:#00f">1</span>,
</span></span><span style="display:flex;"><span>                    frame-&gt;buffer_front + <span style="color:#00f">1</span>,
</span></span><span style="display:flex;"><span>                    frame-&gt;cigar_front + <span style="color:#00f">1</span>,
</span></span><span style="display:flex;"><span>                    frame-&gt;max_dist - <span style="color:#00f">1</span>,
</span></span><span style="display:flex;"><span>                    iter-&gt;frames
</span></span><span style="display:flex;"><span>                );
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#000080;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">default</span>:
</span></span><span style="display:flex;"><span>            assert(false);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    free(frame);
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">return</span> edit_next_pattern(iter, result);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>I have a lot more callback functions to update, but this is how I have gotten this far. What do you think? Do you have suggestions for smarter ways to do this? How do you implement generators in C? I would love to hear from you if you have ideas or experience with this.</p>
<!-- raw HTML omitted -->


</article>


<hr/>
<div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "mailund-dk" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
<hr/>
<section class="post-nav">
    <ul>
        
        <li>
            <a href="http://localhost:1313/posts/elegant-scipy/"><i class="fa fa-chevron-circle-left"></i> Elegant Scipy</a>
        </li>
        
        
        <li>
            <a href="http://localhost:1313/posts/joys-of-hashing/">Joys of Hashing <i class="fa fa-chevron-circle-right"></i> </a>
        </li>
        
    </ul>
</section>
  





</main>
    <footer>
        <h6>Copyright © 2020-2025 - Thomas Mailund |
            Rendered by <a href="https://gohugo.io" title="Hugo">Hugo</a> |
            <a href="http://localhost:1313/index.xml">Subscribe</a></h6>
    </footer>
</div>
<script src="http://localhost:1313/js/scripts.js"></script>
</body>
<div id="amzn-assoc-ad-04956520-8388-43ab-9b6e-fbe758d208f8"></div>
<script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=04956520-8388-43ab-9b6e-fbe758d208f8"></script>

<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

</html>
