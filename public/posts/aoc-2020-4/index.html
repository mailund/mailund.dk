<!doctype html>

<html lang="en">

<head>
  <title>Mailund on the Internet</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="The HTML5 Herald" />
  <meta name="author" content="Thomas Mailund" />
  

  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/7.0.0/normalize.min.css" />

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />

<link rel="stylesheet" type="text/css" href="https://mailund.dk/css/styles.css" />
<link rel="stylesheet" href="https://cdn.rawgit.com/tonsky/FiraCode/1.205/distr/fira_code.css">

 
       <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Droid Sans" type="text/css" media="all" />
     
       <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Fira Mono" type="text/css" media="all" />
     

 <style>
 body {
     font-family: 'Droid Sans';
 }
 code {
    font-family: 'Fira Code';
 }
 </style>

 <script type="text/javascript" async
   src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
   MathJax.Hub.Queue(function() {
     
     
     
     var all = MathJax.Hub.getAllJax(), i;
     for(i = 0; i < all.length; i += 1) {
         all[i].SourceElement().parentNode.className += ' has-jax';
     }
   });

   MathJax.Hub.Config({
   
   TeX: { equationNumbers: { autoNumber: "AMS" } }
   });
   MathJax.Hub.Config({
   tex2jax: {
     inlineMath: [['$$','$$'], ['\\(','\\)']],
     displayMath: [['$$$','$$$']],
     processEscapes: true,
     processEnvironments: true,
     skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
     TeX: { equationNumbers: { autoNumber: "AMS" },
          extensions: ["AMSmath.js", "AMSsymbols.js"] }
   }
   });
 </script>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-10582357-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

</head>

<body>
  <div id="container">
    <header>
      <h1>
                <a href="https://mailund.dk/">Mailund on the Internet</a>
            </h1>

      <ul id="social-media">
        
        <li><a href="https://twitter.com/ThomasMailund"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
         
        <li><a href="https://www.linkedin.com/in/thomas-mailund-94153b1"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
         
        <li><a href="https://github.com/mailund"><i class="fab fa-github fa-lg" aria-hidden="true"></i></a></li>
          
        <li><a href="https://www.facebook.com/mailund"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
          
        <li><a href="https://patreon.com/mailund"><i class="fab fa-patreon fa-lg" aria-hidden="true"></i></a></li>
         
        <li><a href="https://www.goodreads.com/author/show/15484380.Thomas_Mailund"><i class="fab fa-goodreads fa-lg" aria-hidden="true"></i></a></li>
        
      </ul>
      
      <p><em>On Writing, Science, Programming and more</em></p>
      

    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="" href="https://mailund.dk/about/">
                <i class="fa-li fa  fa-lg"></i><span>About</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://mailund.dk/posts">
                <i class="fa-li fa  fa-lg"></i><span>Posts</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://mailund.dk/books/">
                <i class="fa-li fa  fa-lg"></i><span>Books</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://mailund.dk/publications/">
                <i class="fa-li fa  fa-lg"></i><span>Publications</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://mailund.dk/software/">
                <i class="fa-li fa  fa-lg"></i><span>Software</span>
            </a>
        </li>
        
    </ul>
</nav>

    <main>




<article>

    <h1>Advent of Code 2020 — days 12-13</h1>

    
        <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-12-17T10:54:39&#43;01:00">Dec 17, 2020</time>
        </li>
        
        
        <li>
            Categories: 
            <em>
                
                    
                    <a href="https://mailund.dk/categories/programming/">Programming</a>
                
            </em>
        </li>
        

        
        <li>
            <em>
                
                    
                    <a href="https://mailund.dk/tags/python/">#python</a>
                
                    , 
                    <a href="https://mailund.dk/tags/programming/">#programming</a>
                
            </em>
        </li>
        

        <li>14 min read</li>
    </ul>
</aside>
    

    <p>I don’t have a lot of time today, so I will only describe the solutions for two days. I promise that I will catch up to the day the puzzles are released, but it probably won’t be until after the weekend…</p>
<h2 id="day-12--rain-risk">Day 12 — Rain Risk</h2>
<p>In <a href="https://adventofcode.com/2020/day/12">day 12</a> we are navigating a ship—because why not?</p>
<p>We have another virtual machine. It isn’t described exactly like a virtual machine, so it might be less obvious than the machine in <a href="https://mailund.dk/posts/aoc-2020-2/">day 8</a>, but it is what we have. There is a state—the position and the angle we are facing—and there are instructions for modifying the state. So, without thinking too deeply about it, I did the same as in day 8: I made a class for the state, put the operations in it as methods, then made a table that maps from opcodes to actions, and ran the program.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000080;font-weight:bold">from</span> math <span style="color:#000080;font-weight:bold">import</span> cos, sin, pi
<span style="color:#000080;font-weight:bold">class</span> Position(object):
    <span style="color:#000080;font-weight:bold">def</span> __init__(self):
        self.x = <span style="color:#00f">0.0</span>
        self.y = <span style="color:#00f">0.0</span>
        self.angle = <span style="color:#00f">0.0</span> <span style="color:#080;font-style:italic"># facing east</span>

    @property
    <span style="color:#000080;font-weight:bold">def</span> manhattan_dist(self):
        <span style="color:#000080;font-weight:bold">return</span> abs(self.x) + abs(self.y)

    <span style="color:#080;font-style:italic"># Ops...</span>
    <span style="color:#000080;font-weight:bold">def</span> N(self, amount): self.y += amount
    <span style="color:#000080;font-weight:bold">def</span> S(self, amount): self.y -= amount
    <span style="color:#000080;font-weight:bold">def</span> E(self, amount): self.x += amount
    <span style="color:#000080;font-weight:bold">def</span> W(self, amount): self.x -= amount
    <span style="color:#000080;font-weight:bold">def</span> L(self, angle):  self.angle += pi * angle / <span style="color:#00f">180.0</span> <span style="color:#080;font-style:italic"># radiants</span>
    <span style="color:#000080;font-weight:bold">def</span> R(self, angle):  self.L(-angle) <span style="color:#080;font-style:italic"># subtraction bus R == -L</span>
    <span style="color:#000080;font-weight:bold">def</span> F(self, amount):
        self.x += amount * cos(self.angle)
        self.y += amount * sin(self.angle)

pos = Position()
dispatcher = {op: getattr(pos, op) <span style="color:#000080;font-weight:bold">for</span> op <span style="font-weight:bold">in</span> <span style="color:#00f">&#34;NSEWLRF&#34;</span>}

f = open(<span style="color:#00f">&#39;/Users/mailund/Projects/adventofcode/2020/12/input.txt&#39;</span>)
<span style="color:#000080;font-weight:bold">for</span> op <span style="font-weight:bold">in</span> [line.strip() <span style="color:#000080;font-weight:bold">for</span> line <span style="font-weight:bold">in</span> f]:
    dispatcher[op[<span style="color:#00f">0</span>]](int(op[<span style="color:#00f">1</span>:]))
</code></pre></div><p>After the program, we want the Manhattan distance for the position. I implemented that as a property, and I don’t really know why. I guess I just felt like it. A method would be fine, or you could even extract the coordinates and compute it directly when you answer the puzzle.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000080;font-weight:bold">print</span>(f<span style="color:#00f">&#34;Puzzle #1: {round(pos.manhattan_dist)}&#34;</span>)
</code></pre></div><p>This was entirely standard code, following the same template as for day 8. (But I don’t plan on generating machine code for this one—once is enough).</p>
<p>For Puzzle #2, we change the virtual machine. Now, the state is both the location of the ship and a waypoint, and some of the operations modify the waypoint, while others modify the ship.</p>
<p>I took the direct approach and refactored the code into a <code>Waypoint</code> and a <code>Ship</code> class, with a position in the waypoint and waypoint and position in the ship. I put the waypoint operations in that class, and the others in the ship, with a dispatch between ship and waypoint for the waypoint operations. That way, I can build the table for the operations the same way as before.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000080;font-weight:bold">from</span> math <span style="color:#000080;font-weight:bold">import</span> cos, sin, pi
<span style="color:#000080;font-weight:bold">class</span> Waypoint(object):
    <span style="color:#000080;font-weight:bold">def</span> __init__(self):
        self.x = <span style="color:#00f">10.0</span>
        self.y = <span style="color:#00f">1.0</span>

    <span style="color:#080;font-style:italic"># Ops...</span>
    <span style="color:#000080;font-weight:bold">def</span> N(self, amount): self.y += amount
    <span style="color:#000080;font-weight:bold">def</span> S(self, amount): self.y -= amount
    <span style="color:#000080;font-weight:bold">def</span> E(self, amount): self.x += amount
    <span style="color:#000080;font-weight:bold">def</span> W(self, amount): self.x -= amount
    <span style="color:#000080;font-weight:bold">def</span> rotate(self, angle):
        angle = pi * angle / <span style="color:#00f">180.0</span> <span style="color:#080;font-style:italic"># use radiants</span>
        self.x, self.y = self.x * cos(angle) - self.y * sin(angle), \
                         self.x * sin(angle) + self.y * cos(angle)

<span style="color:#000080;font-weight:bold">class</span> Ship(object):
    <span style="color:#000080;font-weight:bold">def</span> __init__(self):
        self.waypoint = Waypoint()
        <span style="color:#000080;font-weight:bold">for</span> op <span style="font-weight:bold">in</span> <span style="color:#00f">&#34;NSEW&#34;</span>: setattr(self, op, getattr(self.waypoint, op))
        self.x = <span style="color:#00f">0.0</span>
        self.y = <span style="color:#00f">0.0</span>

    @property
    <span style="color:#000080;font-weight:bold">def</span> manhattan_dist(self):
        <span style="color:#000080;font-weight:bold">return</span> abs(self.x) + abs(self.y)

    <span style="color:#080;font-style:italic"># Ops...</span>
    <span style="color:#000080;font-weight:bold">def</span> L(self, angle):  self.waypoint.rotate(angle)
    <span style="color:#000080;font-weight:bold">def</span> R(self, angle):  self.waypoint.rotate(-angle)
    <span style="color:#000080;font-weight:bold">def</span> F(self, amount):
        self.x += amount * self.waypoint.x
        self.y += amount * self.waypoint.y

ship = Ship()
dispatcher = {op: getattr(ship, op) <span style="color:#000080;font-weight:bold">for</span> op <span style="font-weight:bold">in</span> <span style="color:#00f">&#34;NSEWLRF&#34;</span>}

f = open(<span style="color:#00f">&#39;/Users/mailund/Projects/adventofcode/2020/12/input.txt&#39;</span>)
<span style="color:#000080;font-weight:bold">for</span> op <span style="font-weight:bold">in</span> [line.strip() <span style="color:#000080;font-weight:bold">for</span> line <span style="font-weight:bold">in</span> f]:
    dispatcher[op[<span style="color:#00f">0</span>]](int(op[<span style="color:#00f">1</span>:]))
<span style="color:#000080;font-weight:bold">print</span>(f<span style="color:#00f">&#34;Puzzle #2: {round(ship.manhattan_dist)}&#34;</span>)
</code></pre></div><p>The only tricky part was the trigonometry for changing the angle. I didn’t notice until later that all the changes are multiples of 90 degrees.</p>
<p>Since we are looking at multiples of 90 degrees, rotations are simpler. If you turn 90, you map \( (x,y) \) into \( (-y,x) \). Do it twice, and you turn 180 degrees, so you go \( (x,y) \mapsto (-x,-y) \). And 270 sends you to \( (y,-x) \). Take the angle you have to turn, divide it by 90, and apply this rule  that many times. Or make a table for the transformations. It is likely to be simpler and faster than the trigonometry, but I didn’t see that the angles were this regular, and if it was in the problem description I missed it.</p>
<p>However, if you are simplifying the code, you can do better than building a table for the rotations. You can use complex numbers.</p>
<p>Both the waypoint and the ship contain a two-dimensional position, and when you look at a complex number the right way, that is what they are. We can use the real part for the x-coordinate and the imaginary part for the y-coordinate. When we move East/West, we add an amount to the real part; when we move North/South, we add an amount to the imaginary part. That simplifies the arithmetic.</p>
<p>What is more interesting is how complex numbers help us with the rotations. If you multiply complex numbers \( x+iy \) and \( v + iw \) you get \( (xv-yw) + i(xw+yv) \). That is just how multiplication is defined for these buggers. But it is interesting for us, because we can construct the transformations from above from this. If we take the imaginary number \(i\) and put raise it to increasing powers we get</p>
<p>$$i^0 = 1 +i0$$
$$i^1 = 0+i1$$
$$i^2 = -1+0i$$
$$i^3 = 0-1i$$</p>
<p>after which it cycles back to 1 again. Now take a point, \( (x,y) \) represented as a complex number, \( z = x+iy \), and multiply it with these powers.</p>
<p>$$ (x,y) \mapsto (x,y)\cdot i^0 = (x+iy)(1+i0) = x + iy = (x,y) $$
$$ (x,y) \mapsto (x,y)\cdot i^1 = (x+iy)(0+i1) = -y + ix = (-y,x) $$
$$ (x,y) \mapsto (x,y)\cdot i^2 = (x+iy)(-1+i0) = -x - iy = (-x,-y) $$
$$ (x,y) \mapsto (x,y)\cdot i^3 = (x+iy)(0-i1) = y - ix = (y,-x) $$</p>
<p>These are the transitions from above. So, if you want to rotate by 90 degrees, you multiply your coordinates (as a complex number) by \( i^1 \). If you want to rotate them more, in steps of 90 degrees, raise \( i \) to higher powers. With this trick, we can solve the puzzle like this:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">
<span style="color:#000080;font-weight:bold">class</span> Ship(object):
    <span style="color:#000080;font-weight:bold">def</span> __init__(self):
        self.wp  = <span style="color:#00f">10</span> + <span style="color:#00f">1j</span>
        self.pos =  <span style="color:#00f">0</span> + <span style="color:#00f">0j</span>

    @property
    <span style="color:#000080;font-weight:bold">def</span> manhattan_dist(self):
        <span style="color:#000080;font-weight:bold">return</span> abs(self.pos.real) + abs(self.pos.imag)

    <span style="color:#080;font-style:italic"># Ops...</span>
    <span style="color:#000080;font-weight:bold">def</span> N(self, amount): self.wp += amount*<span style="color:#00f">1j</span>
    <span style="color:#000080;font-weight:bold">def</span> S(self, amount): self.wp -= amount*<span style="color:#00f">1j</span>
    <span style="color:#000080;font-weight:bold">def</span> E(self, amount): self.wp += amount
    <span style="color:#000080;font-weight:bold">def</span> W(self, amount): self.wp -= amount
    <span style="color:#000080;font-weight:bold">def</span> L(self, angle):  self.wp *= <span style="color:#00f">1j</span> ** (angle // <span style="color:#00f">90</span>)
    <span style="color:#000080;font-weight:bold">def</span> R(self, angle):  self.wp *= <span style="color:#00f">1j</span> ** (-angle // <span style="color:#00f">90</span>)
    <span style="color:#000080;font-weight:bold">def</span> F(self, amount): self.pos += amount * self.wp

ship = Ship()
dispatcher = {op: getattr(ship, op) <span style="color:#000080;font-weight:bold">for</span> op <span style="font-weight:bold">in</span> <span style="color:#00f">&#34;NSEWLRF&#34;</span>}

f = open(<span style="color:#00f">&#39;/Users/mailund/Projects/adventofcode/2020/12/input.txt&#39;</span>)
<span style="color:#000080;font-weight:bold">for</span> op <span style="font-weight:bold">in</span> [line.strip() <span style="color:#000080;font-weight:bold">for</span> line <span style="font-weight:bold">in</span> f]:
    dispatcher[op[<span style="color:#00f">0</span>]](int(op[<span style="color:#00f">1</span>:]))
<span style="color:#000080;font-weight:bold">print</span>(f<span style="color:#00f">&#34;Puzzle #2: {round(ship.manhattan_dist)}&#34;</span>)
</code></pre></div><p>In Python, the imaginary number is <code>j</code>. Well, if you have a number in front of <code>j</code> it is an imaginary number; <code>j</code> is just a variable name otherwise. But you create complex numbers using <code>j</code>. Mathematicians use \(i\) for imaginary numbers and electrical engineers use \(j\), and Python follows the latter convention. (I use the former here, except in code).</p>
<p>This implementation only handles angles that are multiples of 90 degrees, but we can generalise it. The trigonometry we used for rotations earlier can also be phrased in terms of complex numbers. The rotation worked by mapping \( (x,y) \) to \( (x\cos\theta - y\sin\theta, x\sin\theta + y\cos\theta) \) for angle \(\theta\). If we call \( v=\cos\theta \) and \( w=\sin\theta \), then that is \( (xv - yw, xw + yv) \) which is the product of complex numbers \( x+iy \) and \( v+iw \). So if we can translate an angle \(\theta\) into the number \(\cos\theta + i\sin\theta\), then we have a general rotation. And we can, because that is what exponentiation does to complex numbers.</p>
<p>If you take an angle \(\theta\) (in radiants), then \(e^{i\theta} = \cos\theta + i\sin\theta\). Thus, we can get a general ship implementation with complex numbers like this:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000080;font-weight:bold">class</span> Ship(object):
    <span style="color:#000080;font-weight:bold">def</span> __init__(self):
        self.wp  = <span style="color:#00f">10</span> + <span style="color:#00f">1j</span>
        self.pos =  <span style="color:#00f">0</span> + <span style="color:#00f">0j</span>

    @property
    <span style="color:#000080;font-weight:bold">def</span> manhattan_dist(self):
        <span style="color:#000080;font-weight:bold">return</span> abs(self.pos.real) + abs(self.pos.imag)

    <span style="color:#080;font-style:italic"># Ops...</span>
    <span style="color:#000080;font-weight:bold">def</span> N(self, amount): self.wp += amount*<span style="color:#00f">1j</span>
    <span style="color:#000080;font-weight:bold">def</span> S(self, amount): self.wp -= amount*<span style="color:#00f">1j</span>
    <span style="color:#000080;font-weight:bold">def</span> E(self, amount): self.wp += amount
    <span style="color:#000080;font-weight:bold">def</span> W(self, amount): self.wp -= amount
    <span style="color:#000080;font-weight:bold">def</span> L(self, angle):  self.wp *= e ** (angle * pi/<span style="color:#00f">180</span> * <span style="color:#00f">1j</span>)
    <span style="color:#000080;font-weight:bold">def</span> R(self, angle):  self.wp *= e ** (-angle * pi/<span style="color:#00f">180</span> * <span style="color:#00f">1j</span>)
    <span style="color:#000080;font-weight:bold">def</span> F(self, amount): self.pos += amount * self.wp
</code></pre></div><h2 id="day-13--shuttle-search">Day 13 — Shuttle Search</h2>
<p>This was my least favourite day so far, because the difficulty entirely depends on whether you happen to remember a result from number theory. I was lucky, but I dislike puzzles whose difficulty depends so crucially on whether you know a bit of trivia. But I am getting ahead of myself…</p>
<p>Read <a href="https://adventofcode.com/2020/day/13">the program description</a>. If you haven’t already solved Puzzle #1, then you can’t see the part that I was hinting at, so we will quickly get the first puzzle out of our way and then get to Puzzle #2, that is either trivial or hard, depending on your background.</p>
<p>We get a list of busses, that depart at various frequencies. Most of the explanation is misdirection, because the only thing that matters is that bus \(b_i\) will depart at integers that are multiples of \(b_i\), i.e., \(0b_i, 1b_i, 2b_i, \ldots\). We then have a departure time, let’s call it \(d\), and we must identify the first bus that departs after \(d\), \(b\), and the waiting time between \(d\) and when it departs, \(w\), and the answer to the puzzle is \(b\cdot w\).</p>
<p>Whenever you have a problem that involves something that happens at regular intervals, you want to look at modular arithmetic. It isn’t always where a solution lies, but it is more often than not.</p>
<p>Usually, it is something simple, like “a bus leaves the station every 17 minutes, from six in the morning to six in the evening, write down the schedule”. That means it is a period of 17 minutes, but you can’t write “6:00, 6:17, 6:34, 6:51, 6:68, 6:85, …” because an hour only has 60 minutes. But you can get the minutes modulo 60, <code>minute = k * 17 % 60</code> and the hour by devision <code>hour = k * 17 // 60</code> (remember integer division, which is <code>//</code> in Python).</p>
<p>Here, the situation is not quite that simple, but almost. We need to work out the waiting time for each bus, which isn’t the bus’ frequency modulo anything. But consider the busses’ periods, \({0b_i, 1b_i, 2b_i, \ldots, kb_i, (k+1)b_i, \ldots}\). We can draw them like this, where the vertical line would be the departure time we are interested in.</p>
<p><img src="busses.png" alt=""></p>
<p>The busses run in different intervals, the boxes, and when we put down a departure time, we cut one of those intervals in two (where one of the two parts could have length zero, if the departure time is a multiple of the frequency). In the picture, I have show the two parts in dark and light grey. If you do division \(d / b_i\) you will get the number of white boxes for bus \(b_i\) before the departure time. That is the whole number of times you can complete an interval before \(d\). The dark gray is the remaining time up to \(d\), or \(d\) mod \(b_i\). We are interested in the light grey, which must then be \(b_i - d\) mod \(b_i\).</p>
<p>When you have done these kinds of problems a few times, your brain will jump to this inference faster that you can read the explanation, but if you are ever stumped, make a figure like this, and things will likely quickly click. Every time I run into a problem where the solution isn’t immediately obvious, I start drawing. It is only when I have done that enough that my subconscious programmer take over, and just tells me the solution, that I don’t draw. Drawing, and solving puzzles, are intrinsically tied for me.</p>
<p>Anyway, when we realise that waiting times are \(b_i - d\) mod \(b_i\), finding the smallest and multiplying the waiting time with the bus frequency is trivial:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">f = open(<span style="color:#00f">&#39;/Users/mailund/Projects/adventofcode/2020/13/input.txt&#39;</span>)
depart = int(f.readline())
busses = [int(bus) <span style="color:#000080;font-weight:bold">for</span> bus <span style="font-weight:bold">in</span> f.read().strip().split(<span style="color:#00f">&#39;,&#39;</span>) <span style="color:#000080;font-weight:bold">if</span> bus != <span style="color:#00f">&#39;x&#39;</span>]

<span style="color:#080;font-style:italic"># Puzzle #1: Get the earliest bus after departure...</span>
w, b = min((b - depart % b, b) <span style="color:#000080;font-weight:bold">for</span> b <span style="font-weight:bold">in</span> busses)
<span style="color:#000080;font-weight:bold">print</span>(f<span style="color:#00f">&#34;Puzzle #1: {b * w}&#34;</span>)
</code></pre></div><p>That only took a few minutes to solve, and Puzzle #2 was just as simple (although I did spend a bit longer implementing an algorithm that I didn’t find out was already in <code>SymPy</code> until later). But Puzzle #2 is only simple if you know the <a href="https://en.wikipedia.org/wiki/Chinese_remainder_theorem">Chinese Remainder Theorem</a>, and this is why I don’t like day 13. I find it unreasonable that those who are lucky to know CRT (and lucky enough to remember it) will have a trivial problem, while those that do not, are in for the unpleasant task of reinventing it. There are always cases where knowing a trick can greatly speed up problem solving, but this is one piece of trivia that makes or breaks the problem. And it is not something you run into that often. I don’t think I have used CRT in 20 years, and it was utter undiluted luck that I recognised it here.</p>
<p>There is lots of mathematics that I once new but couldn’t tell you what is if my life depended on it—I know there is something called a Gaussian curvature, but if you put a gun to my head and demanded that I tell you what it is, I would be dead. There are some tricks and techniques that I think every programmer should know, and things that pop up often in everyday programming is reasonable to expect people to know. While the CRT is not completely obscure, I wouldn’t put it in this category.</p>
<p>You can expect that a mathematician will recognise it, of course. A few days later I talked to a friend from the Math department, and when I explained the puzzle I wasn’t 30 seconds in before he said “du skal bruge den kinesiske restsætning!” (He was speaking Danish; it means “you need to use the Chinese remainder theorem”—google translate will back me up on this). So yeah, for the right people, this is essential knowledge. I don’t think it is for programmers, and judging from Twitter responses to this puzzle, people who didn’t know CRT were having a tough day. I think that is unfair.</p>
<p>Anyway, read on, and then you will also know CRT.</p>
<p>The puzzle is now this: We consider the index at which we see busses (after compensation for “missing” busses, encoded as <code>”x”</code>). I will call them offsets, because that is how we will use them. Each bus, \(b_i\) has an offset \(o_i\), and we need to find a time, \(t\), such that bus \(b_i\) will depart at time \(t+o_i\) for all busses \(b_i\). We know that the waiting time for bus \(b_i\) will be \(b_i - t\) mod \(b_i\)—we just worked that out in Puzzle #1—so the task is to find \(t\) such that \(b_i -t\) mod \(b_i = o_i\), or \(t\) mod \(b_i = b_i - o_i\).</p>
<p>We can then reformulate this, once more, to say that we have \(k\) equations:</p>
<p>$$t \equiv b_1-o_1 \mod b_1$$
$$t \equiv b_2-o_2 \mod b_2$$
$$\ldots$$
$$t \equiv b_k-o_k \mod b_k$$</p>
<p>That rang a bell! I freely admit that I had to look up the Chinese remainder theorem to check, but I was right. It says that for numbers \(a_1,\ldots,a_k\) and \(n_1,\ldots,n_,\) with \(N=\prod n_i\), there is a unique solution \(0\leq x &lt; N\) to</p>
<p>$$x \equiv a_1 \mod n_1$$
$$x \equiv a_2 \mod n_2$$
$$\ldots$$
$$x \equiv a_k \mod n_k$$</p>
<p>if the \(n_i\) are co-prime. The co-prime is important, and was part of what triggered my memory; I had just noticed that the busses had prime numbers, and figured there was a reason for that—which started my brain searching for such a reason.</p>
<p>Anyway, just because we know that something exists, doesn’t mean that we can find it. We know that all integers can be factored into primes, but that doesn’t tell us what the factorisation is for any given number. With CRT, however, there is an algorithm that will give us \(x\). Since it is unique between 0 and \(N\), it is also the smallest, so it is the solution to our puzzle.</p>
<p>I had to google around to find out how to do this, and then implement it, but you don’t have to. Because it is in <code>SymPy</code>. You can solve Puzzle #2 this easily:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">f = open(<span style="color:#00f">&#39;/Users/mailund/Projects/adventofcode/2020/13/input.txt&#39;</span>)
depart = int(f.readline())
busses = [(offset, int(bus))
            <span style="color:#000080;font-weight:bold">for</span> offset, bus <span style="font-weight:bold">in</span> enumerate(f.read().strip().split(<span style="color:#00f">&#39;,&#39;</span>))
            <span style="color:#000080;font-weight:bold">if</span> bus != <span style="color:#00f">&#39;x&#39;</span>]

<span style="color:#000080;font-weight:bold">from</span> sympy.ntheory.modular <span style="color:#000080;font-weight:bold">import</span> crt 
n = [b <span style="color:#000080;font-weight:bold">for</span> o,b <span style="font-weight:bold">in</span> busses]
a = [(b - o) <span style="color:#000080;font-weight:bold">for</span> o,b <span style="font-weight:bold">in</span> busses]
x, N = crt(n, a)
<span style="color:#000080;font-weight:bold">print</span>(f<span style="color:#00f">&#34;Puzzle #2: {x}&#34;</span>)
</code></pre></div><p>The <code>crt()</code> function returns \(x\) and \(N\), and our puzzle answer is \(x\).</p>
<p>If I knew I had <code>crt()</code> readily available, it would have been a 10 minutes puzzle. It was closer to 30 because I had to find the algorithm and implement it. But that is still quite a bit faster than if I had to come up with a solution from nothing.</p>


</article>


<section class="post-nav">
    <ul>
        
        <li>
            <a href="https://mailund.dk/posts/aoc-2020-3/"><i class="fa fa-chevron-circle-left"></i> Advent of Code 2020 — days 09–11</a>
        </li>
        
        
        <li>
            <a href="https://mailund.dk/posts/aoc-2020-5/">Advent of Code 2020 — days 14-16 <i class="fa fa-chevron-circle-right"></i> </a>
        </li>
        
    </ul>
</section>
    
        <section class="comments-block">
      <button id="show-comments" style="display: none;"><i class="fa fa-comments-o"></i> Add/View Comments</button>
</section>

<section id="disqus_thread"></section>

<script>
      (function () {
            
            
            if (window.location.hostname == "localhost")
                  return;

            var disqus_loaded = false;
            var disqus_shortname = 'mailund-dk';
            var disqus_button = document.getElementById("show-comments");

            disqus_button.style.display = "";
            disqus_button.addEventListener("click", disqus, false);

            function disqus() {

                  if (!disqus_loaded) {
                        disqus_loaded = true;

                        var e = document.createElement("script");
                        e.type = "text/javascript";
                        e.async = true;
                        e.src = "//" + disqus_shortname + ".disqus.com/embed.js";
                        (document.getElementsByTagName("head")[0] ||
                              document.getElementsByTagName("body")[0])
                        .appendChild(e);

                        
                        document.getElementById("show-comments").style.display = "none";
                  }
            }

            
            var hash = window.location.hash.substr(1);
            if (hash.length > 8) {
                  if (hash.substring(0, 8) == "comment-") {
                        disqus();
                  }
            }

            
            if (/bot|google|baidu|bing|msn|duckduckgo|slurp|yandex/i.test(navigator.userAgent)) {
                  disqus();
            }
      })();
</script>
    





</main>
    <footer>
        <h6>Copyright © 2020 - Thomas Mailund |
            Rendered by <a href="https://gohugo.io" title="Hugo">Hugo</a> |
            <a href="https://mailund.dk/index.xml">Subscribe</a></h6>
    </footer>
</div>
<script src="https://mailund.dk/js/scripts.js"></script>
</body>
<div id="amzn-assoc-ad-04956520-8388-43ab-9b6e-fbe758d208f8"></div>
<script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=04956520-8388-43ab-9b6e-fbe758d208f8"></script>

<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

</html>
