<!doctype html>

<html lang="en">

<head>
  <title>Mailund on the Internet</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="The HTML5 Herald" />
  <meta name="author" content="" />
  

  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/7.0.0/normalize.min.css" />

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />

<link rel="stylesheet" type="text/css" href="https://mailund.dk/css/styles.css" />
<link rel="stylesheet" href="https://cdn.rawgit.com/tonsky/FiraCode/1.205/distr/fira_code.css">

 
       <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Droid Sans" type="text/css" media="all" />
     
       <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Fira Mono" type="text/css" media="all" />
     

 <style>
 body {
     font-family: 'Droid Sans';
 }
 code {
    font-family: 'Fira Code';
 }
 </style>

 <script type="text/javascript" async
   src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
   MathJax.Hub.Queue(function() {
     
     
     
     var all = MathJax.Hub.getAllJax(), i;
     for(i = 0; i < all.length; i += 1) {
         all[i].SourceElement().parentNode.className += ' has-jax';
     }
   });

   MathJax.Hub.Config({
   
   TeX: { equationNumbers: { autoNumber: "AMS" } }
   });
   MathJax.Hub.Config({
   tex2jax: {
     inlineMath: [['$$','$$'], ['\\(','\\)']],
     displayMath: [['$$$','$$$']],
     processEscapes: true,
     processEnvironments: true,
     skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
     TeX: { equationNumbers: { autoNumber: "AMS" },
          extensions: ["AMSmath.js", "AMSsymbols.js"] }
   }
   });
 </script>

      <script async src="https://www.googletagmanager.com/gtag/js?id=386493837"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', '386493837');
        }
      </script>
</head>

<body>
  <div id="container">
    <header>
      <h1>
                <a href="https://mailund.dk/">Mailund on the Internet</a>
            </h1>

      <ul id="social-media">
                
      </ul>
      
      <p><em>On Writing, Science, Programming and more</em></p>
      

    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="" href="https://mailund.dk/about/">
                <i class="fa-li fa  fa-lg"></i><span>About</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://mailund.dk/posts">
                <i class="fa-li fa  fa-lg"></i><span>Posts</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://mailund.dk/books/">
                <i class="fa-li fa  fa-lg"></i><span>Books</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://mailund.dk/fiction/">
                <i class="fa-li fa  fa-lg"></i><span>Fiction</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://mailund.dk/publications/">
                <i class="fa-li fa  fa-lg"></i><span>Publications</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://mailund.dk/software/">
                <i class="fa-li fa  fa-lg"></i><span>Software</span>
            </a>
        </li>
        
    </ul>
</nav>

    <main>




<article>

    <h1>OOP example in C</h1>

    
        <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-11-12T05:08:49&#43;01:00">Nov 12, 2020</time>
        </li>
        
        
        <li>
            Categories: 
            <em>
                
                    
                    <a href="https://mailund.dk/categories/writing/">Writing</a>
                
                    , 
                    <a href="https://mailund.dk/categories/programming/">Programming</a>
                
            </em>
        </li>
        

        
        <li>
            <em>
                
                    
                    <a href="https://mailund.dk/tags/books/">#books</a>
                
                    , 
                    <a href="https://mailund.dk/tags/writing/">#writing</a>
                
                    , 
                    <a href="https://mailund.dk/tags/programming/">#programming</a>
                
                    , 
                    <a href="https://mailund.dk/tags/c/">#C</a>
                
                    , 
                    <a href="https://mailund.dk/tags/oop/">#OOP</a>
                
                    , 
                    <a href="https://mailund.dk/tags/polymorphism/">#polymorphism</a>
                
            </em>
        </li>
        

        <li>8 min read</li>
    </ul>
</aside>
    

    <p>I&rsquo;m writing the chapter on function pointers in my C pointers book, and I want a nice example of how you can use them to implement rudimentary object-oriented programming with dynamic dispatch.</p>
<h2 id="casting-and-nested-structures">Casting and nested structures</h2>
<p>The way to do it is simple enough. The C standard guarantees that the first object you put in a <code>struct</code> goes at the first memory address of instances of that <code>struct</code>, and if you have a pointer to an instance of the <code>struct</code>, then you can safely cast it to a pointer to the first element. This means that if you nest <code>structs</code>, you can cast your way into the nesting. For example, with:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">struct</span> A {
</span></span><span style="display:flex;"><span>	<span style="color:#000080;font-weight:bold">int</span> a;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">struct</span> B {
</span></span><span style="display:flex;"><span>  <span style="color:#000080;font-weight:bold">struct</span> A a;
</span></span><span style="display:flex;"><span>  <span style="color:#000080;font-weight:bold">int</span> b;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">struct</span> C {
</span></span><span style="display:flex;"><span>  <span style="color:#000080;font-weight:bold">struct</span> B b;
</span></span><span style="display:flex;"><span>  <span style="color:#000080;font-weight:bold">int</span> c;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>you can access members of a <code>struct C</code> as if they were members of the nested <code>struct B</code> or the nested <code>struct A</code> in the <code>struct B</code>.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">struct</span> C *x = <span style="color:#080;font-style:italic">/* some allocation */</span>;
</span></span><span style="display:flex;"><span>assert(((B*)x)-&gt;b == x-&gt;b.b);
</span></span><span style="display:flex;"><span>assert(((A*)x)-&gt;a == x-&gt;b.a.a);
</span></span></code></pre></div><p>Anywhere you have a function that works with pointers to <code>struct A</code> or <code>struct B</code>, you can call the function with a pointer to an instance of <code>struct C</code>. (They have to be pointers, of course, because otherwise you copy members, and you will only copy members of the type the function expects).</p>
<p>The C standard promises a little more about the memory layout of <code>struct</code>s, and you wouldn&rsquo;t have to nest them here. If the <code>struct</code>s share a prefix of members, it also works.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">struct</span> A {
</span></span><span style="display:flex;"><span>  <span style="color:#000080;font-weight:bold">int</span> a;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">struct</span> B {
</span></span><span style="display:flex;"><span>  <span style="color:#000080;font-weight:bold">int</span> a;
</span></span><span style="display:flex;"><span>  <span style="color:#000080;font-weight:bold">int</span> b;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">struct</span> C {
</span></span><span style="display:flex;"><span>  <span style="color:#000080;font-weight:bold">int</span> a;
</span></span><span style="display:flex;"><span>  <span style="color:#000080;font-weight:bold">int</span> b;
</span></span><span style="display:flex;"><span>  <span style="color:#000080;font-weight:bold">int</span> c;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>If you want to use one <code>struct</code> as another, though, it is easier to next them.</p>
<h2 id="single-inheritance-objects-and-classes">Single inheritance objects and classes</h2>
<p>We can use this to create classes and objects (or instances) in an object-oriented programming sense. It is close to how C++ was originally implemented. Use nested <code>structs</code> for objects, so derived objects contains he data their base cases have, and for virtual functions (or functions with dynamic dispatch, or whatever you want to call them), use nested <code>structs</code> for classes.</p>
<p>For polymorphism/dynamic dispatch, have all objects carry a pointer to their class. When we need to call a polymorphic function, we can look up the concrete function in the object&rsquo;s class. We can define a class pointer as <code>void *</code>, so it can point to any structure, and define the most basic object as something that has such a pointer. I have also defined a macro, <code>basetype()</code> for the casting, just to make it explicit what we are doing. Then I have a macro, <code>vtbl</code> that gets the virtual function table, cast to a class type.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">typedef</span> <span style="color:#000080;font-weight:bold">void</span> * cls;
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">typedef</span> <span style="color:#000080;font-weight:bold">struct</span> { cls *cls; } obj;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008080">#define basetype(x, base) ((base *)x)
</span></span></span><span style="display:flex;"><span><span style="color:#008080">#define vtbl(inst, base) \
</span></span></span><span style="display:flex;"><span><span style="color:#008080">          basetype(((obj *)inst)-&gt;cls, base)
</span></span></span></code></pre></div><p>You can make the <code>basetype()</code> more type safe by going into the nested classes rather than casting, but it puts constraints on how the <code>struct</code>s must be nested, and if you modify the type hierarchy above a class, you would need to update the code. The cast does what it is supposed to do, if you are careful with it.</p>
<p>Classes must be allocated and initialised before we can use them. There&rsquo;s a function and macro for that:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> *alloc_cls(<span style="color:#000080;font-weight:bold">size_t</span> cls_size,
</span></span><span style="display:flex;"><span>                <span style="color:#000080;font-weight:bold">void</span> (*cls_init)(cls *))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  cls *cls = malloc(cls_size);
</span></span><span style="display:flex;"><span>  <span style="color:#000080;font-weight:bold">if</span> (!cls) abort(); <span style="color:#080;font-style:italic">// error handling
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>  cls_init(cls);
</span></span><span style="display:flex;"><span>  <span style="color:#000080;font-weight:bold">return</span> cls;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008080">#define INIT_CLS(p, init)                    \
</span></span></span><span style="display:flex;"><span><span style="color:#008080">  do {                                       \
</span></span></span><span style="display:flex;"><span><span style="color:#008080">    if (!p)                                  \
</span></span></span><span style="display:flex;"><span><span style="color:#008080">      p = alloc_cls(                         \
</span></span></span><span style="display:flex;"><span><span style="color:#008080">            sizeof *p, (void (*)(cls *))init \
</span></span></span><span style="display:flex;"><span><span style="color:#008080">          );                                 \
</span></span></span><span style="display:flex;"><span><span style="color:#008080">  } while(0)
</span></span></span></code></pre></div><p>The <code>INIT_CLS()</code> gets a pointer to the class, which I expect is a global variable, initially NULL. If the class hasn&rsquo;t been initialised yet, we allocate it, and use the <code>init</code> function provided to initialise it.</p>
<p>For objects, we can use</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> *alloc_obj(<span style="color:#000080;font-weight:bold">size_t</span> obj_size, cls cls)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  obj *obj = malloc(obj_size);
</span></span><span style="display:flex;"><span>  <span style="color:#000080;font-weight:bold">if</span> (!obj) abort(); <span style="color:#080;font-style:italic">// error handling
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>  obj-&gt;cls = cls;
</span></span><span style="display:flex;"><span>  <span style="color:#000080;font-weight:bold">return</span> obj;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#008080">#define NEW_OBJ(p, cls) alloc_obj(sizeof *p, cls)
</span></span></span></code></pre></div><p>The <code>NEW_OBJ()</code> macro creates an object and sets it class. There is not an initialisation function here, because I expect that initialisers will need arguments, so we cannot handle that generically. The same might be true for classes, but if that day arises, we can deal with it.</p>
<h2 id="an-expression-class-hierarchy">An expression class hierarchy</h2>
<p>For a concrete example, we can have generic arithmetic expressions. We can define their main interface as having a <code>print()</code> and an <code>eval()</code> function.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">typedef</span> <span style="color:#000080;font-weight:bold">struct</span> base_expr *EXP;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// Base class, class definition
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#000080;font-weight:bold">typedef</span> <span style="color:#000080;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#000080;font-weight:bold">void</span>   (*print)(EXP);
</span></span><span style="display:flex;"><span>  <span style="color:#000080;font-weight:bold">double</span> (*eval) (EXP);
</span></span><span style="display:flex;"><span>} base_expr_cls;
</span></span></code></pre></div><p>The functions are generic, so the implementation dispatch to the table in the class:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> print_expr(EXP e)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  vtbl(e, base_expr_cls)-&gt;print(e);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">double</span> eval_expr(EXP e)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#000080;font-weight:bold">return</span> vtbl(e, base_expr_cls)-&gt;eval(e);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>When we initialise the class, we don&rsquo;t put any methods in there. They are abstract.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> init_base_expr_cls(base_expr_cls *cls)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  cls-&gt;print = <span style="color:#00f">0</span>; <span style="color:#080;font-style:italic">// abstract method
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>  cls-&gt;eval  = <span style="color:#00f">0</span>; <span style="color:#080;font-style:italic">// abstract method
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>}
</span></span></code></pre></div><p>There is nothing in instances of the base class (except the nested <code>obj</code> needed for the class pointer).</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#080;font-style:italic">// Base class, object definition
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#000080;font-weight:bold">typedef</span> <span style="color:#000080;font-weight:bold">struct</span> base_expr {
</span></span><span style="display:flex;"><span>  obj obj;
</span></span><span style="display:flex;"><span>} base_expr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// Base class, methods
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#000080;font-weight:bold">void</span> init_base_expr(base_expr *inst)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-style:italic">// nothing to initialise...
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>}
</span></span></code></pre></div><p>A concrete expression type is one that merely holds a value. It can look like this:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#080;font-style:italic">// Value expressions
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#000080;font-weight:bold">typedef</span> <span style="color:#000080;font-weight:bold">struct</span>  {
</span></span><span style="display:flex;"><span>  base_expr_cls base_expr_cls;
</span></span><span style="display:flex;"><span>} value_expr_cls;
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">typedef</span> <span style="color:#000080;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>  base_expr base_expr;
</span></span><span style="display:flex;"><span>  <span style="color:#000080;font-weight:bold">double</span> value;
</span></span><span style="display:flex;"><span>} value_expr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// Concrete class, so must have a struct
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>value_expr_cls *VALUE_EXPR_CLS = <span style="color:#00f">0</span>; <span style="color:#080;font-style:italic">// must be initialised
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> value_expr_print(value_expr *val)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  printf(<span style="color:#00f">&#34;%.3f&#34;</span>, val-&gt;value);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">double</span> value_expr_eval(value_expr *val)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#000080;font-weight:bold">return</span> val-&gt;value;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> init_value_expr_cls(value_expr_cls *cls)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  init_base_expr_cls(basetype(cls, base_expr_cls));
</span></span><span style="display:flex;"><span>  basetype(cls, base_expr_cls)-&gt;print =
</span></span><span style="display:flex;"><span>            (<span style="color:#000080;font-weight:bold">void</span> (*)(EXP))value_expr_print;
</span></span><span style="display:flex;"><span>  basetype(cls, base_expr_cls)-&gt;eval  =
</span></span><span style="display:flex;"><span>            (<span style="color:#000080;font-weight:bold">double</span> (*)(EXP))value_expr_eval;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> init_value_expr(value_expr *val, <span style="color:#000080;font-weight:bold">double</span> value)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  init_base_expr(basetype(val, base_expr));
</span></span><span style="display:flex;"><span>  val-&gt;value = value;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// constructor
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>EXP value(<span style="color:#000080;font-weight:bold">double</span> value)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  INIT_CLS(VALUE_EXPR_CLS, init_value_expr_cls);
</span></span><span style="display:flex;"><span>  value_expr *val = NEW_OBJ(val, VALUE_EXPR_CLS);
</span></span><span style="display:flex;"><span>  init_value_expr(val, value);
</span></span><span style="display:flex;"><span>  <span style="color:#000080;font-weight:bold">return</span> (EXP)val;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The class holds the base class and nothing else. We are not introducing new virtual functions. The instance structure holds the base class&rsquo;s data and the value. Since it is a concrete class, we need a pointer to hold the class structure. We will initialise it before we create instances. We have an implementation of the two abstract virtual functions; we set them in the class initialisation code, after initialising the base class part. In the object initiations we initialise the base class part and then set the value. For a concrete class we need a constructor, here it is called <code>value()</code>, and it initialises the class (if it isn&rsquo;t already there), create a new object with the class, and then initialises object as a value.</p>
<p>In the code below, we define binary expressions and two sub-classes, one for addition and one for subtraction. They follow the pattern we used for the values class.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#080;font-style:italic">// Binary expressions
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#000080;font-weight:bold">typedef</span> <span style="color:#000080;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>  base_expr_cls base_expr_cls;
</span></span><span style="display:flex;"><span>} binary_expr_cls;
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">typedef</span> <span style="color:#000080;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>  base_expr base_expr;
</span></span><span style="display:flex;"><span>  <span style="color:#000080;font-weight:bold">char</span> symb;
</span></span><span style="display:flex;"><span>  EXP left, right;
</span></span><span style="display:flex;"><span>} binary_expr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> print_binary_expr(binary_expr *binop)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  putchar(<span style="color:#800080">&#39;(&#39;</span>);
</span></span><span style="display:flex;"><span>    print_expr(binop-&gt;left);
</span></span><span style="display:flex;"><span>  putchar(<span style="color:#800080">&#39;)&#39;</span>);
</span></span><span style="display:flex;"><span>  putchar(binop-&gt;symb);
</span></span><span style="display:flex;"><span>  putchar(<span style="color:#800080">&#39;(&#39;</span>);
</span></span><span style="display:flex;"><span>    print_expr(binop-&gt;right);
</span></span><span style="display:flex;"><span>  putchar(<span style="color:#800080">&#39;)&#39;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> init_binary_expr_cls(binary_expr_cls *cls)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  init_base_expr_cls(basetype(cls, base_expr_cls));
</span></span><span style="display:flex;"><span>  basetype(cls, base_expr_cls)-&gt;print =
</span></span><span style="display:flex;"><span>          (<span style="color:#000080;font-weight:bold">void</span> (*)(EXP))print_binary_expr;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> init_binary_expr(binary_expr *binop,
</span></span><span style="display:flex;"><span>                      <span style="color:#000080;font-weight:bold">char</span> symb, EXP left, EXP right)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  init_base_expr(basetype(binop, base_expr));
</span></span><span style="display:flex;"><span>  binop-&gt;symb = symb;
</span></span><span style="display:flex;"><span>  binop-&gt;left = left;
</span></span><span style="display:flex;"><span>  binop-&gt;right = right;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// Addition
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#000080;font-weight:bold">typedef</span> <span style="color:#000080;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>  binary_expr_cls binary_expr_cls;
</span></span><span style="display:flex;"><span>} add_expr_cls;
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">typedef</span> <span style="color:#000080;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>  binary_expr binary_expr;
</span></span><span style="display:flex;"><span>} add_expr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// Concrete class, so must have a struct
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>add_expr_cls *ADD_EXPR_CLS = <span style="color:#00f">0</span>; <span style="color:#080;font-style:italic">// must be initialised
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">double</span> eval_add_expr(add_expr *expr)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#000080;font-weight:bold">return</span> eval_expr(basetype(expr, binary_expr)-&gt;left) +
</span></span><span style="display:flex;"><span>         eval_expr(basetype(expr, binary_expr)-&gt;right);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> init_add_expr_cls(add_expr_cls *cls)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  init_binary_expr_cls(basetype(cls, binary_expr_cls));
</span></span><span style="display:flex;"><span>  basetype(cls, base_expr_cls)-&gt;eval =
</span></span><span style="display:flex;"><span>          (<span style="color:#000080;font-weight:bold">double</span> (*)(EXP))eval_add_expr;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> init_add_expr(add_expr *expr, EXP left, EXP right)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  init_binary_expr(basetype(expr, binary_expr),
</span></span><span style="display:flex;"><span>                   <span style="color:#800080">&#39;+&#39;</span>, left, right);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// constructor
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>EXP add(EXP left, EXP right)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  INIT_CLS(ADD_EXPR_CLS, init_add_expr_cls);
</span></span><span style="display:flex;"><span>  add_expr *expr = NEW_OBJ(expr, ADD_EXPR_CLS);
</span></span><span style="display:flex;"><span>  init_add_expr(expr, left, right);
</span></span><span style="display:flex;"><span>  <span style="color:#000080;font-weight:bold">return</span> (EXP)expr;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// Subtraction
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#000080;font-weight:bold">typedef</span> <span style="color:#000080;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>  binary_expr_cls binary_expr_cls;
</span></span><span style="display:flex;"><span>} sub_expr_cls;
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">typedef</span> <span style="color:#000080;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>  binary_expr binary_expr;
</span></span><span style="display:flex;"><span>} sub_expr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// Concrete class, so must have a struct
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>sub_expr_cls *SUB_EXPR_CLS = <span style="color:#00f">0</span>; <span style="color:#080;font-style:italic">// must be initialised
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">double</span> eval_sub_expr(sub_expr *expr)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#000080;font-weight:bold">return</span> eval_expr(basetype(expr, binary_expr)-&gt;left) -
</span></span><span style="display:flex;"><span>         eval_expr(basetype(expr, binary_expr)-&gt;right);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> init_sub_expr_cls(sub_expr_cls *cls)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  init_binary_expr_cls(basetype(cls, binary_expr_cls));
</span></span><span style="display:flex;"><span>  basetype(cls, base_expr_cls)-&gt;eval =
</span></span><span style="display:flex;"><span>          (<span style="color:#000080;font-weight:bold">double</span> (*)(EXP))eval_sub_expr;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">void</span> init_sub_expr(add_expr *expr, EXP left, EXP right)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  init_binary_expr(basetype(expr, binary_expr),
</span></span><span style="display:flex;"><span>                   <span style="color:#800080">&#39;-&#39;</span>, left, right);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// constructor
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>EXP sub(EXP left, EXP right)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  INIT_CLS(SUB_EXPR_CLS, init_sub_expr_cls);
</span></span><span style="display:flex;"><span>  add_expr *expr = NEW_OBJ(expr, SUB_EXPR_CLS);
</span></span><span style="display:flex;"><span>  init_sub_expr(expr, left, right);
</span></span><span style="display:flex;"><span>  <span style="color:#000080;font-weight:bold">return</span> (EXP)expr;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>You can use the expressions like this:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">int</span> main(<span style="color:#000080;font-weight:bold">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  EXP expr =
</span></span><span style="display:flex;"><span>    add(value(<span style="color:#00f">1.0</span>),
</span></span><span style="display:flex;"><span>        sub(value(<span style="color:#00f">10.0</span>),
</span></span><span style="display:flex;"><span>            value(<span style="color:#00f">2.0</span>))
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>  print_expr(expr); putchar(<span style="color:#800080">&#39;\n&#39;</span>);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#00f">&#34;evaluates to %f</span><span style="color:#00f">\n</span><span style="color:#00f">&#34;</span>, eval_expr(expr));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#000080;font-weight:bold">return</span> <span style="color:#00f">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="a-new-example">A new example?</h2>
<p>The expressions example shows most of the ideas with implementing classes in this way, but there is not an example of adding to the interface. The abstract interface, <code>print()</code> and <code>eval()</code>, is all there is. I would like an example where I also add a virtual method to a subclass. I just cannot think of something that isn&rsquo;t entirely artificial, like &ldquo;animals are living things but can also move&hellip;&rdquo; or such things. If you have any suggestions, I would love to hear from you.</p>


</article>


<section class="post-nav">
    <ul>
        
        <li>
            <a href="https://mailund.dk/posts/c-refcount-list/"><i class="fa fa-chevron-circle-left"></i> Reference counting lists in C</a>
        </li>
        
        
        <li>
            <a href="https://mailund.dk/posts/aoc-2020-1/">Advent of Code 2020 — days 01-05 <i class="fa fa-chevron-circle-right"></i> </a>
        </li>
        
    </ul>
</section>
    





</main>
    <footer>
        <h6>Copyright © 2020-2025 - Thomas Mailund |
            Rendered by <a href="https://gohugo.io" title="Hugo">Hugo</a> |
            <a href="https://mailund.dk/index.xml">Subscribe</a></h6>
    </footer>
</div>
<script src="https://mailund.dk/js/scripts.js"></script>
</body>
<div id="amzn-assoc-ad-04956520-8388-43ab-9b6e-fbe758d208f8"></div>
<script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=04956520-8388-43ab-9b6e-fbe758d208f8"></script>

<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

</html>
