<!doctype html>

<html lang="en">

<head>
  <title>Mailund on the Internet</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="The HTML5 Herald" />
  <meta name="author" content="" />
  

  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/7.0.0/normalize.min.css" />

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />

<link rel="stylesheet" type="text/css" href="https://mailund.dk/css/styles.css" />
<link rel="stylesheet" href="https://cdn.rawgit.com/tonsky/FiraCode/1.205/distr/fira_code.css">

 
       <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Droid Sans" type="text/css" media="all" />
     
       <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Fira Mono" type="text/css" media="all" />
     

 <style>
 body {
     font-family: 'Droid Sans';
 }
 code {
    font-family: 'Fira Code';
 }
 </style>

 <script type="text/javascript" async
   src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
   MathJax.Hub.Queue(function() {
     
     
     
     var all = MathJax.Hub.getAllJax(), i;
     for(i = 0; i < all.length; i += 1) {
         all[i].SourceElement().parentNode.className += ' has-jax';
     }
   });

   MathJax.Hub.Config({
   
   TeX: { equationNumbers: { autoNumber: "AMS" } }
   });
   MathJax.Hub.Config({
   tex2jax: {
     inlineMath: [['$$','$$'], ['\\(','\\)']],
     displayMath: [['$$$','$$$']],
     processEscapes: true,
     processEnvironments: true,
     skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
     TeX: { equationNumbers: { autoNumber: "AMS" },
          extensions: ["AMSmath.js", "AMSsymbols.js"] }
   }
   });
 </script>

</head>

<body>
  <div id="container">
    <header>
      <h1>
                <a href="https://mailund.dk/">Mailund on the Internet</a>
            </h1>

      <ul id="social-media">
                
      </ul>
      
      <p><em>On Writing, Science, Programming and more</em></p>
      

    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="" href="https://mailund.dk/about/">
                <i class="fa-li fa  fa-lg"></i><span>About</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://mailund.dk/posts">
                <i class="fa-li fa  fa-lg"></i><span>Posts</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://mailund.dk/books/">
                <i class="fa-li fa  fa-lg"></i><span>Books</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://mailund.dk/fiction/">
                <i class="fa-li fa  fa-lg"></i><span>Fiction</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://mailund.dk/publications/">
                <i class="fa-li fa  fa-lg"></i><span>Publications</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://mailund.dk/software/">
                <i class="fa-li fa  fa-lg"></i><span>Software</span>
            </a>
        </li>
        
    </ul>
</nav>

    <main>




<article>

    <h1>Advent of Code 2020 — days 23 and 24</h1>

    
        <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-12-24T07:51:59&#43;01:00">Dec 24, 2020</time>
        </li>
        
        
        <li>
            Categories: 
            <em>
                
                    
                    <a href="https://mailund.dk/categories/programming/">Programming</a>
                
            </em>
        </li>
        

        
        <li>
            <em>
                
                    
                    <a href="https://mailund.dk/tags/python/">#python</a>
                
                    , 
                    <a href="https://mailund.dk/tags/programming/">#programming</a>
                
            </em>
        </li>
        

        <li>11 min read</li>
    </ul>
</aside>
    

    <p>Unexpectedly, I was allowed to play today—it <em>is</em> Christmas, after all—as long as I didn’t spend too much time at the computer. So I hurried up and solved today’s and yesterday’s puzzles quickly.</p>
<h2 id="day-23--crab-cups">Day 23 — Crab Cups</h2>
<p>On <a href="https://adventofcode.com/2020/day/23">Day 23</a>, we get another game. It is a game of shuffling cups around, and it reads very much like a circular list of cups. And mostly it is.</p>
<p>You have to take three cups to the right of the current and move it to elsewhere in your circular list, based on the index of the current cup. The rules are not that hard to decode, and you can implement the solution using Python’s lists and a little bit of modular arithmetic.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>inp = <span style="color:#00f">&#34;389125467&#34;</span> <span style="color:#080;font-style:italic"># test data</span>
</span></span><span style="display:flex;"><span>cups = list(map(int, inp))
</span></span><span style="display:flex;"><span>min_cup = min(cups)
</span></span><span style="display:flex;"><span>max_cup = max(cups)
</span></span><span style="display:flex;"><span>n = len(cups)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">def</span> next_three(i):
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">return</span> [ (i+k) % n <span style="color:#000080;font-weight:bold">for</span> k <span style="font-weight:bold">in</span> range(<span style="color:#00f">1</span>,<span style="color:#00f">4</span>) ]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"># Brute force with small list manipulations...</span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">def</span> round(cups, i):
</span></span><span style="display:flex;"><span>    current_cup = cups[i]
</span></span><span style="display:flex;"><span>    removed = [cups[i] <span style="color:#000080;font-weight:bold">for</span> i <span style="font-weight:bold">in</span> next_three(i)]
</span></span><span style="display:flex;"><span>    remaining = [c <span style="color:#000080;font-weight:bold">for</span> c <span style="font-weight:bold">in</span> cups <span style="color:#000080;font-weight:bold">if</span> c <span style="font-weight:bold">not</span> <span style="font-weight:bold">in</span> removed]
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    destination = current_cup - <span style="color:#00f">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">while</span> destination <span style="font-weight:bold">not</span> <span style="font-weight:bold">in</span> remaining:
</span></span><span style="display:flex;"><span>        destination -= <span style="color:#00f">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">if</span> destination &lt; min_cup:
</span></span><span style="display:flex;"><span>            destination = max_cup
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    j = remaining.index(destination)
</span></span><span style="display:flex;"><span>    remaining[j+<span style="color:#00f">1</span>:j+<span style="color:#00f">1</span>] = removed
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">return</span> remaining, (remaining.index(current_cup) + <span style="color:#00f">1</span>) % n
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">def</span> play(cups, rounds):
</span></span><span style="display:flex;"><span>    i = <span style="color:#00f">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">for</span> _ <span style="font-weight:bold">in</span> range(rounds):
</span></span><span style="display:flex;"><span>        cups, i = round(cups, i)
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">return</span> cups
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">def</span> rotation(cups, start):
</span></span><span style="display:flex;"><span>    i = cups.index(start)
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">return</span> <span style="color:#00f">&#39;&#39;</span>.join(str(cups[ (i+j+<span style="color:#00f">1</span>) % n ]) <span style="color:#000080;font-weight:bold">for</span> j <span style="font-weight:bold">in</span> range(n))[:-<span style="color:#00f">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#00f">f</span><span style="color:#00f">&#34;Puzzle #1: </span><span style="color:#00f">{</span>rotation(play(cups[:], <span style="color:#00f">100</span>), <span style="color:#00f">1</span>)<span style="color:#00f">}</span><span style="color:#00f">&#34;</span>)
</span></span></code></pre></div><p>When it comes to lists, linked lists and Python’s lists (which are arrays for all practical purposes), there are different performance tradeoffs. There always is with different data structures.</p>
<p>Linked lists will let us move a sub-list to another location in constant time (if we can extract the list in constant time, which we can here), but with arrays, we must copy the entire list to achieve this. Copying everything sounds slow, but it isn’t for small data sizes. Arrays sit in contiguous memory, and modern computer’s caches are really good at dealing with things like that. Add to this, that a linked list implemented in Python is bound to be much slower than Python’s own lists implemented in C. So for small data, slicing and composing the built-in lists is usually faster than rolling out a linked list.</p>
<p>For Puzzle #2, however, the size of the problem grows to a list of length one million, and we need to run ten million iterations of the game. Here, we enter a size where slow linked lists will outperform arrays for certain.</p>
<p>The solution above will run in time \( O(mn) \) where \( m \) is the number of rounds and \( n \) is the size of the list. This is far too slow if \(m\) is ten million and \(n\) is a million. With linked lists, we can make each iteration take constant time, and go down to \(m\), which is more manable.</p>
<p>To get there, we need to represent the cups in a circular linked list, and to get the destination, we need a constant time approach to get the destination from its number. If we have that, then we have a solution to the puzzle.</p>
<p>So, I implemented a cyclic doubly-linked list:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">class</span> Link(object):
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">def</span> __init__(self, val, prev = <span style="color:#000080;font-weight:bold">None</span>, next = <span style="color:#000080;font-weight:bold">None</span>):
</span></span><span style="display:flex;"><span>        self.val = val
</span></span><span style="display:flex;"><span>        self.prev = prev
</span></span><span style="display:flex;"><span>        self.next = next
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">if</span> self.prev <span style="font-weight:bold">is</span> <span style="font-weight:bold">not</span> <span style="color:#000080;font-weight:bold">None</span>:
</span></span><span style="display:flex;"><span>            self.prev.next = self
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">else</span>:
</span></span><span style="display:flex;"><span>            self.prev = self <span style="color:#080;font-style:italic"># circular list</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">if</span> self.next <span style="font-weight:bold">is</span> <span style="font-weight:bold">not</span> <span style="color:#000080;font-weight:bold">None</span>:
</span></span><span style="display:flex;"><span>            self.next.prev = self
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">else</span>:
</span></span><span style="display:flex;"><span>            self.next = self <span style="color:#080;font-style:italic"># circular list</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">def</span> __contains__(self, val):
</span></span><span style="display:flex;"><span>        link = self
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">while</span> <span style="color:#000080;font-weight:bold">True</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#000080;font-weight:bold">if</span> link.val == val: <span style="color:#000080;font-weight:bold">return</span> <span style="color:#000080;font-weight:bold">True</span>
</span></span><span style="display:flex;"><span>            link = link.next
</span></span><span style="display:flex;"><span>            <span style="color:#000080;font-weight:bold">if</span> link <span style="font-weight:bold">is</span> self: <span style="color:#000080;font-weight:bold">return</span> <span style="color:#000080;font-weight:bold">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">def</span> __str__(self):
</span></span><span style="display:flex;"><span>        links = [<span style="color:#00f">f</span><span style="color:#00f">&#34;</span><span style="color:#00f">{</span>self.val<span style="color:#00f">}</span><span style="color:#00f">&#34;</span>]
</span></span><span style="display:flex;"><span>        link = self.next
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">while</span> link != self:
</span></span><span style="display:flex;"><span>            links.append(<span style="color:#00f">f</span><span style="color:#00f">&#34;</span><span style="color:#00f">{</span>link.val<span style="color:#00f">}</span><span style="color:#00f">&#34;</span>)
</span></span><span style="display:flex;"><span>            link = link.next
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">return</span> <span style="color:#00f">&#34; -&gt; &#34;</span>.join(links)
</span></span></code></pre></div><p>Write a function for creating a linked list from a Python list, solely for convenience:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">def</span> make_linked_list(x):
</span></span><span style="display:flex;"><span>    link = Link(x[<span style="color:#00f">0</span>])
</span></span><span style="display:flex;"><span>    link.next = link.prev = link
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">for</span> y <span style="font-weight:bold">in</span> x[<span style="color:#00f">1</span>:]:
</span></span><span style="display:flex;"><span>        Link(y, link.prev, link) <span style="color:#080;font-style:italic"># appending</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">return</span> link
</span></span></code></pre></div><p>And then I wrote functions for moving the three cups in the game:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">def</span> take_three(link):
</span></span><span style="display:flex;"><span>    start = link.next
</span></span><span style="display:flex;"><span>    end = start.next.next
</span></span><span style="display:flex;"><span>    start.prev.next = end.next
</span></span><span style="display:flex;"><span>    end.next.prev = start.prev
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic"># make circular</span>
</span></span><span style="display:flex;"><span>    start.prev = end
</span></span><span style="display:flex;"><span>    end.next = start
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">return</span> start
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">def</span> insert_after(link, lst):
</span></span><span style="display:flex;"><span>    lst.prev.next = link.next
</span></span><span style="display:flex;"><span>    lst.prev.next.prev = lst.prev
</span></span><span style="display:flex;"><span>    link.next = lst ; lst.prev = link
</span></span></code></pre></div><p>Playing the game in Puzzle #2 works the same way as in Puzzle #1, but first we build the linked list, and we create a map from cup names to links, so we can get the destination cup in constant time.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>min_cup = <span style="color:#00f">1</span>
</span></span><span style="display:flex;"><span>max_cup = <span style="color:#00f">1_000_000</span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">def</span> dec(i):
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">return</span> (i - <span style="color:#00f">1</span>) <span style="color:#000080;font-weight:bold">if</span> (i - <span style="color:#00f">1</span>) &gt;= min_cup <span style="color:#000080;font-weight:bold">else</span> max_cup
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">def</span> play(starting_cups):
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic"># Fill the cups to the max</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">for</span> i <span style="font-weight:bold">in</span> range(<span style="color:#00f">10</span>, max_cup + <span style="color:#00f">1</span>):
</span></span><span style="display:flex;"><span>        Link(i, starting_cups.prev, starting_cups)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic"># starting cup</span>
</span></span><span style="display:flex;"><span>    cup = starting_cups
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic"># Build dict to map from index to link</span>
</span></span><span style="display:flex;"><span>    LINK_MAP = {}
</span></span><span style="display:flex;"><span>    LINK_MAP[cup.val] = cup
</span></span><span style="display:flex;"><span>    link = cup.next
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">while</span> link != cup:
</span></span><span style="display:flex;"><span>        LINK_MAP[link.val] = link
</span></span><span style="display:flex;"><span>        link = link.next
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic"># Now play the game...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">for</span> i <span style="font-weight:bold">in</span> range(<span style="color:#00f">10_000_000</span>):
</span></span><span style="display:flex;"><span>        removed = take_three(cup)
</span></span><span style="display:flex;"><span>        dest = dec(cup.val)
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">while</span> dest <span style="font-weight:bold">in</span> removed:
</span></span><span style="display:flex;"><span>            dest = dec(dest)
</span></span><span style="display:flex;"><span>        insert_after(LINK_MAP[dest], removed)
</span></span><span style="display:flex;"><span>        cup = cup.next
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">return</span> LINK_MAP[<span style="color:#00f">1</span>].next.val * LINK_MAP[<span style="color:#00f">1</span>].next.next.val
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>inp = <span style="color:#00f">&#34;389125467&#34;</span> <span style="color:#080;font-style:italic"># test data</span>
</span></span><span style="display:flex;"><span>cups = make_linked_list(list(map(int, inp)))
</span></span><span style="display:flex;"><span>print(<span style="color:#00f">f</span><span style="color:#00f">&#34;Puzzle #2: </span><span style="color:#00f">{</span>play(cups)<span style="color:#00f">}</span><span style="color:#00f">&#34;</span>)
</span></span></code></pre></div><p>The lists are doubly-linked, but they do not have to be. It makes it easier to insert one list into another, because the first link in a list also contains a pointer to the last, but since we only move lists of length three, we could hardwire it and save a little space.</p>
<p>I reached for doubly-linked lists right away, because the problem screams for them, and I knew I could solve it that way. But it is actually overkill. We can easily handle the the problem without a new class. After all, the only thing we need to make the algorithm fast is an indirect way to handle the “next” relationship. And an array will work just fine for that.</p>
<p>We can add another array to our data, where index \(i\) gives us the index of the cup clockwise from the cup with index \(i\), i.e., if the cup at index \(i\) has the cup with index \(j\) to its right, then <code>next[i] == j</code>. That is all we need to make it work.</p>
<p>This is easiest to do if all the indices up to the length of the array is in use, so I subtracted one from all the cup identifiers. They start at one and go to one million, but now they start at zero and go to 999,999. At the end, I have to get the two cups following cup zero instead of one, and I need to add one to their values before I multiply them. I still need a map from cup ids to indices, because the first ten are out of order, but I <em>only</em> need a map for the first ten indices. After that, each cup identity is also its index.</p>
<p>There is a little bit of bookkeeping to look up the next cup—you need to get the cup index and then the value in the <code>next</code> array—but it is nothing worse than we have seen many times before in our lives.</p>
<p>This approach gives us code like this:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>min_cup = <span style="color:#00f">1</span>
</span></span><span style="display:flex;"><span>max_cup = <span style="color:#00f">1_000_000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">def</span> play(starting_cups):
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic"># Zero-index instead</span>
</span></span><span style="display:flex;"><span>    starting_cups = [x - <span style="color:#00f">1</span> <span style="color:#000080;font-weight:bold">for</span> x <span style="font-weight:bold">in</span> starting_cups]
</span></span><span style="display:flex;"><span>    cups = starting_cups + list(range(max(starting_cups) + <span style="color:#00f">1</span>, max_cup))
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    LINK_MAP = { starting_cups[i]: i <span style="color:#000080;font-weight:bold">for</span> i <span style="font-weight:bold">in</span> range(len(starting_cups)) }
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">def</span> cup_idx(i): <span style="color:#000080;font-weight:bold">return</span> LINK_MAP[i] <span style="color:#000080;font-weight:bold">if</span> i <span style="font-weight:bold">in</span> LINK_MAP <span style="color:#000080;font-weight:bold">else</span> i
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    next_links = cups[<span style="color:#00f">1</span>:] + [cups[<span style="color:#00f">0</span>]]
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">def</span> next_cup(cup):
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">return</span> next_links[cup_idx(cup)]
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">def</span> set_next(cup, n):
</span></span><span style="display:flex;"><span>        next_links[cup_idx(cup)] = n
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic"># starting cup</span>
</span></span><span style="display:flex;"><span>    cup = cups[<span style="color:#00f">0</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic"># Now play the game...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">for</span> i <span style="font-weight:bold">in</span> range(<span style="color:#00f">10_000_000</span>):
</span></span><span style="display:flex;"><span>        a = next_cup(cup)
</span></span><span style="display:flex;"><span>        b = next_cup(a)
</span></span><span style="display:flex;"><span>        c = next_cup(b)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        dest = cup
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">while</span> dest <span style="font-weight:bold">in</span> [cup, a, b, c]:
</span></span><span style="display:flex;"><span>            dest -= <span style="color:#00f">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000080;font-weight:bold">if</span> dest &lt; <span style="color:#00f">0</span>: dest = max_cup - <span style="color:#00f">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        set_next(cup, next_cup(c)) <span style="color:#080;font-style:italic"># cup&#39;s next is past the three</span>
</span></span><span style="display:flex;"><span>        set_next(c, next_cup(dest))
</span></span><span style="display:flex;"><span>        set_next(dest, a)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        cup = next_cup(cup)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">return</span> (<span style="color:#00f">1</span> + next_cup(<span style="color:#00f">0</span>)) * (<span style="color:#00f">1</span> + next_cup(next_cup(<span style="color:#00f">0</span>)))
</span></span></code></pre></div><h2 id="day-24--lobby-layout">Day 24 — Lobby Layout</h2>
<p><a href="https://adventofcode.com/2020/day/24">On the 24th</a>, we get to play with hexagonal floor tiles. There is not much to those, except that you have to be a little careful with coordinates. If you move to a tile next to you, you have moved twice as far as if you go to the tile to the upper right of you. But other than that, you can think of tiles as their coordinates. If the center of a floor os (0,0), you can encode the tile to the right of you as (1,0) the one to your left as (-1,0), the one to the north-east as (1/2,1/2), the one to the south-east as (1/2,-1/2), and so on. Or, if you don’t like using floating point numbers, use (0,0) for the center, (2,0) for the tile to the East, (-2,0) for the tile to the West,  (-1,1) and (1,1) for the tiles above you, and (-1,-1) and (1,-1) for the tiles below you.</p>
<p>That is what I did, except that I used complex numbers. I figured that we might be in for a Puzzle #2 where we needed rotations or something, and complex numbers are easier there. I think something like that was going through my brain. But it doesn’t matter, I can use complex numbers as 2D vectors if I want to, and that was all I needed.</p>
<p>That being said, if this was code that should survive longer than this puzzle, I would change it back now. It is confusing to use complex numbers in this context.</p>
<p>Anyway, for Puzzle #1, we need to work out how many tiles have flipped to black from a path to the tiles. Decoding the path is straightforward. Keep an index into the string you are parsing, and if it points to a <code>n</code> or <code>s</code>, you are looking at half of a direction, and you have to go up or down (<code>1j</code> or <code>-1j</code>). After that, we work out how far to the left or right we need to go. If we don’t go up and down, the direction to the East or West should be a distance of 2, but if we go up or down, it should be a distance of 1, so I correct that when I see <code>n</code> or <code>s</code>. Otherwise, there is really nothing to it.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>f = open(<span style="color:#00f">&#39;/Users/mailund/Projects/adventofcode/2020/24/input.txt&#39;</span>)
</span></span><span style="display:flex;"><span>tiles = f.read().strip().split()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">def</span> identify_tile(x):
</span></span><span style="display:flex;"><span>    i, tile = <span style="color:#00f">0</span>, <span style="color:#00f">0</span> + <span style="color:#00f">0</span>j
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">while</span> i &lt; len(x):
</span></span><span style="display:flex;"><span>        ew_step = <span style="color:#00f">2</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">if</span> x[i] == <span style="color:#00f">&#39;n&#39;</span>:
</span></span><span style="display:flex;"><span>            tile += <span style="color:#00f">1</span>j
</span></span><span style="display:flex;"><span>            i += <span style="color:#00f">1</span>
</span></span><span style="display:flex;"><span>            ew_step = <span style="color:#00f">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">elif</span> x[i] == <span style="color:#00f">&#39;s&#39;</span>:
</span></span><span style="display:flex;"><span>            tile -= <span style="color:#00f">1</span>j
</span></span><span style="display:flex;"><span>            i += <span style="color:#00f">1</span>
</span></span><span style="display:flex;"><span>            ew_step = <span style="color:#00f">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">if</span> x[i] == <span style="color:#00f">&#39;e&#39;</span>:
</span></span><span style="display:flex;"><span>            tile += ew_step
</span></span><span style="display:flex;"><span>            i += <span style="color:#00f">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">else</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#000080;font-weight:bold">assert</span> x[i] == <span style="color:#00f">&#39;w&#39;</span>
</span></span><span style="display:flex;"><span>            tile -= ew_step
</span></span><span style="display:flex;"><span>            i += <span style="color:#00f">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">return</span> tile
</span></span></code></pre></div><p>When we have all the tile positions, we insert or remove them from a set of black tiles, and the size of the set when we are done is the answer to Puzzle #1:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">def</span> collect_black(tiles):
</span></span><span style="display:flex;"><span>    black_tiles = set()
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">for</span> x <span style="font-weight:bold">in</span> tiles:
</span></span><span style="display:flex;"><span>        tile = identify_tile(x)
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">if</span> tile <span style="font-weight:bold">in</span> black_tiles:
</span></span><span style="display:flex;"><span>            black_tiles.remove(tile)
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">else</span>:
</span></span><span style="display:flex;"><span>            black_tiles.add(tile)
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">return</span> black_tiles
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#00f">f</span><span style="color:#00f">&#34;Puzzle #1: </span><span style="color:#00f">{</span>len(collect_black(tiles))<span style="color:#00f">}</span><span style="color:#00f">&#34;</span>)
</span></span></code></pre></div><p>For Puzzle #2, we have a Game of Life-like puzzle, and we have seen many of those already. It is, in principle, on an infinite floor, so we can use the trick we used on <a href="https://mailund.dk/posts/aoc-2020-6/">Day 17</a>, of only keeping track of the tiles we need for the rules. We need to update tiles based on their black neighbours, so we can store the coordinate of black tiles only. When we need to update the floor, we iterate through the black tiles and their neighbours, and those are the only coordinates that might change into or remain black.</p>
<p>I wrote a class for that, although it wouldn’t have been harder to work with a set direction to be honest.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>NEIGHBOURS = [ <span style="color:#00f">1</span>+<span style="color:#00f">1</span>j, <span style="color:#00f">2</span>, <span style="color:#00f">1</span>-<span style="color:#00f">1</span>j, -<span style="color:#00f">1</span>-<span style="color:#00f">1</span>j, -<span style="color:#00f">2</span>, -<span style="color:#00f">1</span>+<span style="color:#00f">1</span>j ]
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">class</span> Floor(object):
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">def</span> __init__(self, tiles = ()):
</span></span><span style="display:flex;"><span>        self.blacks = collect_black(tiles)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">def</span> black_neighbours(self, tile):
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">return</span> sum( (tile + n) <span style="font-weight:bold">in</span> self.blacks <span style="color:#000080;font-weight:bold">for</span> n <span style="font-weight:bold">in</span> NEIGHBOURS )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">def</span> __iter__(self):
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">for</span> tile <span style="font-weight:bold">in</span> self.blacks:
</span></span><span style="display:flex;"><span>            <span style="color:#000080;font-weight:bold">yield</span> <span style="color:#00f">&#39;B&#39;</span>, tile, self.black_neighbours(tile)
</span></span><span style="display:flex;"><span>            <span style="color:#000080;font-weight:bold">for</span> n <span style="font-weight:bold">in</span> NEIGHBOURS:
</span></span><span style="display:flex;"><span>                <span style="color:#000080;font-weight:bold">if</span> tile + n <span style="font-weight:bold">not</span> <span style="font-weight:bold">in</span> self.blacks:
</span></span><span style="display:flex;"><span>                    <span style="color:#000080;font-weight:bold">yield</span> <span style="color:#00f">&#39;W&#39;</span>, tile + n, \
</span></span><span style="display:flex;"><span>                          self.black_neighbours(tile + n)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">def</span> next_floor(self):
</span></span><span style="display:flex;"><span>        floor = Floor()
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">for</span> col, coord, black_n <span style="font-weight:bold">in</span> self:
</span></span><span style="display:flex;"><span>            <span style="color:#000080;font-weight:bold">if</span> col == <span style="color:#00f">&#39;W&#39;</span> <span style="font-weight:bold">and</span> black_n == <span style="color:#00f">2</span>:
</span></span><span style="display:flex;"><span>                floor.blacks.add(coord)
</span></span><span style="display:flex;"><span>            <span style="color:#000080;font-weight:bold">elif</span> col == <span style="color:#00f">&#39;B&#39;</span> <span style="font-weight:bold">and</span> <span style="color:#00f">1</span> &lt;= black_n &lt;= <span style="color:#00f">2</span>:
</span></span><span style="display:flex;"><span>                floor.blacks.add(coord)
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">return</span> floor
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">def</span> __len__(self): <span style="color:#000080;font-weight:bold">return</span> len(self.blacks)
</span></span></code></pre></div><p>Evolving the floor works exactly as the other Game of Life puzzles this year, so nothing new here either:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>floor = Floor(tiles)
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">def</span> evolve(tiles, days):
</span></span><span style="display:flex;"><span>    floor = Floor(tiles)
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">for</span> _ <span style="font-weight:bold">in</span> range(days):
</span></span><span style="display:flex;"><span>        floor = floor.next_floor()
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">return</span> floor
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#00f">f</span><span style="color:#00f">&#34;Puzzle #2: </span><span style="color:#00f">{</span>len(evolve(tiles, <span style="color:#00f">100</span>))<span style="color:#00f">}</span><span style="color:#00f">&#34;</span>)
</span></span></code></pre></div><p>So all in all, this was a very easy day. Maybe, if I am lucky, I am allowed to play tomorrow again, and if it is just as simple, I will finish the puzzles on time.</p>


</article>


<section class="post-nav">
    <ul>
        
        <li>
            <a href="https://mailund.dk/posts/aoc-2020-9/"><i class="fa fa-chevron-circle-left"></i> Advent of Code 2020 — day 22</a>
        </li>
        
        
        <li>
            <a href="https://mailund.dk/posts/aoc-2020-11/">Advent of Code 2020 — day 25 <i class="fa fa-chevron-circle-right"></i> </a>
        </li>
        
    </ul>
</section>
    





</main>
    <footer>
        <h6>Copyright © 2020-2025 - Thomas Mailund |
            Rendered by <a href="https://gohugo.io" title="Hugo">Hugo</a> |
            <a href="https://mailund.dk/index.xml">Subscribe</a></h6>
    </footer>
</div>
<script src="https://mailund.dk/js/scripts.js"></script>
</body>
<div id="amzn-assoc-ad-04956520-8388-43ab-9b6e-fbe758d208f8"></div>
<script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=04956520-8388-43ab-9b6e-fbe758d208f8"></script>

<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

</html>
