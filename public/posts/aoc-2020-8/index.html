<!doctype html>

<html lang="en">

<head>
  <title>Mailund on the Internet</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="The HTML5 Herald" />
  <meta name="author" content="Thomas Mailund" />
  

  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/7.0.0/normalize.min.css" />

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />

<link rel="stylesheet" type="text/css" href="https://mailund.dk/css/styles.css" />
<link rel="stylesheet" href="https://cdn.rawgit.com/tonsky/FiraCode/1.205/distr/fira_code.css">

 
       <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Droid Sans" type="text/css" media="all" />
     
       <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Fira Mono" type="text/css" media="all" />
     

 <style>
 body {
     font-family: 'Droid Sans';
 }
 code {
    font-family: 'Fira Code';
 }
 </style>

 <script type="text/javascript" async
   src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
   MathJax.Hub.Queue(function() {
     
     
     
     var all = MathJax.Hub.getAllJax(), i;
     for(i = 0; i < all.length; i += 1) {
         all[i].SourceElement().parentNode.className += ' has-jax';
     }
   });

   MathJax.Hub.Config({
   
   TeX: { equationNumbers: { autoNumber: "AMS" } }
   });
   MathJax.Hub.Config({
   tex2jax: {
     inlineMath: [['$$','$$'], ['\\(','\\)']],
     displayMath: [['$$$','$$$']],
     processEscapes: true,
     processEnvironments: true,
     skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
     TeX: { equationNumbers: { autoNumber: "AMS" },
          extensions: ["AMSmath.js", "AMSsymbols.js"] }
   }
   });
 </script>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-10582357-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

</head>

<body>
  <div id="container">
    <header>
      <h1>
                <a href="https://mailund.dk/">Mailund on the Internet</a>
            </h1>

      <ul id="social-media">
        
        <li><a href="https://twitter.com/ThomasMailund"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
         
        <li><a href="https://www.linkedin.com/in/thomas-mailund-94153b1"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
         
        <li><a href="https://github.com/mailund"><i class="fab fa-github fa-lg" aria-hidden="true"></i></a></li>
          
        <li><a href="https://www.facebook.com/mailund"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
          
        <li><a href="https://patreon.com/mailund"><i class="fab fa-patreon fa-lg" aria-hidden="true"></i></a></li>
         
        <li><a href="https://www.goodreads.com/author/show/15484380.Thomas_Mailund"><i class="fab fa-goodreads fa-lg" aria-hidden="true"></i></a></li>
         
        <li><a href="https://www.stackoverflow.com/users/2170269/thomas-mailund"><i class="fab fa-stack-overflow fa-lg" aria-hidden="true"></i></a></li>
        
      </ul>
      
      <p><em>On Writing, Science, Programming and more</em></p>
      

    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="" href="https://mailund.dk/about/">
                <i class="fa-li fa  fa-lg"></i><span>About</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://mailund.dk/posts">
                <i class="fa-li fa  fa-lg"></i><span>Posts</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://mailund.dk/books/">
                <i class="fa-li fa  fa-lg"></i><span>Books</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://mailund.dk/publications/">
                <i class="fa-li fa  fa-lg"></i><span>Publications</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://mailund.dk/software/">
                <i class="fa-li fa  fa-lg"></i><span>Software</span>
            </a>
        </li>
        
    </ul>
</nav>

    <main>




<article>

    <h1>Advent of Code 2020 — days 20 and 21</h1>

    
        <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-12-21T07:51:59&#43;01:00">Dec 21, 2020</time>
        </li>
        
        
        <li>
            Categories: 
            <em>
                
                    
                    <a href="https://mailund.dk/categories/programming/">Programming</a>
                
            </em>
        </li>
        

        
        <li>
            <em>
                
                    
                    <a href="https://mailund.dk/tags/python/">#python</a>
                
                    , 
                    <a href="https://mailund.dk/tags/programming/">#programming</a>
                
            </em>
        </li>
        

        <li>13 min read</li>
    </ul>
</aside>
    

    <h2 id="day-20-jurassic-jigsaw">Day 20: Jurassic Jigsaw</h2>
<p><a href="https://adventofcode.com/2020/day/20">Day 20</a> we get tiles for a puzzle, and we have to work out the puzzle from them. The tiles can be rotated or flipped, but we can connect them by identifying how edges match.</p>
<p>Puzzle #1 is fairly straightforward. In my first attempt, I tracked both which edges connected to other tiles and whether they matched in reverse, but it became a book-keeping nightmare in Puzzle #2, so I gave up on that. Instead, I just match all edges and all pairs of tiles, both directly comparing the edges and comparing with one reversed, and collected how tiles are matched. There are no cases in my input where one edge matches more than one tile, which was nice to see, as that could be important.</p>
<p>For Puzzle #1, we only need to identify the corners of the puzzle, and those are the tiles with only two connections. I used the <code>Tile</code> class below to keep track of that. I didn’t add the rotations and flipping until Puzzle #2, but I am not going to remove the functionality just to show you a clean implementation here. I have already spent too much time on the puzzle today. The key aspect of the class is that we keep track of the image and the borders (that we automatically update when we modify it in Puzzle #2), and we will have a dictionary, <code>connections</code> that map borders to tiles that can match that border.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000080;font-weight:bold">def</span> keyflip(f, d):
    <span style="color:#000080;font-weight:bold">return</span> { f(k): v <span style="color:#000080;font-weight:bold">for</span> k,v <span style="font-weight:bold">in</span> d.items() }
<span style="color:#000080;font-weight:bold">def</span> ewflip(x):
    <span style="color:#000080;font-weight:bold">if</span> x == <span style="color:#00f">&#39;E&#39;</span>: <span style="color:#000080;font-weight:bold">return</span> <span style="color:#00f">&#39;W&#39;</span>
    <span style="color:#000080;font-weight:bold">if</span> x == <span style="color:#00f">&#39;W&#39;</span>: <span style="color:#000080;font-weight:bold">return</span> <span style="color:#00f">&#39;E&#39;</span>
    <span style="color:#000080;font-weight:bold">else</span>:        <span style="color:#000080;font-weight:bold">return</span> x
<span style="color:#000080;font-weight:bold">def</span> nsflip(x):
    <span style="color:#000080;font-weight:bold">if</span> x == <span style="color:#00f">&#39;N&#39;</span>: <span style="color:#000080;font-weight:bold">return</span> <span style="color:#00f">&#39;S&#39;</span>
    <span style="color:#000080;font-weight:bold">if</span> x == <span style="color:#00f">&#39;S&#39;</span>: <span style="color:#000080;font-weight:bold">return</span> <span style="color:#00f">&#39;N&#39;</span>
    <span style="color:#000080;font-weight:bold">else</span>:        <span style="color:#000080;font-weight:bold">return</span> x

<span style="color:#000080;font-weight:bold">class</span> Tile(object):
    <span style="color:#000080;font-weight:bold">def</span> __init__(self, tile_id, pixels):
        self.tile_id = tile_id
        self.pixels = pixels
        self.connections = {}

    <span style="color:#080;font-style:italic"># Border edges, north, east, south, west</span>
    @property
    <span style="color:#000080;font-weight:bold">def</span> N(self): <span style="color:#000080;font-weight:bold">return</span> self.pixels[<span style="color:#00f">0</span>]
    @property
    <span style="color:#000080;font-weight:bold">def</span> E(self): <span style="color:#000080;font-weight:bold">return</span> <span style="color:#00f">&#39;&#39;</span>.join(line[-<span style="color:#00f">1</span>] <span style="color:#000080;font-weight:bold">for</span> line <span style="font-weight:bold">in</span> self.pixels)
    @property
    <span style="color:#000080;font-weight:bold">def</span> S(self): <span style="color:#000080;font-weight:bold">return</span> self.pixels[-<span style="color:#00f">1</span>]
    @property
    <span style="color:#000080;font-weight:bold">def</span> W(self): <span style="color:#000080;font-weight:bold">return</span> <span style="color:#00f">&#39;&#39;</span>.join(line[<span style="color:#00f">0</span>] <span style="color:#000080;font-weight:bold">for</span> line <span style="font-weight:bold">in</span> self.pixels)
    @property
    <span style="color:#000080;font-weight:bold">def</span> edges(self): <span style="color:#000080;font-weight:bold">return</span> ( (e,getattr(self,e)) <span style="color:#000080;font-weight:bold">for</span> e <span style="font-weight:bold">in</span> <span style="color:#00f">&#34;NESW&#34;</span> )

    <span style="color:#000080;font-weight:bold">def</span> connect(self, ori, other):
        <span style="color:#080;font-style:italic"># In the general case, the same edge can match more than</span>
        <span style="color:#080;font-style:italic"># one other tile. That makes the problem harder, but</span>
        <span style="color:#080;font-style:italic"># here we check that it doesn&#39;t happen in our input</span>
        <span style="color:#000080;font-weight:bold">assert</span> ori <span style="font-weight:bold">not</span> <span style="font-weight:bold">in</span> self.connections
        self.connections[ori] = other

    <span style="color:#000080;font-weight:bold">def</span> rot(self, a, b):
        x = <span style="color:#00f">&#34;NESW&#34;</span>
        r = x.index(a) - x.index(b)
        <span style="color:#000080;font-weight:bold">if</span> r &lt; <span style="color:#00f">0</span>: r += <span style="color:#00f">4</span>

        <span style="color:#000080;font-weight:bold">for</span> _ <span style="font-weight:bold">in</span> range(r): <span style="color:#080;font-style:italic"># FIXME: be smarter, Thomas</span>
            self.pixels = [ *zip(*self.pixels[::-<span style="color:#00f">1</span>]) ]
        self.pixels = [ <span style="color:#00f">&#39;&#39;</span>.join(x) <span style="color:#000080;font-weight:bold">for</span> x <span style="font-weight:bold">in</span> self.pixels ]

        self.connections = {
            x[(i + r) % <span style="color:#00f">4</span>]: self.connections[x[i]]
            <span style="color:#000080;font-weight:bold">for</span> i <span style="font-weight:bold">in</span> range(<span style="color:#00f">4</span>) 
            <span style="color:#000080;font-weight:bold">if</span> x[i] <span style="font-weight:bold">in</span> self.connections
        }

    <span style="color:#000080;font-weight:bold">def</span> flip_horizontal(self):
        self.connections = keyflip(ewflip, self.connections)
        self.pixels = [ x[::-<span style="color:#00f">1</span>] <span style="color:#000080;font-weight:bold">for</span> x <span style="font-weight:bold">in</span> self.pixels ]

    <span style="color:#000080;font-weight:bold">def</span> flip_vertical(self):
        self.connections = keyflip(nsflip, self.connections)
        self.pixels = self.pixels[::-<span style="color:#00f">1</span>]

    <span style="color:#000080;font-weight:bold">def</span> __str__(self):
        <span style="color:#000080;font-weight:bold">return</span> <span style="color:#00f">&#34;</span><span style="color:#00f">\n</span><span style="color:#00f">&#34;</span>.join(
            [f<span style="color:#00f">&#34;{self.tile_id}&#34;</span>, *self.pixels]
        )
    <span style="color:#000080;font-weight:bold">def</span> __repr__(self):
        <span style="color:#000080;font-weight:bold">return</span> f<span style="color:#00f">&#34;tile {self.tile_id}&#34;</span>
</code></pre></div><p>Parsing the data is ugly, but there is nothing much to it:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#080;font-style:italic"># Parse the tiles...</span>
<span style="color:#000080;font-weight:bold">import</span> re
<span style="color:#000080;font-weight:bold">def</span> parse_tiles(fname):
    <span style="color:#000080;font-weight:bold">with</span> open(fname) <span style="color:#000080;font-weight:bold">as</span> f:
        tiles = []
        <span style="color:#000080;font-weight:bold">for</span> tile <span style="font-weight:bold">in</span> f.read().strip().split(<span style="color:#00f">&#39;</span><span style="color:#00f">\n\n</span><span style="color:#00f">&#39;</span>):
            tile = tile.split(<span style="color:#00f">&#39;</span><span style="color:#00f">\n</span><span style="color:#00f">&#39;</span>)
            tile_id, = re.match(<span style="color:#00f">r</span><span style="color:#00f">&#34;Tile (\d+):&#34;</span>,tile[<span style="color:#00f">0</span>]).groups()
            tiles.append(Tile(int(tile_id), tile[<span style="color:#00f">1</span>:]))
        <span style="color:#000080;font-weight:bold">return</span> tiles
</code></pre></div><p>To work out which tile can connect to which other tiles, there is nothing clever you can do, I think. You have to compare them to figure out if a match on a border is possible. (Unless you start making data structures of borders you can work in—I suppose that is also an option, but this \( O(n^2) \) part of the puzzle is not that slow, so I wouldn’t bother with it when we have so few tiles as we do. In any case, the problematic part with my implementation isn’t the matching, but the assumption that each edge can at most match one other tile. That is guaranteed to be false in a real problem, but dealing with it will be much much harder. So this bit of code suffices here:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#080;font-style:italic"># Connect the tiles...</span>
<span style="color:#000080;font-weight:bold">def</span> connect_tiles(tiles):
    <span style="color:#000080;font-weight:bold">def</span> connect(x, y):
        <span style="color:#000080;font-weight:bold">for</span> ori_x, edge_x <span style="font-weight:bold">in</span> x.edges:
            <span style="color:#000080;font-weight:bold">for</span> ori_y, edge_y <span style="font-weight:bold">in</span> y.edges:
                <span style="color:#000080;font-weight:bold">if</span> edge_x == edge_y <span style="font-weight:bold">or</span> edge_x == edge_y[::-<span style="color:#00f">1</span>]:
                    x.connect(ori_x, y)
                    y.connect(ori_y, x)

    <span style="color:#000080;font-weight:bold">for</span> i <span style="font-weight:bold">in</span> range(len(tiles)):
        <span style="color:#000080;font-weight:bold">for</span> j <span style="font-weight:bold">in</span> range(i + <span style="color:#00f">1</span>, len(tiles)):
            connect(tiles[i], tiles[j])

    <span style="color:#000080;font-weight:bold">return</span> tiles
</code></pre></div><p>At this point, all tiles know which neighbours they can match. A tile in the middle of the puzzle will have four neighbours, those on edges will have three, and the corners will have two. That makes it easy to extract the corners:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#080;font-style:italic"># Puzzle #1: get the tiles with two (four with flip) neighbours</span>
fname = <span style="color:#00f">&#39;/Users/mailund/Projects/adventofcode/2020/20/input.txt&#39;</span>
<span style="color:#000080;font-weight:bold">import</span> math
tiles = connect_tiles(parse_tiles(fname))
corners = [ tile <span style="color:#000080;font-weight:bold">for</span> tile <span style="font-weight:bold">in</span> tiles <span style="color:#000080;font-weight:bold">if</span> len(tile.connections) == <span style="color:#00f">2</span> ]
<span style="color:#000080;font-weight:bold">print</span>(f<span style="color:#00f">&#34;Puzzle #1: {math.prod(tile.tile_id for tile in corners )}&#34;</span>)
</code></pre></div><p>For me, Puzzle #2 was rather unpleasant. The way I kept track of connections was more complicated than that above, which became such a mess that I gave up on debugging it. I deleted all the code and took a break. When I got back to it, I went for the simple solution you see above. I still fucked up with the <code>edges</code> property, so it didn’t compute the edges each time you asked for it, which naturally became a problem and one that was hard to debug. There when well over an hour. After that, I had to chase down a bug in rotations, when the rotations need to go counter-clockwise. Simple enough debugging, but when you are in a bit of a hurry because you really ought to be doing something else, you try to force the code, and that rarely works.</p>
<p>Anyway, I decided to build the puzzle from the upper left corner, scanning one row at a time. When I know the tile on the left of a tile, I know how to fix it with rotations and flips to make it match, and the same goes when I know the tile above me. So I can start from the upper left, fix towards the right (or eastwards in the code) until I can go no further. Then the first row is done, so I go back to the first tile in the row, get its southern neighbour, fix it if necessary, and then build the next row from it.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000080;font-weight:bold">def</span> fix_east(west, east):
    ori = [k <span style="color:#000080;font-weight:bold">for</span> k,v <span style="font-weight:bold">in</span> east.connections.items() <span style="color:#000080;font-weight:bold">if</span> v == west][<span style="color:#00f">0</span>]
    east.rot(<span style="color:#00f">&#39;W&#39;</span>, ori)
    <span style="color:#000080;font-weight:bold">if</span> west.E != east.W:
        east.flip_vertical()
    <span style="color:#000080;font-weight:bold">assert</span> west.E == east.W
    <span style="color:#000080;font-weight:bold">if</span> <span style="color:#00f">&#39;N&#39;</span> <span style="font-weight:bold">in</span> east.connections:
        <span style="color:#000080;font-weight:bold">assert</span> east.N == east.connections[<span style="color:#00f">&#39;N&#39;</span>].S

<span style="color:#000080;font-weight:bold">def</span> fix_south(north, south):
    ori = [k <span style="color:#000080;font-weight:bold">for</span> k,v <span style="font-weight:bold">in</span> south.connections.items() <span style="color:#000080;font-weight:bold">if</span> v == north][<span style="color:#00f">0</span>]
    south.rot(<span style="color:#00f">&#39;N&#39;</span>, ori)
    <span style="color:#000080;font-weight:bold">if</span> north.S != south.N:
        south.flip_horizontal()
    <span style="color:#000080;font-weight:bold">assert</span> north.S == south.N
    
<span style="color:#000080;font-weight:bold">def</span> tile_row(x):
    res = []
    <span style="color:#000080;font-weight:bold">while</span> <span style="color:#00f">&#39;E&#39;</span> <span style="font-weight:bold">in</span> x.connections:
        res.append(x)
        x = x.connections[<span style="color:#00f">&#39;E&#39;</span>]
        fix_east(res[-<span style="color:#00f">1</span>], x)
    res.append(x)
    <span style="color:#000080;font-weight:bold">return</span> res

<span style="color:#000080;font-weight:bold">def</span> assemble_tiles(tiles):
    x = [ <span style="color:#080;font-style:italic"># get upper left tile to start from</span>
        tile <span style="color:#000080;font-weight:bold">for</span> tile <span style="font-weight:bold">in</span> tiles 
        <span style="color:#000080;font-weight:bold">if</span> set(tile.connections.keys()) == {<span style="color:#00f">&#39;E&#39;</span>,<span style="color:#00f">&#39;S&#39;</span>} 
    ][<span style="color:#00f">0</span>]

    res = []
    row = tile_row(x)
    <span style="color:#000080;font-weight:bold">while</span> <span style="color:#00f">&#39;S&#39;</span> <span style="font-weight:bold">in</span> row[<span style="color:#00f">0</span>].connections:
        res.append(row)
        x = row[<span style="color:#00f">0</span>].connections[<span style="color:#00f">&#39;S&#39;</span>]
        fix_south(row[<span style="color:#00f">0</span>], x)
        row = tile_row(x)
    res.append(row)
    <span style="color:#000080;font-weight:bold">return</span> res

assembly = assemble_tiles(tiles)
</code></pre></div><p>Once you have assembled all the tiles, you might be able to scan for monsters directly in them, but for me, it was easier to build the image. That, at least, was easy to do:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000080;font-weight:bold">def</span> remove_borders(tiles):
    <span style="color:#000080;font-weight:bold">for</span> tile <span style="font-weight:bold">in</span> tiles:
        tile.pixels = [ row[<span style="color:#00f">1</span>:-<span style="color:#00f">1</span>] <span style="color:#000080;font-weight:bold">for</span> row <span style="font-weight:bold">in</span> tile.pixels[<span style="color:#00f">1</span>:-<span style="color:#00f">1</span>] ]

remove_borders(tiles)

<span style="color:#000080;font-weight:bold">def</span> insert_tile(img, tile, x, y):
    k = len(tile.pixels)
    <span style="color:#000080;font-weight:bold">for</span> i <span style="font-weight:bold">in</span> range(k):
        <span style="color:#000080;font-weight:bold">for</span> j <span style="font-weight:bold">in</span> range(k):
            img[k*x+i][k*y+j] = tile.pixels[i][j]

<span style="color:#000080;font-weight:bold">def</span> build_img(assembly):
    n, m, k = len(assembly), len(assembly[<span style="color:#00f">0</span>]), len(assembly[<span style="color:#00f">0</span>][<span style="color:#00f">0</span>].pixels)
    img = [ [<span style="color:#00f">&#39; &#39;</span>] * (m*k) <span style="color:#000080;font-weight:bold">for</span> _ <span style="font-weight:bold">in</span> range(n*k) ]
    <span style="color:#000080;font-weight:bold">for</span> x <span style="font-weight:bold">in</span> range(n):
        <span style="color:#000080;font-weight:bold">for</span> y <span style="font-weight:bold">in</span> range(m):
            insert_tile(img, assembly[x][y], x, y)
    <span style="color:#000080;font-weight:bold">return</span> img
</code></pre></div><p>To find the monsters, I use a sliding window approach. I don’t think that there are overlapping monsters—and the description didn’t tell us what to do if that happened—so I didn’t worry about it.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">MONSTER = \
<span style="color:#00f">&#34;&#34;&#34;                  # 
</span><span style="color:#00f">#    ##    ##    ###
</span><span style="color:#00f"> #  #  #  #  #  #   &#34;&#34;&#34;</span>.split(<span style="color:#00f">&#39;</span><span style="color:#00f">\n</span><span style="color:#00f">&#39;</span>)
MONSTER_OFFSETS = [
    (i,j) <span style="color:#000080;font-weight:bold">for</span> i <span style="font-weight:bold">in</span> range(len(MONSTER))
          <span style="color:#000080;font-weight:bold">for</span> j <span style="font-weight:bold">in</span> range(len(MONSTER[<span style="color:#00f">0</span>]))
          <span style="color:#000080;font-weight:bold">if</span> MONSTER[i][j] == <span style="color:#00f">&#39;#&#39;</span>
]

<span style="color:#000080;font-weight:bold">def</span> detect_monster(img, x, y):
    <span style="color:#000080;font-weight:bold">return</span> all(
        img[x + i][y + j] == <span style="color:#00f">&#39;#&#39;</span>
        <span style="color:#000080;font-weight:bold">for</span> i,j <span style="font-weight:bold">in</span> MONSTER_OFFSETS
    )
<span style="color:#000080;font-weight:bold">def</span> draw_monster(img, x, y):
    <span style="color:#000080;font-weight:bold">for</span> i,j <span style="font-weight:bold">in</span> MONSTER_OFFSETS:
        img[x + i][y + j] = <span style="color:#00f">&#39;O&#39;</span>

<span style="color:#000080;font-weight:bold">def</span> scan_for_monsters(img):
    found = False
    n, m = len(img), len(img[<span style="color:#00f">0</span>])
    nn, mm = len(MONSTER), len(MONSTER[<span style="color:#00f">0</span>])
    <span style="color:#000080;font-weight:bold">for</span> x <span style="font-weight:bold">in</span> range(n - nn):
        <span style="color:#000080;font-weight:bold">for</span> y <span style="font-weight:bold">in</span> range(m - mm):
            <span style="color:#000080;font-weight:bold">if</span> detect_monster(img, x, y):
                found = True
                draw_monster(img, x, y)
    <span style="color:#000080;font-weight:bold">return</span> found
</code></pre></div><p>There might not be any monsters in the first image, but then we can try to rotate and flip. For my input, I found the monsters after rotating, so I didn’t implement flipping an image.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#080;font-style:italic"># Try rotations until we find something or have rotated all the way</span>
img = build_img(assembly)

<span style="color:#000080;font-weight:bold">def</span> rotate_img(img):
    <span style="color:#000080;font-weight:bold">return</span> [ *map(list, zip(*img[::-<span style="color:#00f">1</span>])) ]

<span style="color:#000080;font-weight:bold">def</span> print_img(img):
    <span style="color:#000080;font-weight:bold">print</span>(<span style="color:#00f">&#39;</span><span style="color:#00f">\n</span><span style="color:#00f">&#39;</span>.join( <span style="color:#00f">&#39;&#39;</span>.join(row) <span style="color:#000080;font-weight:bold">for</span> row <span style="font-weight:bold">in</span> img ))

<span style="color:#000080;font-weight:bold">for</span> _ <span style="font-weight:bold">in</span> range(<span style="color:#00f">4</span>):
    <span style="color:#000080;font-weight:bold">if</span> scan_for_monsters(img):
        <span style="color:#000080;font-weight:bold">break</span>
    img = rotate_img(img)

<span style="color:#080;font-style:italic"># It was enough with rotations for me, but potentially</span>
<span style="color:#080;font-style:italic"># you would need flips as well...</span>
<span style="color:#000080;font-weight:bold">print</span>(f<span style="color:#00f">&#34;Puzzle #2: {sum(row.count(&#39;#&#39;) for row in img)}&#34;</span>)
</code></pre></div><p>I admit that I didn’t have that much fun with this puzzle. It was mostly grunt work and not clever ideas. I know, I know, most programming <em>is</em> grunt work, but when I do that, I get paid to do it. When I program for fun, I want to have fun.</p>
<p>I still think I would have had more fun with it if I had known that it would take this long to solve, and I had set aside the necessary time, but I was rushing to finish, and that makes it stressful, and I mess up much more than I usually do (which is plenty, I might add).</p>
<p>I had thought about sneaking up to the computer during the holiday to solve the puzzles, but if they take more than an hour from now on, then I have to leave them for after New Year. I fully plan to get through, but I don’t want to hide in the office over the holiday. And I know very well, that once I start on a problem, I cannot put it down again until it is done. Even if it took all of Christmas Day, I would be working. That won’t do. So I have to make up my mind soon on whether I should finish this year, or leave the last few puzzles for January.</p>
<h2 id="day-21--allergen-assessment">Day 21 — Allergen Assessment</h2>
<p><a href="https://adventofcode.com/2020/day/21">Day 21</a>  looked very scary to me at first. The way it is framed smells awfully much like we would have to implement a graph pairing algorithm, and I was sure I would be in for another long session of grunt work. Thankfully, it was a lot easier than I feared. With this day, we are back to about an hour, hour and a half, for solving both puzzles.</p>
<p>When I read the description, I was thinking bipartite graph, pairing or flow, or something like that, so I wrote up some code for handling that. Ingredients know which allergens they might contain, and allergens know which ingredients they might be in, and because Puzzle #1 wants us to check the recipes in the input, I made a class for that as well. I was <em>so</em> prepared for something hard.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">f = open(<span style="color:#00f">&#39;/Users/mailund/Projects/adventofcode/2020/21/input.txt&#39;</span>)

<span style="color:#000080;font-weight:bold">class</span> IngredientsList(object):
    <span style="color:#000080;font-weight:bold">def</span> __init__(self, foods, allergens):
        self.foods = foods
        self.allergens = allergens

<span style="color:#000080;font-weight:bold">class</span> Food(object):
    <span style="color:#000080;font-weight:bold">def</span> __init__(self, name):
        self.name = name
        self.may_contain = set()

    <span style="color:#000080;font-weight:bold">def</span> add_allergens(self, allergens):
        self.may_contain.update(allergens)

<span style="color:#000080;font-weight:bold">class</span> Allergen(object):
    <span style="color:#000080;font-weight:bold">def</span> __init__(self, name):
        self.name = name
        self.might_be_in = None
    <span style="color:#000080;font-weight:bold">def</span> add_foods(self, foods):
        <span style="color:#000080;font-weight:bold">if</span> self.might_be_in <span style="font-weight:bold">is</span> None:
            self.might_be_in = set(foods)
        <span style="color:#000080;font-weight:bold">else</span>:
            self.might_be_in &amp;= set(foods)
        
<span style="color:#000080;font-weight:bold">class</span> Graph(object):
    <span style="color:#000080;font-weight:bold">def</span> __init__(self):
        self.foods = {}
        self.allergens = {}
    <span style="color:#000080;font-weight:bold">def</span> food(self, name):
        <span style="color:#000080;font-weight:bold">if</span> name <span style="font-weight:bold">not</span> <span style="font-weight:bold">in</span> self.foods:
            self.foods[name] = Food(name)
        <span style="color:#000080;font-weight:bold">return</span> self.foods[name]
    <span style="color:#000080;font-weight:bold">def</span> allergen(self, name):
        <span style="color:#000080;font-weight:bold">if</span> name <span style="font-weight:bold">not</span> <span style="font-weight:bold">in</span> self.allergens:
            self.allergens[name] = Allergen(name)
        <span style="color:#000080;font-weight:bold">return</span> self.allergens[name]

GRAPH = Graph()
LIST = []

<span style="color:#000080;font-weight:bold">import</span> re
<span style="color:#000080;font-weight:bold">for</span> line <span style="font-weight:bold">in</span> f:
    foods, allergens = \
	    re.match(<span style="color:#00f">r</span><span style="color:#00f">&#34;([^\(]+) \(contains (.*)\)&#34;</span>, line).groups()
    foods = foods.split()
    allergens = [a.strip() <span style="color:#000080;font-weight:bold">for</span> a <span style="font-weight:bold">in</span> allergens.strip().split(<span style="color:#00f">&#39;,&#39;</span>)]

    <span style="color:#000080;font-weight:bold">for</span> food <span style="font-weight:bold">in</span> foods:
        GRAPH.food(food).add_allergens(
	        GRAPH.allergen(a) <span style="color:#000080;font-weight:bold">for</span> a <span style="font-weight:bold">in</span> allergens
	      )
    <span style="color:#000080;font-weight:bold">for</span> allergen <span style="font-weight:bold">in</span> allergens:
        GRAPH.allergen(allergen).add_foods(
	        GRAPH.food(f) <span style="color:#000080;font-weight:bold">for</span> f <span style="font-weight:bold">in</span> foods
	      )

    LIST.append(IngredientsList(
      [GRAPH.food(food) <span style="color:#000080;font-weight:bold">for</span> food <span style="font-weight:bold">in</span> foods],
      [GRAPH.allergen(a) <span style="color:#000080;font-weight:bold">for</span> a <span style="font-weight:bold">in</span> allergens]
    ))
</code></pre></div><p>However, Puzzle #1 is much like some of the earlier puzzles, where we can work out the answer with set operations. For each allergen, the input lines tell us a set of ingredients they might be in, and if we compute the intersections of those lists, we can eliminate ingredients they might be in. The description threw me a little when it said that there might be allergens left out, which throws the whole declaration up in the air, but when we know that at most one food item can have an allergen, it falls back into place.</p>
<p>So, I simply compute the intersection of food items for all the allergens over all the input lists. That is why I use the <code>&amp;=</code> to update allergens’ relations to food items, while I do not do the same for the other direction. If I had know about Puzzle #2 before I wrote this code, I wouldn’t hade made the graph, and food ingredients would just be their names, so the code is completely over-engineered. After solving Day 20, however, I don’t have the strength to reimplement this one as well.</p>
<p>Anyway, if we have computed the intersections of the sets for all the allergens, the safe ingredients are those that are not in any of those sets. So, we can compute the union of the allergens’ sets, make a set of all the food items, and the set-difference gives us the safe food. After that, it is just counting.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#080;font-style:italic">## PUZZLE #1 ---------------------------------------------</span>
contains_allergens = set.union( 
	*(a.might_be_in <span style="color:#000080;font-weight:bold">for</span> a <span style="font-weight:bold">in</span> GRAPH.allergens.values())
)
foods = set(GRAPH.foods.values())
no_allergens = foods - contains_allergens
count = sum((food <span style="font-weight:bold">in</span> lst.foods) 
            <span style="color:#000080;font-weight:bold">for</span> food <span style="font-weight:bold">in</span> no_allergens <span style="color:#000080;font-weight:bold">for</span> lst <span style="font-weight:bold">in</span> LIST)
<span style="color:#000080;font-weight:bold">print</span>(f<span style="color:#00f">&#34;Puzzle #1: {count}&#34;</span> )
</code></pre></div><p>I open Puzzle #2 with trembling hands, but ended up pleasantly surprised. We need to pair allergens with ingredients, and that is potentially a pairing algorithm. However, we are once again in the situation where we have some singletons to start from, and whenever we have a singleton to an allergen, we can make a pairing and remove the corresponding ingredient from the other sets. If we do this until there are only singletons left, we are done.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#080;font-style:italic">## PUZZLE #2 ---------------------------------------------</span>
<span style="color:#000080;font-weight:bold">def</span> elimination(allergens):
    pairings = []
    <span style="color:#000080;font-weight:bold">while</span> True:
        singletons = [
            a <span style="color:#000080;font-weight:bold">for</span> a <span style="font-weight:bold">in</span> allergens <span style="color:#000080;font-weight:bold">if</span> len(a.might_be_in) == <span style="color:#00f">1</span>
        ]
        allergens = [
            a <span style="color:#000080;font-weight:bold">for</span> a <span style="font-weight:bold">in</span> allergens <span style="color:#000080;font-weight:bold">if</span> len(a.might_be_in) &gt; <span style="color:#00f">1</span>
        ]
        pairings.extend(singletons)

        <span style="color:#000080;font-weight:bold">if</span> len(allergens) == <span style="color:#00f">0</span>:
            <span style="color:#000080;font-weight:bold">return</span> pairings
        
        <span style="color:#000080;font-weight:bold">for</span> s <span style="font-weight:bold">in</span> singletons:
            food, = s.might_be_in
            <span style="color:#000080;font-weight:bold">for</span> r <span style="font-weight:bold">in</span> allergens:
                <span style="color:#000080;font-weight:bold">if</span> food <span style="font-weight:bold">in</span> r.might_be_in:
                    r.might_be_in.remove(food)

<span style="color:#000080;font-weight:bold">def</span> danger_list(pairings):
    lst = sorted([
        (a.name,list(a.might_be_in)[<span style="color:#00f">0</span>].name)
        <span style="color:#000080;font-weight:bold">for</span> a  <span style="font-weight:bold">in</span> pairings
    ])
    <span style="color:#000080;font-weight:bold">return</span> <span style="color:#00f">&#39;,&#39;</span>.join(f <span style="color:#000080;font-weight:bold">for</span> a,f <span style="font-weight:bold">in</span> lst)

pairings = elimination(GRAPH.allergens.values())
cannonical_list = danger_list(pairings)
<span style="color:#000080;font-weight:bold">print</span>(f<span style="color:#00f">&#34;Puzzle #2: {cannonical_list}&#34;</span>)
</code></pre></div><p>You cannot always do this, of course, and quite often it becomes an optimisation problem, and I was not in the mood for that, so I am very happy that this worked.</p>
<p>Day 21 was fun, so I will have a look at the puzzles tomorrow as well. The day after, my holiday begins, so I will leave the last three days’ puzzles to January, where I am home alone anyway. They will make a nice distraction between the Zoom-exams.</p>
<p>By January, I will also have time to fix up code before I post it—and it needs that if the two days in this post are indicators of what is to come.</p>


</article>


<section class="post-nav">
    <ul>
        
        <li>
            <a href="https://mailund.dk/posts/aoc-2020-7/"><i class="fa fa-chevron-circle-left"></i> Advent of Code 2020 — day 19</a>
        </li>
        
        
    </ul>
</section>
    
        <section class="comments-block">
      <button id="show-comments" style="display: none;"><i class="fa fa-comments-o"></i> Add/View Comments</button>
</section>

<section id="disqus_thread"></section>

<script>
      (function () {
            
            
            if (window.location.hostname == "localhost")
                  return;

            var disqus_loaded = false;
            var disqus_shortname = 'mailund-dk';
            var disqus_button = document.getElementById("show-comments");

            disqus_button.style.display = "";
            disqus_button.addEventListener("click", disqus, false);

            function disqus() {

                  if (!disqus_loaded) {
                        disqus_loaded = true;

                        var e = document.createElement("script");
                        e.type = "text/javascript";
                        e.async = true;
                        e.src = "//" + disqus_shortname + ".disqus.com/embed.js";
                        (document.getElementsByTagName("head")[0] ||
                              document.getElementsByTagName("body")[0])
                        .appendChild(e);

                        
                        document.getElementById("show-comments").style.display = "none";
                  }
            }

            
            var hash = window.location.hash.substr(1);
            if (hash.length > 8) {
                  if (hash.substring(0, 8) == "comment-") {
                        disqus();
                  }
            }

            
            if (/bot|google|baidu|bing|msn|duckduckgo|slurp|yandex/i.test(navigator.userAgent)) {
                  disqus();
            }
      })();
</script>
    





</main>
    <footer>
        <h6>Copyright © 2020 - Thomas Mailund |
            Rendered by <a href="https://gohugo.io" title="Hugo">Hugo</a> |
            <a href="https://mailund.dk/index.xml">Subscribe</a></h6>
    </footer>
</div>
<script src="https://mailund.dk/js/scripts.js"></script>
</body>
<div id="amzn-assoc-ad-04956520-8388-43ab-9b6e-fbe758d208f8"></div>
<script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=04956520-8388-43ab-9b6e-fbe758d208f8"></script>

<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

</html>
