<!doctype html>

<html lang="en">

<head>
  <title>Mailund on the Internet</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="The HTML5 Herald" />
  <meta name="author" content="" />
  

  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/7.0.0/normalize.min.css" />

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />

<link rel="stylesheet" type="text/css" href="https://mailund.dk/css/styles.css" />
<link rel="stylesheet" href="https://cdn.rawgit.com/tonsky/FiraCode/1.205/distr/fira_code.css">

 
       <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Droid Sans" type="text/css" media="all" />
     
       <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Fira Mono" type="text/css" media="all" />
     

 <style>
 body {
     font-family: 'Droid Sans';
 }
 code {
    font-family: 'Fira Code';
 }
 </style>

 <script type="text/javascript" async
   src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
   MathJax.Hub.Queue(function() {
     
     
     
     var all = MathJax.Hub.getAllJax(), i;
     for(i = 0; i < all.length; i += 1) {
         all[i].SourceElement().parentNode.className += ' has-jax';
     }
   });

   MathJax.Hub.Config({
   
   TeX: { equationNumbers: { autoNumber: "AMS" } }
   });
   MathJax.Hub.Config({
   tex2jax: {
     inlineMath: [['$$','$$'], ['\\(','\\)']],
     displayMath: [['$$$','$$$']],
     processEscapes: true,
     processEnvironments: true,
     skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
     TeX: { equationNumbers: { autoNumber: "AMS" },
          extensions: ["AMSmath.js", "AMSsymbols.js"] }
   }
   });
 </script>

      <script async src="https://www.googletagmanager.com/gtag/js?id=386493837"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', '386493837');
        }
      </script>
</head>

<body>
  <div id="container">
    <header>
      <h1>
                <a href="https://mailund.dk/">Mailund on the Internet</a>
            </h1>

      <ul id="social-media">
                
      </ul>
      
      <p><em>On Writing, Science, Programming and more</em></p>
      

    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="" href="https://mailund.dk/about/">
                <i class="fa-li fa  fa-lg"></i><span>About</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://mailund.dk/posts">
                <i class="fa-li fa  fa-lg"></i><span>Posts</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://mailund.dk/books/">
                <i class="fa-li fa  fa-lg"></i><span>Books</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://mailund.dk/fiction/">
                <i class="fa-li fa  fa-lg"></i><span>Fiction</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://mailund.dk/publications/">
                <i class="fa-li fa  fa-lg"></i><span>Publications</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://mailund.dk/software/">
                <i class="fa-li fa  fa-lg"></i><span>Software</span>
            </a>
        </li>
        
    </ul>
</nav>

    <main>




<article>

    <h1>Overscoping and eval</h1>

    
        <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2018-09-22T12:23:09&#43;02:00">Sep 22, 2018</time>
        </li>
        
        

        
        <li>
            <em>
                
                    
                    <a href="https://mailund.dk/tags/programming/">#programming</a>
                
                    , 
                    <a href="https://mailund.dk/tags/rstats/">#rstats</a>
                
            </em>
        </li>
        

        <li>16 min read</li>
    </ul>
</aside>
    

    <p>In my <a href="https://mailund.github.io/r-programmer-blog/2018/09/20/scoping-rules-and-nse/">previous post</a> I used the <code>lm</code> function for an example of scope rules, but I left a few details out. I didn&rsquo;t want to muddy the example with too many details, so I chose to lie a little.</p>
<p>The drawing I used to explain the example was this:</p>
<figure><img src="https://mailund.dk/posts/eval-and-overscoping/lm2%20details%20ok.png">
</figure>

<p>I explained how the scope is implemented using environments that are chained through parent pointers, and how a function has an environment associated with it. This environment is the environment where you define the function.</p>
<p>When you call a function, it gets its own instance environment (for historical reasons more than anything else we call this the call frame, but it is really just a new environment). The parent of that frame is the environment associated with the function.</p>
<p>So, we have two environments in play here, the environment of the instance and the environment where the function was defined. The parent of the former is the latter.</p>
<p>If you define a function nested inside another, then the environment associated with the nested function is the environment of the function <em>call</em> of the outer function. So, if you call the inner function, we have three environments in place: the one where the outer function was defined, the environment created when the outer function was called, and the environment of the inner function call.</p>
<p>Consider this:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>f &lt;- <span style="color:#000080;font-weight:bold">function</span>(x) <span style="color:#000080;font-weight:bold">function</span>(y) x + y
</span></span><span style="display:flex;"><span>g &lt;- f(<span style="color:#00f">2</span>)
</span></span><span style="display:flex;"><span>g(<span style="color:#00f">3</span>)
</span></span></code></pre></div><pre tabindex="0"><code>## [1] 5
</code></pre><p>The global environment will contain <code>f</code> and <code>g</code>. They are both variables in the global scope, and they are both functions, but the environment associated with them are different. Because <code>f</code> was defined in the global scope, that is the environment associated with. On the other hand, <code>g</code> was defined inside a call to <code>f</code>. We didn&rsquo;t name it there, but what we name functions has nothing to do with where they are defined. The <code>g</code> function was defined inside the call to <code>f</code>.</p>
<p>In the call to <code>f</code>, we created an environment for the call, and we put the parameter <code>x</code> into this. The parent of this environment is the one associated with <code>f</code>, which is the global environment.</p>
<p>The environment associated with <code>g</code> is the one we created with the call to <code>f</code>, where we created the inner function. So, when we call <code>g</code>, we create an environment for the call, we set its parent to the one associated with <code>g</code>â€”the one we created when we called <code>g</code>. We put the parameter <code>y</code> into this environment, and it is in this environment we evaluate the body of <code>g</code>: <code>x + y</code>.</p>
<p>The setup is this, where I have illustrated where the <code>g</code> body finds variables <code>x</code> and <code>y</code> by searching through the environment chain, the <code>y</code> variable in the immediate environment and the <code>x</code> variable in its parent.</p>
<figure><img src="https://mailund.dk/posts/eval-and-overscoping/nested%20calls.png">
</figure>

<p>This is how lexical scope works.</p>
<p>Now, consider instead this code:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>f &lt;- <span style="color:#000080;font-weight:bold">function</span>(x) x + y + z
</span></span><span style="display:flex;"><span>g &lt;- <span style="color:#000080;font-weight:bold">function</span>(y) f(x)
</span></span><span style="display:flex;"><span>h &lt;- <span style="color:#000080;font-weight:bold">function</span>(z) g(y)
</span></span><span style="display:flex;"><span>x &lt;- y &lt;- z &lt;- <span style="color:#00f">1</span>
</span></span></code></pre></div><p>What would happen if we called <code>h(5)</code> here?</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>h(<span style="color:#00f">5</span>)
</span></span></code></pre></div><pre tabindex="0"><code>## [1] 3
</code></pre><p>The rules are the same as before, and the environments and how they are chained is this:</p>
<figure><img src="https://mailund.dk/posts/eval-and-overscoping/not%20nested.png">
</figure>

<p>All three functions are associated with the global environment, so when we call them, that will be the parent of their call environments. This means that when we call <code>h(5)</code> we get an environment that maps <code>z</code> to 5, but we find the <code>y</code> we use in the call to <code>g</code> from the global environment, where it is 1. The call environment for <code>g(y = 1)</code> contains the mapping for <code>y</code>, but we find the <code>x</code> for the call <code>f(x)</code> in the global environment, so we call <code>f(x = 1)</code>. That creates yet another call environment where we map <code>x</code> to one. When we evaluate <code>x + y + z</code> we find <code>x</code> in the call-environment, and we find <code>y</code> and <code>z</code> in its parent-environmentâ€”the global environment. That is why <code>x + y + z</code> evaluates to three.</p>
<p>I have shown the caller environments in blue-ish. For each function, it shows the environment where the function was called from. If R had so-called dynamic scope, the chain of blue environments is where it would look for the variables. But R implements lexical scope, so it follows the brown chains instead.</p>
<h2 id="non-standard-evaluation">Non-standard evaluation</h2>
<p>Now, we can explicitly tell R to use a different environment in which to evaluate an expression. We need to do two things: we have to replace expressions with quoted expressions and then evaluate them using the <code>eval</code> function with the alternative environment.</p>
<p>We have to use quoted expressions because otherwise, we will evaluate the expressions where we call <code>eval</code> and not inside it, in the environment we tell <code>eval</code> to do the evaluation.^[How arguments are actually evaluated is more complicated than this; notice that I wrote that &ldquo;we will evaluate the expressions where we call <code>eval</code>&rdquo;. I didn&rsquo;t say we would evaluate them <em>before</em> we call <code>eval</code>. We still evaluate the argument after we call <code>eval</code>, we just won&rsquo;t use the alternative environment. I have explained how lazy evaluation works in <a href="https://mailund.dk/books/">a couple of books</a> and even how you can exploit it to implement lazy data structures in <a href="https://amzn.to/2znwsW8"><em>Functional Data-Structures in R</em></a>. I won&rsquo;t repeat it here, but might in a later post. There is enough to cover in this post as it is.]</p>
<p>We can do something like this:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>f &lt;- <span style="color:#000080;font-weight:bold">function</span>(x)
</span></span><span style="display:flex;"><span>    eval(quote(x + y + z), rlang::caller_env())
</span></span><span style="display:flex;"><span>g &lt;- <span style="color:#000080;font-weight:bold">function</span>(y)
</span></span><span style="display:flex;"><span>    eval(quote(f(x)), rlang::caller_env())
</span></span><span style="display:flex;"><span>h &lt;- <span style="color:#000080;font-weight:bold">function</span>(z) g(y)
</span></span><span style="display:flex;"><span>h(<span style="color:#00f">5</span>)
</span></span></code></pre></div><pre tabindex="0"><code>## [1] 7
</code></pre><p>This tells <code>f</code> to evaluate the expression <code>x + y + z</code> in the caller&rsquo;s environment instead of its own. It tells <code>g</code> to evaluate the expression <code>f(x)</code> in <em>its</em> caller&rsquo;s environment. Finally, we tell <code>h</code> just to evaluate <code>g(y)</code>.</p>
<p>The chains of parents in this new setup is the same. Those are fixed once we have defined the functions.</p>
<p>You might also expect that the chains of caller-environments are the same, but that is not really true. The <code>h</code> function is still called from the global environment, and the  <code>g</code> function is still called from <code>h</code>, so this doesn&rsquo;t change. But inside the <code>g</code> call, we ask <code>eval</code> to pretend it is in the caller&rsquo;s frame when it evaluates <code>f(x)</code>, so the caller to <code>f</code> is <code>h(5)</code>&rsquo;s environment.</p>
<p>To explicitly see the environments in place, we can out some output to the functions:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>f &lt;- <span style="color:#000080;font-weight:bold">function</span>(x) {
</span></span><span style="display:flex;"><span>    print(<span style="color:#00f">&#34;f&#39;s caller env:&#34;</span>)
</span></span><span style="display:flex;"><span>    print(rlang::caller_env())
</span></span><span style="display:flex;"><span>    print(<span style="color:#00f">&#34;f&#39;s environment:&#34;</span>)
</span></span><span style="display:flex;"><span>    print(environment())
</span></span><span style="display:flex;"><span>    eval(quote(x + y + z), rlang::caller_env())
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>g &lt;- <span style="color:#000080;font-weight:bold">function</span>(y) {
</span></span><span style="display:flex;"><span>    print(<span style="color:#00f">&#34;g&#39;s caller env:&#34;</span>)
</span></span><span style="display:flex;"><span>    print(rlang::caller_env())
</span></span><span style="display:flex;"><span>    print(<span style="color:#00f">&#34;g&#39;s environment:&#34;</span>)
</span></span><span style="display:flex;"><span>    print(environment())
</span></span><span style="display:flex;"><span>    eval(quote(f(x)), rlang::caller_env())
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>h &lt;- <span style="color:#000080;font-weight:bold">function</span>(z) {
</span></span><span style="display:flex;"><span>    print(<span style="color:#00f">&#34;h&#39;s caller env:&#34;</span>)
</span></span><span style="display:flex;"><span>    print(rlang::caller_env())
</span></span><span style="display:flex;"><span>    print(<span style="color:#00f">&#34;h&#39;s environment:&#34;</span>)
</span></span><span style="display:flex;"><span>    print(environment())
</span></span><span style="display:flex;"><span>    g(y)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>When we call <code>f</code> from the global environment it has its own evaluation environment and the global environment as its caller&rsquo;s environment:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>f(x)
</span></span></code></pre></div><pre tabindex="0"><code>## [1] &#34;f&#39;s caller env:&#34;
## &lt;environment: R_GlobalEnv&gt;
## [1] &#34;f&#39;s environment:&#34;
## &lt;environment: 0x7fde174dea78&gt;
</code></pre><pre tabindex="0"><code>## [1] 3
</code></pre><p>The same when we call <code>g</code>, but when we ask <code>eval</code> to evaluate <code>f(x)</code> in <code>g(y)</code>&rsquo;s caller environment we are asking it to evaluate <code>f(x)</code> in the global environment:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>g(y)
</span></span></code></pre></div><pre tabindex="0"><code>## [1] &#34;g&#39;s caller env:&#34;
## &lt;environment: R_GlobalEnv&gt;
## [1] &#34;g&#39;s environment:&#34;
## &lt;environment: 0x7fde161f4738&gt;
## [1] &#34;f&#39;s caller env:&#34;
## &lt;environment: R_GlobalEnv&gt;
## [1] &#34;f&#39;s environment:&#34;
## &lt;environment: 0x7fde165f8b60&gt;
</code></pre><pre tabindex="0"><code>## [1] 3
</code></pre><p>When we call <code>h(5)</code> we call it from the global environment, but we evaluate the <code>g(y)</code> call in <code>h(5)</code>&rsquo;s evaluation environment:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>h(<span style="color:#00f">5</span>)
</span></span></code></pre></div><pre tabindex="0"><code>## [1] &#34;h&#39;s caller env:&#34;
## &lt;environment: R_GlobalEnv&gt;
## [1] &#34;h&#39;s environment:&#34;
## &lt;environment: 0x7fde17a13078&gt;
## [1] &#34;g&#39;s caller env:&#34;
## &lt;environment: 0x7fde17a13078&gt;
## [1] &#34;g&#39;s environment:&#34;
## &lt;environment: 0x7fde17a17040&gt;
## [1] &#34;f&#39;s caller env:&#34;
## &lt;environment: 0x7fde17a13078&gt;
## [1] &#34;f&#39;s environment:&#34;
## &lt;environment: 0x7fde1838c768&gt;
</code></pre><pre tabindex="0"><code>## [1] 7
</code></pre><p>So in this version, <code>g</code> will evaluate <code>f(x)</code> in <code>h(5)</code>&rsquo;s environment and <code>f</code> will evaluate <code>x + y + z</code> in the same environment. When <code>g</code> evaluates <code>x + y + z</code> it finds <code>z</code> in the call-environment of <code>h(5)</code>, and it finds <code>x</code> and <code>y</code> in the global environment (because this is the parent of <code>h(5)</code>&rsquo;s environment). The environments of <code>g(y)</code> and <code>f(x)</code> are never in play here; we skip them entirely.</p>
<figure><img src="https://mailund.dk/posts/eval-and-overscoping/dyn%20scope%201.png">
</figure>

<p>With me so far?</p>
<p>There is more to it than this. When <code>g</code> asks <code>eval</code> to evaluate <code>quote(f(x))</code> in its caller&rsquo;s environment, <code>eval</code> will also look for <code>f</code> there. Inside the scope of <code>g(y)</code>, there is an <code>f</code>, and you can find it by going through its parent to the global environment. But that is not where <code>eval</code> looks for <code>f</code>. It looks for <code>f</code> starting in <code>h(5)</code>&rsquo;s environment. It still finds <code>f</code> in the global environment, but if <code>h</code> had an inner function named <code>f</code>, that is where it would find it.</p>
<p>We haven&rsquo;t implemented dynamic scope exactly here. We skip some local environments, but that is not what dynamic scope does. It looks through the chain of function calls to find its variables. We just skip some environments and avoid the local ones completely.</p>
<p>If you want dynamic scope you can set the parent of the local environments to the caller environment like this:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>f &lt;- <span style="color:#000080;font-weight:bold">function</span>(x) {
</span></span><span style="display:flex;"><span>    e &lt;- environment() <span style="color:#080;font-style:italic"># the instance env.</span>
</span></span><span style="display:flex;"><span>    parent.env(e) &lt;- rlang::caller_env()
</span></span><span style="display:flex;"><span>    x + y + z
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>g &lt;- <span style="color:#000080;font-weight:bold">function</span>(y) {
</span></span><span style="display:flex;"><span>    e &lt;- environment() <span style="color:#080;font-style:italic"># the instance env.</span>
</span></span><span style="display:flex;"><span>    parent.env(e) &lt;- rlang::caller_env()
</span></span><span style="display:flex;"><span>    f(x)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>k &lt;- <span style="color:#000080;font-weight:bold">function</span>(x, y, z) g(y)
</span></span><span style="display:flex;"><span>k(<span style="color:#00f">1</span>, <span style="color:#00f">2</span>, <span style="color:#00f">3</span>)
</span></span></code></pre></div><pre tabindex="0"><code>## [1] 6
</code></pre><p>When we call <code>k(1, 2, 3)</code> we define values for <code>x</code>, <code>y</code>, and <code>z</code>. We then call <code>g(y)</code>, so we pass along the value of the local <code>y</code>. That value is stored in the variable <code>y</code> in the local environment of that call; it doesn&rsquo;t matter here because both <code>y</code> variables refer to the same value, but we could change it in <code>g</code>, and the new value would be the one we see.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>g &lt;- <span style="color:#000080;font-weight:bold">function</span>(y) {
</span></span><span style="display:flex;"><span>    y &lt;- <span style="color:#00f">-3</span> <span style="color:#080;font-style:italic"># change the binding of `y`</span>
</span></span><span style="display:flex;"><span>    e &lt;- environment() <span style="color:#080;font-style:italic"># the instance env.</span>
</span></span><span style="display:flex;"><span>    parent.env(e) &lt;- rlang::caller_env()
</span></span><span style="display:flex;"><span>    f(x)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>k(<span style="color:#00f">1</span>, <span style="color:#00f">2</span>, <span style="color:#00f">3</span>)
</span></span></code></pre></div><pre tabindex="0"><code>## [1] 1
</code></pre><p>When we evaluate <code>f(x)</code> we have also changed the parent environment, so while we can find <code>x</code> in the local environment we search for <code>y</code> and <code>z</code> in the caller&rsquo;s environment instead of our original parent&rsquo;s.</p>
<p>Notice here that we no longer need to use <code>eval</code> for non-standard evaluation. When we change the parent of our environment, we can just evaluate expressions in the usual way.</p>
<p>If you want to combine lexical and dynamic scope, you are in a bit of trouble. Your environments only have one parent, so you have to either use the caller&rsquo;s environment or the function&rsquo;s environment.</p>
<p>You can mix the two by explicitly searching for variables in different environments, you can use the <code>get</code> function for this:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>f &lt;- <span style="color:#000080;font-weight:bold">function</span>(x) {
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">function</span>(y) {
</span></span><span style="display:flex;"><span>        z &lt;- get(<span style="color:#00f">&#34;z&#34;</span>, rlang::caller_env())
</span></span><span style="display:flex;"><span>        x + y + z
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>g &lt;- f(<span style="color:#00f">1</span>)
</span></span><span style="display:flex;"><span>h &lt;- f(<span style="color:#00f">2</span>)
</span></span><span style="display:flex;"><span>z &lt;- <span style="color:#00f">1</span>
</span></span><span style="display:flex;"><span>g(<span style="color:#00f">2</span>) <span style="color:#080;font-style:italic"># 1(x) + 2(y) + 1(z)</span>
</span></span></code></pre></div><pre tabindex="0"><code>## [1] 4
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>h(<span style="color:#00f">3</span>) <span style="color:#080;font-style:italic"># 2(x) + 3(y) + 1(z)</span>
</span></span></code></pre></div><pre tabindex="0"><code>## [1] 6
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>k &lt;- <span style="color:#000080;font-weight:bold">function</span>(z) g(<span style="color:#00f">2</span>)
</span></span><span style="display:flex;"><span>k(<span style="color:#00f">3</span>) <span style="color:#080;font-style:italic"># 1(x) + 2(y) + 3(z)</span>
</span></span></code></pre></div><pre tabindex="0"><code>## [1] 6
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>k(<span style="color:#00f">4</span>) <span style="color:#080;font-style:italic"># 1(x) + 2(y) + 4(z)</span>
</span></span></code></pre></div><pre tabindex="0"><code>## [1] 7
</code></pre><p>I wouldn&rsquo;t recommend doing stuff like that, though. Dynamic scope is terrible enough as it is, and people expect lexical scope. R has enough functions with non-standard evaluation, but they work in a reasonably consistent way, so they do not cause much trouble.</p>
<p>If you get too inventive with environments, you are just setting yourself up for trouble.</p>
<blockquote>
<p>Always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live.</p></blockquote>
<h2 id="over-scoping">Over-scoping</h2>
<p>This brings me back to the example where I started this post. The <code>lm</code> function. This function builds its model based on variables in its caller&rsquo;s environment. If you give it a data frame, it will first look there for the variables, and if it does not find them, it will look in the caller&rsquo;s scope.</p>
<p>This sounds a bit like it first looks in one place and then another, and it looks like it is chaining one environment&rsquo;s parent to another.</p>
<p>It is actually both simpler and more complicated than that.</p>
<p>The simple stuff first: When you ask <code>eval</code> to evaluate a quoted expression, you can give it an environment to do it in. We have seen that in the examples above and in my previous post.</p>
<p>You can also give it a list to search in.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>x &lt;- <span style="color:#00f">1</span> ; y &lt;- <span style="color:#00f">2</span>
</span></span><span style="display:flex;"><span>expr &lt;- quote(x + y)
</span></span><span style="display:flex;"><span>eval(expr)
</span></span></code></pre></div><pre tabindex="0"><code>## [1] 3
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>eval(expr, list(x = <span style="color:#00f">4</span>, y = <span style="color:#00f">5</span>))
</span></span></code></pre></div><pre tabindex="0"><code>## [1] 9
</code></pre><p>Data frames are just lists, so it is the same that happens if you give it a data frame.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>d &lt;- data.frame(x = <span style="color:#00f">1</span>:<span style="color:#00f">5</span>, y = <span style="color:#00f">1</span>:<span style="color:#00f">5</span>)
</span></span><span style="display:flex;"><span>eval(expr, d)
</span></span></code></pre></div><pre tabindex="0"><code>## [1]  2  4  6  8 10
</code></pre><p>If we give <code>eval</code> a list that only has some of the variables, it will use those it finds there and get the others from the caller&rsquo;s environment:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>rm(x, y)
</span></span><span style="display:flex;"><span>x &lt;- <span style="color:#00f">5</span>
</span></span><span style="display:flex;"><span>d &lt;- data.frame(y = <span style="color:#00f">1</span>:<span style="color:#00f">5</span>, z = <span style="color:#00f">1</span>:<span style="color:#00f">5</span>)
</span></span><span style="display:flex;"><span>eval(quote(x + y + z), d)
</span></span></code></pre></div><pre tabindex="0"><code>## [1]  7  9 11 13 15
</code></pre><p>We say that the list overrules the environment or that it over-scopes it.</p>
<p>This looks like it is using two environments, but it isn&rsquo;t. A list is not an environment; it doesn&rsquo;t have a parent environment either.</p>
<p>So what happens if we want <code>eval</code> to get <em>some</em> variables from a list and <em>others</em> from an environment that is not the immediate caller?</p>
<p>The function <code>f</code> below calls <code>eval</code> and that call will evaluate <code>expr</code> by first looking in the <code>vars</code> list and otherwise in the <code>f</code> call&rsquo;s scope.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>f &lt;- <span style="color:#000080;font-weight:bold">function</span>(x, y, expr, vars) eval(expr, vars)
</span></span><span style="display:flex;"><span>expr &lt;- quote(x + y + z)
</span></span><span style="display:flex;"><span>f(<span style="color:#00f">1</span>, <span style="color:#00f">2</span>, expr, list(z = <span style="color:#00f">2</span>))
</span></span></code></pre></div><pre tabindex="0"><code>## [1] 5
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>f(<span style="color:#00f">4</span>, <span style="color:#00f">5</span>, expr, list(z = <span style="color:#00f">5</span>))
</span></span></code></pre></div><pre tabindex="0"><code>## [1] 14
</code></pre><p>If you want <code>eval</code> to look in the caller&rsquo;s environment of a function, rather than the function call&rsquo;s own environment, you give it a third argument:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>g &lt;- <span style="color:#000080;font-weight:bold">function</span>(x, y, expr, vars) 
</span></span><span style="display:flex;"><span>    eval(expr, vars, rlang::caller_env())
</span></span><span style="display:flex;"><span>expr &lt;- quote(x + y + z)
</span></span><span style="display:flex;"><span>x &lt;- y &lt;- <span style="color:#00f">5</span>
</span></span><span style="display:flex;"><span>g(<span style="color:#00f">1</span>, <span style="color:#00f">2</span>, expr, list(z = <span style="color:#00f">2</span>))
</span></span></code></pre></div><pre tabindex="0"><code>## [1] 12
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>g(<span style="color:#00f">4</span>, <span style="color:#00f">5</span>, expr, list(z = <span style="color:#00f">5</span>))
</span></span></code></pre></div><pre tabindex="0"><code>## [1] 15
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>x &lt;- y &lt;- <span style="color:#00f">1</span>
</span></span><span style="display:flex;"><span>g(<span style="color:#00f">1</span>, <span style="color:#00f">2</span>, expr, list(z = <span style="color:#00f">2</span>))
</span></span></code></pre></div><pre tabindex="0"><code>## [1] 4
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>g(<span style="color:#00f">4</span>, <span style="color:#00f">5</span>, expr, list(z = <span style="color:#00f">5</span>))
</span></span></code></pre></div><pre tabindex="0"><code>## [1] 7
</code></pre><p>In this version, the variables in <code>g</code>&rsquo;s call environment are ignored; <code>eval</code> looks in the global environmentâ€”the caller&rsquo;s environmentâ€”not the local one.</p>
<p>The <code>eval</code> function takes two environment-like arguments, <code>envir</code> and <code>enclos</code>. These are the over-scoping environment and the enclosing environment. It first looks in <code>envir</code> for variables, and if that fails, it looks in <code>enclos</code>.</p>
<p>If <code>envir</code> is an environment, it never looks in <code>enclos</code>â€”that parameter is only used as a substitute for the parent environment when <code>envir</code> doesn&rsquo;t have one, e.g. when it is a list or a data frame. The default value for <code>envir</code> is the caller&rsquo;s environment, i.e. the environment where you call <code>eval</code> from. If you use a list here, the default for <code>enclos</code> is the caller&rsquo;s environment.</p>
<p>So that is how <code>eval</code> deals with over scoping. It doesn&rsquo;t combine dynamic and lexical scope, it just looks in a list before it searches an environment.</p>
<p>The reason that <code>lm</code> is slightly more complicated than this is that <code>lm</code> wants a formula as its first argument.</p>
<p>We can give it a formal and optionally a data frame to get some of the arguments:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>x &lt;- rnorm(<span style="color:#00f">5</span>) ; y &lt;- rnorm(<span style="color:#00f">5</span>)
</span></span><span style="display:flex;"><span>d &lt;- data.frame(y = rnorm(<span style="color:#00f">5</span>))
</span></span><span style="display:flex;"><span>lm(y ~ x) <span style="color:#080;font-style:italic"># local x and y</span>
</span></span></code></pre></div><pre tabindex="0"><code>## 
## Call:
## lm(formula = y ~ x)
## 
## Coefficients:
## (Intercept)            x  
##     0.07468     -0.36076
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>lm(y ~ x, data = d) <span style="color:#080;font-style:italic"># local x, data frame y</span>
</span></span></code></pre></div><pre tabindex="0"><code>## 
## Call:
## lm(formula = y ~ x, data = d)
## 
## Coefficients:
## (Intercept)            x  
##    -0.02754     -0.04762
</code></pre><p>We can also assign a formula to a variable and use that the same way:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>f &lt;- y ~ x
</span></span><span style="display:flex;"><span>lm(f) <span style="color:#080;font-style:italic"># local x and y</span>
</span></span></code></pre></div><pre tabindex="0"><code>## 
## Call:
## lm(formula = f)
## 
## Coefficients:
## (Intercept)            x  
##     0.07468     -0.36076
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>lm(f, data = d) <span style="color:#080;font-style:italic"># local x, data frame y</span>
</span></span></code></pre></div><pre tabindex="0"><code>## 
## Call:
## lm(formula = f, data = d)
## 
## Coefficients:
## (Intercept)            x  
##    -0.02754     -0.04762
</code></pre><p>However, formulae have their own environments, and these can work as closures. If you define a formula in a function, it will be associated with that function call&rsquo;s environment.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>environment(f) <span style="color:#080;font-style:italic"># f defined in the global env.</span>
</span></span></code></pre></div><pre tabindex="0"><code>## &lt;environment: R_GlobalEnv&gt;
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>make_formula &lt;- <span style="color:#000080;font-weight:bold">function</span>(x) y ~ x
</span></span><span style="display:flex;"><span>f2 &lt;- make_formula(rnorm(<span style="color:#00f">5</span>))
</span></span><span style="display:flex;"><span>f3 &lt;- make_formula(rnorm(<span style="color:#00f">5</span>))
</span></span><span style="display:flex;"><span>lm(f2) <span style="color:#080;font-style:italic"># f2 defined in a closure</span>
</span></span></code></pre></div><pre tabindex="0"><code>## 
## Call:
## lm(formula = f2)
## 
## Coefficients:
## (Intercept)            x  
##     -1.1222      -0.9481
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>lm(f3) <span style="color:#080;font-style:italic"># f3 defined in a closure</span>
</span></span></code></pre></div><pre tabindex="0"><code>## 
## Call:
## lm(formula = f3)
## 
## Coefficients:
## (Intercept)            x  
##     -0.4337      -0.4003
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>rm(x, y) <span style="color:#080;font-style:italic"># no global variables</span>
</span></span><span style="display:flex;"><span>ls(environment(f2)) <span style="color:#080;font-style:italic"># f2 still remember&#39;s an x</span>
</span></span></code></pre></div><pre tabindex="0"><code>## [1] &#34;x&#34;
</code></pre><p>If we try to fit a linear model to <code>f2</code> we get an errorâ€”there is no <code>y</code> variable anywhere.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>lm(f2)
</span></span></code></pre></div><pre tabindex="0"><code>## Error in eval(predvars, data, env): objekt &#39;y&#39; blev ikke fundet
</code></pre><p>We can still get it from the data frame, though</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>lm(f2, data = d)
</span></span></code></pre></div><pre tabindex="0"><code>## 
## Call:
## lm(formula = f2, data = d)
## 
## Coefficients:
## (Intercept)            x  
##      0.1328       0.1928
</code></pre><p>Once you start passing formulae around in function calls, everything gets just a tad more complicated. Consider these two functions for building a linear model:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>fit_model1 &lt;- <span style="color:#000080;font-weight:bold">function</span>(y) lm(x ~ y)
</span></span><span style="display:flex;"><span>fit_model2 &lt;- <span style="color:#000080;font-weight:bold">function</span>(y) lm(f)
</span></span></code></pre></div><p>The first try to build a model from the formula <code>x ~ y</code> created inside the function call. It fails because we do not have any <code>x</code> variable in the function call&rsquo;s environment or in its parent, the global environment.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>fit_model1(rnorm(<span style="color:#00f">5</span>))
</span></span></code></pre></div><pre tabindex="0"><code>## Error in eval(predvars, data, env): objekt &#39;x&#39; blev ikke fundet
</code></pre><p>The second fails because we do not have the variable <code>y</code> in the formula&rsquo;s environmentâ€”we have one in the function call&rsquo;s environment, but the formula isn&rsquo;t defined there, it was created in the earlier closure.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>fit_model2(rnorm(<span style="color:#00f">5</span>))
</span></span></code></pre></div><pre tabindex="0"><code>## Error in eval(predvars, data, env): objekt &#39;y&#39; blev ikke fundet
</code></pre><p>The <code>lm</code> function first looks in the data frame you give it if any. If it doesn&rsquo;t find the variables it needs there, it looks in the formula&rsquo;s environment. It doesn&rsquo;t look in the calling environment.</p>
<p>In the example that I started with it <em>did</em> look in the caller&rsquo;s environment, but that was because we created the formula there.</p>
<p>As I said in the previous post: the rules for finding variables in environments are not that hard to understand. It is how they combine that makes things complicated. If you didn&rsquo;t know that formulae have their own environments, then this could definitely be confusing. Now that you know they do, you can figure out why things don&rsquo;t work as intended when that happens.</p>
<p>Formulae and function calls are not the only objects that carry environments with them. Function arguments do as well. But that will have to be another post. If you cannot wait, then have a look at <a href="https://amzn.to/2QQTV8A"><em>Functional Programming in R</em></a>, <a href="https://amzn.to/2QHONDT"><em>Metaprogramming in R</em></a>, or <a href="https://amzn.to/2QHMNLL"><em>Domain-Specific Languages in R</em></a>.</p>
<!-- raw HTML omitted -->


</article>


<section class="post-nav">
    <ul>
        
        <li>
            <a href="https://mailund.dk/posts/ct-slides-chapter5/"><i class="fa fa-chevron-circle-left"></i> Slides for Computational Thinking (Chapter 5)</a>
        </li>
        
        
        <li>
            <a href="https://mailund.dk/posts/ctib-exercises-chapter4/">Exercises (CT chapter 4) <i class="fa fa-chevron-circle-right"></i> </a>
        </li>
        
    </ul>
</section>
    





</main>
    <footer>
        <h6>Copyright Â© 2020-2025 - Thomas Mailund |
            Rendered by <a href="https://gohugo.io" title="Hugo">Hugo</a> |
            <a href="https://mailund.dk/index.xml">Subscribe</a></h6>
    </footer>
</div>
<script src="https://mailund.dk/js/scripts.js"></script>
</body>
<div id="amzn-assoc-ad-04956520-8388-43ab-9b6e-fbe758d208f8"></div>
<script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=04956520-8388-43ab-9b6e-fbe758d208f8"></script>

<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

</html>
