<!doctype html>

<html lang="en">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <title>Mailund on the Internet</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="The HTML5 Herald" />
  <meta name="author" content="" />
  

  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/7.0.0/normalize.min.css" />

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />

<link rel="stylesheet" type="text/css" href="http://localhost:1313/css/styles.css" />
<link rel="stylesheet" href="https://cdn.rawgit.com/tonsky/FiraCode/1.205/distr/fira_code.css">

 
       <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Droid Sans" type="text/css" media="all" />
     
       <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Fira Mono" type="text/css" media="all" />
     

 <style>
 body {
     font-family: 'Droid Sans';
 }
 code {
    font-family: 'Fira Code';
 }
 </style>

 <script type="text/javascript" async
   src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
   MathJax.Hub.Queue(function() {
     
     
     
     var all = MathJax.Hub.getAllJax(), i;
     for(i = 0; i < all.length; i += 1) {
         all[i].SourceElement().parentNode.className += ' has-jax';
     }
   });

   MathJax.Hub.Config({
   
   TeX: { equationNumbers: { autoNumber: "AMS" } }
   });
   MathJax.Hub.Config({
   tex2jax: {
     inlineMath: [['$$','$$'], ['\\(','\\)']],
     displayMath: [['$$$','$$$']],
     processEscapes: true,
     processEnvironments: true,
     skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
     TeX: { equationNumbers: { autoNumber: "AMS" },
          extensions: ["AMSmath.js", "AMSsymbols.js"] }
   }
   });
 </script>

      <script async src="https://www.googletagmanager.com/gtag/js?id=386493837"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', '386493837');
        }
      </script>
</head>

<body>
  <div id="container">
    <header>
      <h1>
                <a href="http://localhost:1313/">Mailund on the Internet</a>
            </h1>

      <ul id="social-media">
                
      </ul>
      
      <p><em>On Writing, Science, Programming and more</em></p>
      

    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="" href="http://localhost:1313/about/">
                <i class="fa-li fa  fa-lg"></i><span>About</span>
            </a>
        </li>
        
        <li>
            <a class="" href="http://localhost:1313/posts">
                <i class="fa-li fa  fa-lg"></i><span>Posts</span>
            </a>
        </li>
        
        <li>
            <a class="" href="http://localhost:1313/books/">
                <i class="fa-li fa  fa-lg"></i><span>Books</span>
            </a>
        </li>
        
        <li>
            <a class="" href="http://localhost:1313/fiction/">
                <i class="fa-li fa  fa-lg"></i><span>Fiction</span>
            </a>
        </li>
        
        <li>
            <a class="" href="http://localhost:1313/publications/">
                <i class="fa-li fa  fa-lg"></i><span>Publications</span>
            </a>
        </li>
        
        <li>
            <a class="" href="http://localhost:1313/software/">
                <i class="fa-li fa  fa-lg"></i><span>Software</span>
            </a>
        </li>
        
    </ul>
</nav>

    <main>




<article>

    <h1>Exercises (CT chapter 5)</h1>

    
        <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2018-09-24T10:54:12&#43;02:00">Sep 24, 2018</time>
        </li>
        
        

        
        <li>
            <em>
                
                    
                    <a href="http://localhost:1313/tags/teaching/">#teaching</a>
                
                    , 
                    <a href="http://localhost:1313/tags/computational-thinking/">#computational-thinking</a>
                
            </em>
        </li>
        

        <li>10 min read</li>
    </ul>
</aside>
    

    <p>I’m on a roll today! Here are the exercises for chapter 5 of <a href="https://leanpub.com/comp-thinking"><em>Introduction to Computational Thinking</em></a>.</p>
<p>Let me know if you spot any errors; I am known to make some from time to time.</p>
<h1 id="exercises">Exercises</h1>
<h2 id="selection-sort">Selection sort</h2>
<p><strong>Exercise:</strong> Give an example input where selection sort is not stable.</p>
<h2 id="insertion-sort">Insertion sort</h2>
<p><strong>Exercise:</strong> Describe what the input list should look like to achieve best-case and worst-case time performance, respectively.</p>
<h2 id="bubble-sort">Bubble sort</h2>
<p><strong>Exercise:</strong> Since O₁ and O₂ tells us that the last j elements are already the largest numbers and are already sorted, we do not need to have the inner loop iterate through these last j elements. How would you exploit this to improve the running time of bubble sort? The worst-case behaviour will not improve, but you can change the running time to about half of the one we have above. Show that this is the case.</p>
<p><strong>Exercise:</strong> With cocktail sort, after running the outer loop j times, both the first j and the last j elements are in their final positions. Show that this is the case.</p>
<p><strong>Exercise:</strong> Knowing that both the first and last j elements are already in their right position can be used to iterate over fewer elements in the inner loops. Modify the algorithm to exploit this. The worst case complexity will still be O(n²), but you will make fewer comparisons. How much do you reduce the number of comparisons by?</p>
<h2 id="comparison-sort-comparison">Comparison sort comparison</h2>
<p><strong>Exercise:</strong> Insertion sort runs in O(n²) when the input is sorted in the reverse order, but can process sorted sequences in O(n). If we can recognise that the input is ordered in reverse, we could first reverse the sequence and then run the insertion sort. Show that we can reverse a sequence, in place, in O(n). Try to adapt insertion sort, so you first recognise consecutive runs of non-increasing elements, then reverse these before you run insertion sort on the result. Show that the worst-case running time is still O(n²), but try to compare the modified algorithm with the traditional insertion sort to see if it works better in practice.</p>
<h2 id="bucket-sort">Bucket sort</h2>
<p><strong>Exercise:</strong> Argue why the inner loop in</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>result_keys, result_values = [], []
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">for</span> key <span style="font-weight:bold">in</span> range(m):
</span></span><span style="display:flex;"><span>	<span style="color:#000080;font-weight:bold">for</span> val <span style="font-weight:bold">in</span> buckets[key]:
</span></span><span style="display:flex;"><span>		result_keys.append(key)
</span></span><span style="display:flex;"><span>		result_values.append(val)
</span></span></code></pre></div><p>only executes n times.</p>
<p><strong>Exercise:</strong> Argue why the bucket sort actually sorts the input.</p>
<h1 id="answers">Answers</h1>
<h2 id="selection-sort-1">Selection sort</h2>
<p><strong>Exercise:</strong> Give an example input where selection sort is not stable.</p>
<p>Consider this input. I use pairs where the first item is the key and the second item is the order of the elements in the input. That is, <code>(2,1)</code> and <code>(1,1)</code> are the first occurrences of keys <code>2</code> and <code>1</code>, respectively, and <code>(2,2)</code> is the second occurrence of key <code>2</code>.</p>
<pre tabindex="0"><code>(2,1), (2,2), (1,1)
</code></pre><p>In the first iteration we search for the smallest element, which is <code>(1,1)</code>. We then swap <code>(2,1)</code> with <code>(1,1)</code>.</p>
<pre tabindex="0"><code>(1,1), (2,2), (2,1)
</code></pre><p>We have now reversed the order of the twos. Whether the algorithm is stable or not now depends on whether we pick the first or the last item that has the smallest key. If we pick the first, then the algorithm is not stable. (If you pick the last pair with the minimal key, then the algorithm wouldn’t be stable on <code>(2,1), (2,2), (1,1), (1,2)</code>—try it out to convince yourself of this).</p>
<h2 id="insertion-sort-1">Insertion sort</h2>
<p><strong>Exercise:</strong> Describe what the input list should look like to achieve best-case and worst-case time performance, respectively.</p>
<p>If the input is already sorted, then we never swap any items. The inner loop is always terminated at the first comparison and the body is never executed.</p>
<p>If the input is sorted in reverse order, then the inner loop will always run through the entire prefix of sorted items, which is the maximum number of iterations it can have.</p>
<h2 id="bubble-sort-1">Bubble sort</h2>
<p><strong>Exercise:</strong> Since O₁ and O₂ tells us that the last j elements are already the largest numbers and are already sorted, we do not need to have the inner loop iterate through these last j elements. How would you exploit this to improve the running time of bubble sort? The worst-case behaviour will not improve, but you can change the running time to about half of the one we have above. Show that this is the case.</p>
<p>We can modify the code just a little bit by replacing the outer <code>while</code> loop with a <code>for</code> loop that runs from zero to the length of the input (those are the maximum number of iterations the <code>while</code> loop could run). Since we know that after iteration <em>j</em> the last <em>j</em> elements are already sorted, we can cap the inner <code>for</code>-loop at <code>len(x) - j</code>.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">for</span> j <span style="font-weight:bold">in</span> range(len(x)):
</span></span><span style="display:flex;"><span>    swapped = <span style="color:#000080;font-weight:bold">False</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">for</span> i <span style="font-weight:bold">in</span> range(<span style="color:#00f">1</span>,len(x) - j):
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">if</span> x[i-<span style="color:#00f">1</span>] &gt; x[i]:
</span></span><span style="display:flex;"><span>            x[i-<span style="color:#00f">1</span>], x[i] = x[i], x[i-<span style="color:#00f">1</span>]
</span></span><span style="display:flex;"><span>            swapped = <span style="color:#000080;font-weight:bold">True</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">if</span> <span style="font-weight:bold">not</span> swapped:
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">break</span>
</span></span></code></pre></div><p>Where the first version of bubble-sort ran through the entire list in each inner loop, taking time <em>n</em> always, the second version takes time <em>n</em> the first time it is run, <em>n-1</em> the second, <em>n-2</em> the third, and so on. This sum is n(n+1)/2, so about one half of the n² of the first version.</p>
<p><strong>Exercise:</strong> With cocktail sort, after running the outer loop j times, both the first j and the last j elements are in their final positions. Show that this is the case.</p>
<p>The argument is really the same as for bubble-sort and the last j elements. After the cocktail sort has iterated from left to right in iteration j, the j largest elements are sorted and in their right position. After iterating from right to left, the smallest j elements are sorted and at the right positions.</p>
<p><strong>Exercise:</strong> Knowing that both the first and last j elements are already in their right position can be used to iterate over fewer elements in the inner loops. Modify the algorithm to exploit this. The worst case complexity will still be O(n²), but you will make fewer comparisons. How much do you reduce the number of comparisons by?</p>
<p>We can modify the cocktail shaker sort the same way we did bubble sort, skip the last and the first j elements:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>x = x[:]
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">for</span> j <span style="font-weight:bold">in</span> range(len(x)):
</span></span><span style="display:flex;"><span>    swapped = <span style="color:#000080;font-weight:bold">False</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">for</span> i <span style="font-weight:bold">in</span> range(<span style="color:#00f">1</span>,len(x) - j):
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">if</span> x[i-<span style="color:#00f">1</span>] &gt; x[i]:
</span></span><span style="display:flex;"><span>            x[i-<span style="color:#00f">1</span>], x[i] = x[i], x[i-<span style="color:#00f">1</span>]
</span></span><span style="display:flex;"><span>            swapped = <span style="color:#000080;font-weight:bold">True</span>
</span></span><span style="display:flex;"><span>				
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">if</span> <span style="font-weight:bold">not</span> swapped:
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">break</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">for</span> i <span style="font-weight:bold">in</span> range(len(x) - j - <span style="color:#00f">1</span>, j + <span style="color:#00f">1</span>, -<span style="color:#00f">1</span>):
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">if</span> x[i-<span style="color:#00f">1</span>] &gt; x[i]:
</span></span><span style="display:flex;"><span>            x[i-<span style="color:#00f">1</span>], x[i] = x[i], x[i-<span style="color:#00f">1</span>]
</span></span><span style="display:flex;"><span>            swapped = <span style="color:#000080;font-weight:bold">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">if</span> <span style="font-weight:bold">not</span> swapped:
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">break</span>
</span></span></code></pre></div><p>With this version we reduce the interval by two in each outer loop, but we run two sweeps for each outer loop, one left-to-right and one right-to-left. Therefore, if we run the outer loop n times, the running time is 2(n + (n-2) + (n-4) + … 2) which is 2 × n(n+2)/4 = n(n+2)/2.</p>
<p>This worst-case running time of this algorithm is worse than the improved bubble sort.</p>
<p>The idea with cocktail sort is that we run the outer loop fewer times than bubble sort does. With bubble sort, we know that we get at least one item to its correct location in each outer iteration. With cocktail sort, we get at least two items to the right position. Since we terminate as soon as we see no swaps, this means that the maximum number of iterations of the outer loop in bubble sort is n, but for cocktail sort it is n/2.</p>
<p>Since we only have half as many iterations of the outer loop, but each iteration is twice as expensive as for bubble sort, the two cancels. The cocktail sort is actually a little worse, with n(n+2)/2 instead of n(n+1)/2.</p>
<p>The hope, of course, is that both algorithms get <em>more</em> than a single element to its right location in each iteration, and then that cocktail sort gets more items moved to their correct position per iteration than bubble sort does.</p>
<h2 id="comparison-sort-comparison-1">Comparison sort comparison</h2>
<p><strong>Exercise:</strong> Insertion sort runs in O(n²) when the input is sorted in the reverse order, but can process sorted sequences in O(n). If we can recognise that the input is ordered in reverse, we could first reverse the sequence and then run the insertion sort. Show that we can reverse a sequence, in place, in O(n). Try to adapt insertion sort, so you first recognise consecutive runs of non-increasing elements, then reverse these before you run insertion sort on the result. Show that the worst-case running time is still O(n²), but try to compare the modified algorithm with the traditional insertion sort to see if it works better in practice.</p>
<p>You can reverse decreasing intervals like this:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>k = <span style="color:#00f">0</span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">while</span> k &lt; len(x) - <span style="color:#00f">1</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic"># locate decreasing interval</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">for</span> l <span style="font-weight:bold">in</span> range(k + <span style="color:#00f">1</span>, len(x)):
</span></span><span style="display:flex;"><span>        <span style="color:#000080;font-weight:bold">if</span> x[l] &gt;= x[l - <span style="color:#00f">1</span>]: <span style="color:#080;font-style:italic"># no longer decreasing</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000080;font-weight:bold">break</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic"># reverse it</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">if</span> l &gt; k + <span style="color:#00f">1</span>:
</span></span><span style="display:flex;"><span>        print(k, l, x[k:l])
</span></span><span style="display:flex;"><span>    i, j = k, l - <span style="color:#00f">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000080;font-weight:bold">while</span> j &gt; i:
</span></span><span style="display:flex;"><span>        x[i], x[j] = x[j], x[i]
</span></span><span style="display:flex;"><span>        i += <span style="color:#00f">1</span>; j -= <span style="color:#00f">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    k = l <span style="color:#080;font-style:italic"># skip past the interval we just reversed</span>
</span></span></code></pre></div><p>I use a <code>while</code> loop for <code>k</code> because I want to update it to jump past intervals we have reversed. If we do not do this, then we run through them twice, just the second time all decreasing intervals are of length one… we might as well skip them.</p>
<p>I stop at <code>len(x) - 1</code> instead of <code>len(x)</code> because we do not need to reverse an interval of length one; it also guarantees that we never end up with <code>k == l</code>—this could happen if <code>k == len(x) - 1</code> because we then make <code>l</code> iterate over <code>range(len(x), len(x))</code>. This doesn’t change <code>l</code>, and if <code>k == len(x) - 1</code> it is because <code>l</code> had this value when we assigned it to <code>k</code>. We do not want that, so therefore this condition in the <code>while</code> loop.</p>
<p>Whether you use <code>&gt;=</code> or <code>&gt;</code> in the test in the inner loop is a bit arbitrary. It affects the result when you hit intervals with equal key, and I have chosen to iterate through those.</p>
<p>It should be fairly easy to see that the reversal runs in linear time (in the length of the interval we reverse). To see that the entire algorithm runs in linear time, observe that the outer loop segments the sequence into non-overlapping intervals that we reverse. In each iteration, we identify an interval <code>[k,l)</code> that we then reverse (in time <code>O(l-k)</code>), and then we increment <code>k</code> to <code>l</code> so the outer loop never sees this interval again.</p>
<h2 id="bucket-sort-1">Bucket sort</h2>
<p><strong>Exercise:</strong> Argue why the inner loop in</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>result_keys, result_values = [], []
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold">for</span> key <span style="font-weight:bold">in</span> range(m):
</span></span><span style="display:flex;"><span>	<span style="color:#000080;font-weight:bold">for</span> val <span style="font-weight:bold">in</span> buckets[key]:
</span></span><span style="display:flex;"><span>		result_keys.append(key)
</span></span><span style="display:flex;"><span>		result_values.append(val)
</span></span></code></pre></div><p>only executes n times.</p>
<p>This is almost trivial to see. We insert <code>n</code> elements in the various buckets <em>in total</em>. We never extract more elements from the buckets than we inserted. There you are, we do not iteration through the inner loop more than <code>n</code> times. This doesn’t mean that we never test the loop condition more than once, though. We try to iterate through <code>buckets[key]</code> for each <code>key</code>—including those buckets that are empty. This is the reason that the algorithm runs in O(n + m) and not just O(n).</p>
<p><strong>Exercise:</strong> Argue why the bucket sort actually sorts the input.</p>
<p>If the items are inserted into the correct buckets, i.e. the keys of the items in bucket <code>key</code> are all <code>key</code>, then the proof boils down to observing that iterate through the buckets in sorted order when we output the items.</p>
<!-- raw HTML omitted -->


</article>


<hr/>
<div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "mailund-dk" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
<hr/>
<section class="post-nav">
    <ul>
        
        <li>
            <a href="http://localhost:1313/posts/ctib-exercises-chapter4/"><i class="fa fa-chevron-circle-left"></i> Exercises (CT chapter 4)</a>
        </li>
        
        
        <li>
            <a href="http://localhost:1313/posts/ctib-slides-chapter7/">Slides (CT Chapter 7) <i class="fa fa-chevron-circle-right"></i> </a>
        </li>
        
    </ul>
</section>
  





</main>
    <footer>
        <h6>Copyright © 2020-2025 - Thomas Mailund |
            Rendered by <a href="https://gohugo.io" title="Hugo">Hugo</a> |
            <a href="http://localhost:1313/index.xml">Subscribe</a></h6>
    </footer>
</div>
<script src="http://localhost:1313/js/scripts.js"></script>
</body>
<div id="amzn-assoc-ad-04956520-8388-43ab-9b6e-fbe758d208f8"></div>
<script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=04956520-8388-43ab-9b6e-fbe758d208f8"></script>

<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

</html>
