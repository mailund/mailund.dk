<!doctype html>

<html lang="en">

<head>
  <title>Mailund on the Internet</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="The HTML5 Herald" />
  <meta name="author" content="Thomas Mailund" />
  

  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/7.0.0/normalize.min.css" />

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />

<link rel="stylesheet" type="text/css" href="https://mailund.dk/css/styles.css" />
<link rel="stylesheet" href="https://cdn.rawgit.com/tonsky/FiraCode/1.205/distr/fira_code.css">

 
       <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Droid Sans" type="text/css" media="all" />
     
       <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Fira Mono" type="text/css" media="all" />
     

 <style>
 body {
     font-family: 'Droid Sans';
 }
 code {
    font-family: 'Fira Code';
 }
 </style>

 <script type="text/javascript" async
   src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
   MathJax.Hub.Queue(function() {
     
     
     
     var all = MathJax.Hub.getAllJax(), i;
     for(i = 0; i < all.length; i += 1) {
         all[i].SourceElement().parentNode.className += ' has-jax';
     }
   });

   MathJax.Hub.Config({
   
   TeX: { equationNumbers: { autoNumber: "AMS" } }
   });
   MathJax.Hub.Config({
   tex2jax: {
     inlineMath: [['$$','$$'], ['\\(','\\)']],
     displayMath: [['$$$','$$$']],
     processEscapes: true,
     processEnvironments: true,
     skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
     TeX: { equationNumbers: { autoNumber: "AMS" },
          extensions: ["AMSmath.js", "AMSsymbols.js"] }
   }
   });
 </script>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-10582357-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

</head>

<body>
  <div id="container">
    <header>
      <h1>
                <a href="https://mailund.dk/">Mailund on the Internet</a>
            </h1>

      <ul id="social-media">
        
        <li><a href="https://twitter.com/ThomasMailund"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
         
        <li><a href="https://www.linkedin.com/in/thomas-mailund-94153b1"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
         
        <li><a href="https://github.com/mailund"><i class="fab fa-github fa-lg" aria-hidden="true"></i></a></li>
          
        <li><a href="https://www.facebook.com/mailund"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
          
        <li><a href="https://patreon.com/mailund"><i class="fab fa-patreon fa-lg" aria-hidden="true"></i></a></li>
         
        <li><a href="https://www.goodreads.com/author/show/15484380.Thomas_Mailund"><i class="fab fa-goodreads fa-lg" aria-hidden="true"></i></a></li>
         
        <li><a href="https://www.stackoverflow.com/users/2170269/thomas-mailund"><i class="fab fa-stack-overflow fa-lg" aria-hidden="true"></i></a></li>
        
      </ul>
      
      <p><em>On Writing, Science, Programming and more</em></p>
      

    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="" href="https://mailund.dk/about/">
                <i class="fa-li fa  fa-lg"></i><span>About</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://mailund.dk/posts">
                <i class="fa-li fa  fa-lg"></i><span>Posts</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://mailund.dk/books/">
                <i class="fa-li fa  fa-lg"></i><span>Books</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://mailund.dk/fiction/">
                <i class="fa-li fa  fa-lg"></i><span>Fiction</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://mailund.dk/publications/">
                <i class="fa-li fa  fa-lg"></i><span>Publications</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://mailund.dk/software/">
                <i class="fa-li fa  fa-lg"></i><span>Software</span>
            </a>
        </li>
        
    </ul>
</nav>

    <main>




<article>

    <h1>CPS and Iterators in C</h1>

    
        <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2021-10-21T04:50:01&#43;02:00">Oct 21, 2021</time>
        </li>
        
        
        <li>
            Categories: 
            <em>
                
                    
                    <a href="https://mailund.dk/categories/programming/">Programming</a>
                
            </em>
        </li>
        

        
        <li>
            <em>
                
                    
                    <a href="https://mailund.dk/tags/programming/">#programming</a>
                
                    , 
                    <a href="https://mailund.dk/tags/c/">#C</a>
                
            </em>
        </li>
        

        <li>47 min read</li>
    </ul>
</aside>
    

    <p>Today, I want to talk about <em>continuation-passing-style</em> (CSP). This is a general approach you can use to translate recursions into tail-calls.</p>
<p>What&rsquo;s tail-calls, I (imagine hearing) you ask?</p>
<p>A <a href="https://en.wikipedia.org/wiki/Tail_call">tail-call</a> is when a function calls another function as the last thing it does. Tail-recursion is when that last call is a recursive call, but that is just a special case of tail-calls.</p>
<p>This is a recursive function, in Python, that computes the factorial of a number:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000080;font-weight:bold">def</span> fact(n):
    match n:
        case <span style="color:#00f">0</span>: <span style="color:#000080;font-weight:bold">return</span> <span style="color:#00f">1</span>
        case _: <span style="color:#000080;font-weight:bold">return</span> n * fact(n - <span style="color:#00f">1</span>)
</code></pre></div><p>(I use pattern matching from Python 3.10, but you can probably easily implement it without matching yourself).</p>
<p>It isn&rsquo;t tail-recursive, because after calling recursively, <code>fact(n - 1)</code>, we take the result and multiply it with <code>n</code>. The multiplication is the last thing we do, not the recursive call.</p>
<p>To make a tail-recursive version, we can add an accumulator and get:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000080;font-weight:bold">def</span> fact(n, acc = <span style="color:#00f">1</span>):
    match n:
        case <span style="color:#00f">0</span>: <span style="color:#000080;font-weight:bold">return</span> acc
        case _: <span style="color:#000080;font-weight:bold">return</span> fact(n - <span style="color:#00f">1</span>, n * acc)
</code></pre></div><p>Now, the last thing we do in the recursion is calling recursively, <code>fact(n - 1, n * acc)</code>. We&rsquo;ve moved the multiplication into an argument, so we don&rsquo;t need to wait for the recursion to finish to do it.</p>
<p>The nice thing about tail-calls is that since the call is the last thing to do, you do not need to remember any state for when it finishes, so you don&rsquo;t need the call frame any more. The new call can take over the existing frame, and when it returns, it can return directly to the point of the original call rather than back to the calling function just to return immediately again. In other words, tail recursion can be translated into a loop in a straightforward manner.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000080;font-weight:bold">def</span> fact(n, acc = <span style="color:#00f">1</span>):
    <span style="color:#000080;font-weight:bold">while</span> n &gt; <span style="color:#00f">0</span>:
        <span style="color:#080;font-style:italic"># update variables instead of calling recursively</span>
        n, acc = n - <span style="color:#00f">1</span>, n * acc
    <span style="color:#000080;font-weight:bold">return</span> acc
</code></pre></div><p>Translating recursion into a loop has several benefits. Looping is (slightly) faster than calling and returning from functions, but more importantly, reusing a stack frame reduces the stack space you need for a function, and stack space is a limited resource.</p>
<p>You don&rsquo;t notice this often, you usually don&rsquo;t recurse that deeply, but it can be a problem. If you use recursion to go down a balanced search tree, you won&rsquo;t have any problems unless the tree is gigantic, because a balanced tree has depth O(log n). If n is four billion, the depth is (if perfectly balanced) only 32, and that is never an issue.</p>
<p>But try traversing a suffix tree over a string of a few million characters. Those bastards can be highly un-balanced, and then you have a problem. You run out of stack space, and your program will not take that kindly.</p>
<p>Optimising tail-calls into loops get rid of the problem entirely. Calls become loops, and you only need a single stack frame for the entire thing.</p>
<p>Plus, the loop transformation is easy to do. It is so simple that you can automate it. <a href="https://github.com/mailund/tailr">I did it (with some limitations) for R in a package.</a>.</p>
<p>If it is simple enough that I can do it, then you can bet that compilers can do it. For pure functional languages, they are guaranteed to do it. There you don&rsquo;t have loops at all, you only have recursion, so it is imperative that those recursions can be translated into loops.</p>
<p>Python, not being a functional language, does not implement the tail-call optimisation, though. R, a functional language but one that has loops, doesn&rsquo;t do it either. Whether this is out of laziness or because they think that you should just use loops, I don&rsquo;t know. But you can make the transformation yourself, as I did for <code>fact(n)</code> above.</p>
<p>But what happens if you need to call more than one function? What if you need to recurse twice?</p>
<p>What can you do about something like the Fibonacci numbers?</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000080;font-weight:bold">def</span> fib(n):
    match n:
        case <span style="color:#00f">0</span> | <span style="color:#00f">1</span>: <span style="color:#000080;font-weight:bold">return</span> n
        case _: <span style="color:#000080;font-weight:bold">return</span> fib(n-<span style="color:#00f">1</span>) + fib(n-<span style="color:#00f">2</span>)
</code></pre></div><p>(I know this is a stupid example, because the obvious iterative way of computing Fibonacci numbers will be asymptotically much faster and never need more than one stack frame, but it is a simple and well-known example, so go with it…)</p>
<p>At best, you can make one of the recursive calls the last call. It looks like you would have to make at least one recursive call that needs stack space.</p>
<p>At least if we think about recursion the usual way, where we do some work going down the recursion and some other work coming back. But we don&rsquo;t have to think this way. We can get rid of the usual call-return thinking and replace it with something else: continuations.</p>
<h1 id="continuations-and-continuation-passing-style">Continuations and continuation-passing-style</h1>
<p>Imagine that the <code>return</code> statement doesn&rsquo;t exist, and instead we always have to call a function to move the control-flow somewhere else. Functions take such a function as argument, we call it a <em>continuation</em>, and when they want to &ldquo;return&rdquo;, i.e., pass back control-flow to something the caller intended, we call that function.</p>
<p>When we call a function, we can hook into that mechanism. If there is something we need to get done with the result of the function call, we can give the function a continuation that does it. It will be called with the result of the call, then it can do what extra work we need doing, and then invoke the continuation that takes us back to our caller.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000080;font-weight:bold">def</span> fact(n, k = <span style="color:#000080;font-weight:bold">lambda</span> x: x):
    match n:
        case <span style="color:#00f">0</span>:
            <span style="color:#080;font-style:italic"># base case: call continuation on base</span>
            <span style="color:#000080;font-weight:bold">return</span> k(<span style="color:#00f">1</span>)
        case _: 
            <span style="color:#080;font-style:italic"># recursive all, give it a continuation</span>
            <span style="color:#080;font-style:italic"># that multiplies the result of the</span>
            <span style="color:#080;font-style:italic"># recursion to n</span>
            <span style="color:#000080;font-weight:bold">return</span> fact(n - <span style="color:#00f">1</span>, <span style="color:#000080;font-weight:bold">lambda</span> res: k(n * res))
</code></pre></div><p>This is Python, we still have <code>return</code> and we need to use it to make a call to <code>fact(n)</code> return the normal way, but all the calls are tail-calls and we return the result of those calls. We just provide a continuation at each step that does what we would normally do with the return value. The recursion will go all the way down from <code>n</code> to <code>0</code> and along the way it will build up a string of continuations for multiplying the numbers.</p>
<p>Once we reach 0, we call the continuation, and that starts evaluating all the accumulated functions.</p>
<p>The computation works the same way as the direct recursion: first you go all the way down to zero, and then you multiply all the numbers. The multiplication is just not done in the original recursive functions but in the continuations.</p>
<p>Without the tail-call optimisation, this is a bad idea. Instead of just filling the stack with recursive calls, we first fill it with the recursions and <em>then</em> we double the number of stack frames by invoking the continuations. So, in Python or R, this is not a good idea.</p>
<p>You can get out of the problem using thunks and trampolines. I&rsquo;ve written about those for R in <a href="https://amzn.to/3jnoeUj">Functional Programming in R</a> and for Python in <a href="https://amzn.to/3C3euGj">Introduction to Computational Thinking</a>, so I won&rsquo;t write more about it here. In any case, this post is about C that <em>does</em> implement tail-call optimisation (and just not all the other things we need to make CPS work, but we can do that ourselves).</p>
<p>How does continuations allow for tail-calls with multiple recursions? Easy enough, you call the first recursion with a continuation that is responsible for the second (or third or fourth, …) recursion. It will be invoked when the first recursion is done, and now you have the stack frame free for use for another string of recursions and continuations.</p>
<p>Here&rsquo;s <code>fib(n)</code> with continuations:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000080;font-weight:bold">def</span> fib(n, k = <span style="color:#000080;font-weight:bold">lambda</span> x: x):
    match n:
        case <span style="color:#00f">0</span> | <span style="color:#00f">1</span>: <span style="color:#000080;font-weight:bold">return</span> k(n)
        case _:
            <span style="color:#000080;font-weight:bold">def</span> k1(res1):
                <span style="color:#000080;font-weight:bold">return</span> fib(n - <span style="color:#00f">2</span>, <span style="color:#000080;font-weight:bold">lambda</span> res2: k(res1 + res2))
            <span style="color:#000080;font-weight:bold">return</span> fib(n - <span style="color:#00f">1</span>, k1)
</code></pre></div><p>The continuation <code>k1</code> is the function we give to the first recursion. It will eventually be called with the result of <code>fib(n - 1)</code>. Then it needs to compute <code>fib(n - 2)</code> so it can add the results of the two recursion, so it will call <code>fib(n - 2)</code> with a new continuation. That continuation, <code>lambda res2: …</code> will get the result of <code>fib(n - 2)</code>, so now it has both <code>res1 = fib(n - 1)</code> and <code>res2 = fib(n - 2)</code> and it can add the two and give the result to the original continuation, <code>k(res1 + res2)</code>, thus passing the result on to the callers continuation.</p>
<p>If you take a general function and identify all the function calls it make, you can split the function at those places. Everything that comes after a function call, where you would normally continue the computation, you can put in another function and make a continuation.</p>
<p><a href="https://en.wikipedia.org/wiki/Call-with-current-continuation">Call/cc</a> does something to that effect, while still looking like a normal call-return, but we don&rsquo;t have that in C or Python (you do have it in R), so that isn&rsquo;t useful for us here; we would need to split functions in this way. And you always can, so you can always translate functions into tail-call versions.</p>
<p>Okay, I introduced the idea with Python, because Python has high-order functions and closures, and it is simple to implement CPS there. (Even though you won&rsquo;t get the benefits of it, as the tail-call optimisation isn&rsquo;t there).</p>
<p>I want to do it in C.</p>
<p>There is a reason why I&rsquo;m interested in doing it in C, and I&rsquo;ll get back to that before the post is over, but for now, let&rsquo;s just check if it is something we can do.</p>
<h1 id="tail-call-optimisation-in-c">Tail-call optimisation in C</h1>
<p>The C standard doesn&rsquo;t require that compilers implement tail-call optimisation, but they usually do if you turn on optimisation. I tested a few compilers with this C-version of the factorial function:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">int</span> fact(<span style="color:#000080;font-weight:bold">int</span> n, <span style="color:#000080;font-weight:bold">int</span> acc)
{
    <span style="color:#000080;font-weight:bold">if</span> (n &lt;= <span style="color:#00f">1</span>) <span style="color:#000080;font-weight:bold">return</span> acc;
    <span style="color:#000080;font-weight:bold">return</span> fact(n - <span style="color:#00f">1</span>, acc * n);
}
</code></pre></div><p>Without optimisation, the compilers won&rsquo;t do any optimisation, including tail-calls, so I tested with <code>-O2</code> or the equivalent. I used <a href="https://godbolt.org">https://godbolt.org</a>; my go-to places for checking the code that compilers generate.</p>
<p>Here&rsquo;s the result <code>gcc 11.2 (x86_64)</code>:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm">fact:
        mov     eax, esi
        cmp     edi, <span style="color:#00f">1</span>
        jle     .L5
.L2:
        imul    eax, edi
        sub     edi, <span style="color:#00f">1</span>
        cmp     edi, <span style="color:#00f">1</span>
        jne     .L2
.L5:
        ret
</code></pre></div><p>It&rsquo;s rather straight-forward, but if you don&rsquo;t speak assembler, just know that a call in <code>x86_64</code> is done with the instruction <code>call</code>, and here there isn&rsquo;t any. That means that the function does not call any other function. The <code>jne .L2</code> is a loop, and it is what the recursive call was translated into.</p>
<p>Here&rsquo;s the code generated by <code>msvc 19.10 (x86_64)</code>:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm">n$ <span style="color:#a61717;background-color:#e3d2d2">=</span> <span style="color:#00f">8</span>
acc$ <span style="color:#a61717;background-color:#e3d2d2">=</span> <span style="color:#00f">16</span>
fact    PROC                                            <span style="color:#080;font-style:italic">; COMDAT
</span><span style="color:#080;font-style:italic"></span>        cmp     ecx, <span style="color:#00f">1</span>
        jle     SHORT $LN11@fact
$LL4@fact:
        imul    edx, ecx
        dec     ecx
        cmp     ecx, <span style="color:#00f">1</span>
        jg      SHORT $LL4@fact
$LN11@fact:
        mov     eax, edx
        ret     <span style="color:#00f">0</span>
fact    ENDP
</code></pre></div><p>Again, there is no <code>call</code> instruction, but there is the <code>jg SHORT $LL4@fact</code> instruction that is the corresponding loop.</p>
<p>With <code>icc 19.0.1 (x86_64)</code>:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm">fact:
        mov       ecx, edi                                      <span style="color:#080;font-style:italic">#13.1
</span><span style="color:#080;font-style:italic"></span>        mov       eax, esi                                      <span style="color:#080;font-style:italic">#13.1
</span><span style="color:#080;font-style:italic"></span>        cmp       ecx, <span style="color:#00f">1</span>                                        <span style="color:#080;font-style:italic">#14.14
</span><span style="color:#080;font-style:italic"></span>        jle       ..B1.9        <span style="color:#080;font-style:italic"># Prob 12%                      #14.14
</span><span style="color:#080;font-style:italic"></span>        cmp       ecx, <span style="color:#00f">2</span>                                        <span style="color:#080;font-style:italic">#14.14
</span><span style="color:#080;font-style:italic"></span>        jle       ..B1.11       <span style="color:#080;font-style:italic"># Prob 12%                      #14.14
</span><span style="color:#080;font-style:italic"></span>        lea       esi, DWORD PTR [-<span style="color:#00f">1</span><span style="color:#a61717;background-color:#e3d2d2">+</span>rcx]                       <span style="color:#080;font-style:italic">#15.21
</span><span style="color:#080;font-style:italic"></span>        imul      esi, ecx                                      <span style="color:#080;font-style:italic">#15.30
</span><span style="color:#080;font-style:italic"></span>        cmp       ecx, <span style="color:#00f">3</span>                                        <span style="color:#080;font-style:italic">#14.14
</span><span style="color:#080;font-style:italic"></span>        jle       ..B1.10       <span style="color:#080;font-style:italic"># Prob 12%                      #14.14
</span><span style="color:#080;font-style:italic"></span>        lea       edx, DWORD PTR [-<span style="color:#00f">2</span><span style="color:#a61717;background-color:#e3d2d2">+</span>rcx]                       <span style="color:#080;font-style:italic">#15.21
</span><span style="color:#080;font-style:italic"></span>        cmp       ecx, <span style="color:#00f">4</span>                                        <span style="color:#080;font-style:italic">#14.14
</span><span style="color:#080;font-style:italic"></span>        jle       ..B1.6        <span style="color:#080;font-style:italic"># Prob 12%                      #14.14
</span><span style="color:#080;font-style:italic"></span>        imul      esi, edx                                      <span style="color:#080;font-style:italic">#15.12
</span><span style="color:#080;font-style:italic"></span>        lea       edi, DWORD PTR [-<span style="color:#00f">4</span><span style="color:#a61717;background-color:#e3d2d2">+</span>rcx]                       <span style="color:#080;font-style:italic">#15.12
</span><span style="color:#080;font-style:italic"></span>        add       ecx, -<span style="color:#00f">3</span>                                       <span style="color:#080;font-style:italic">#15.12
</span><span style="color:#080;font-style:italic"></span>        imul      ecx, eax                                      <span style="color:#080;font-style:italic">#15.12
</span><span style="color:#080;font-style:italic"></span>        imul      esi, ecx                                      <span style="color:#080;font-style:italic">#15.12
</span><span style="color:#080;font-style:italic"></span>        jmp       fact                                          <span style="color:#080;font-style:italic">#15.12
</span><span style="color:#080;font-style:italic"></span>..B1.6:                         <span style="color:#080;font-style:italic"># Preds ..B1.4
</span><span style="color:#080;font-style:italic"></span>        imul      eax, edx                                      <span style="color:#080;font-style:italic">#15.30
</span><span style="color:#080;font-style:italic"></span>        imul      eax, esi                                      <span style="color:#080;font-style:italic">#15.30
</span><span style="color:#080;font-style:italic"></span>..B1.9:                         <span style="color:#080;font-style:italic"># Preds ..B1.1 ..B1.6
</span><span style="color:#080;font-style:italic"></span>        ret                                                     <span style="color:#080;font-style:italic">#15.12
</span><span style="color:#080;font-style:italic"></span>..B1.10:                        <span style="color:#080;font-style:italic"># Preds ..B1.3
</span><span style="color:#080;font-style:italic"></span>        imul      eax, esi                                      <span style="color:#080;font-style:italic">#15.30
</span><span style="color:#080;font-style:italic"></span>        ret                                                     <span style="color:#080;font-style:italic">#15.30
</span><span style="color:#080;font-style:italic"></span>..B1.11:                        <span style="color:#080;font-style:italic"># Preds ..B1.2
</span><span style="color:#080;font-style:italic"></span>        imul      eax, ecx                                      <span style="color:#080;font-style:italic">#15.30
</span><span style="color:#080;font-style:italic"></span>        ret                                                     <span style="color:#080;font-style:italic">#15.30
</span><span style="color:#080;font-style:italic"></span>  
</code></pre></div><p>This is a long one, it looks like the generated code has unrolled part of the underlying loop, but it is a looping version. There are jumps, of varying form, but no <code>call</code>, so no recursion.</p>
<p>(I won&rsquo;t show <code>clang</code>; it generates a rather long list of <code>xmms</code> instructions that I don&rsquo;t fully understand, worse than the loop unrolling above, but there is no <code>call</code> in there either).</p>
<p>It looks like we can have a fair chance of translating tail-recursion into loops. It will depend on the compiler, of course, the standard doesn&rsquo;t ensure it, but it is a reasonable expectation.</p>
<p>That&rsquo;s with recursion, but what about tail-calls to other functions. That&rsquo;s something that is hard to translate to a loop in your own code, but something we should be able to translate into jumps in assembler.</p>
<p>Let&rsquo;s try this code (you can probably recognise the recursion, and it isn&rsquo;t something I want to call, but it is three functions calling each other):</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">int</span> collatz(<span style="color:#000080;font-weight:bold">int</span> n);
<span style="color:#000080;font-weight:bold">int</span> even(<span style="color:#000080;font-weight:bold">int</span> n);
<span style="color:#000080;font-weight:bold">int</span> odd(<span style="color:#000080;font-weight:bold">int</span> n);

<span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">inline</span>
<span style="color:#000080;font-weight:bold">bool</span> is_odd(<span style="color:#000080;font-weight:bold">int</span> n) { <span style="color:#000080;font-weight:bold">return</span> (n &amp; <span style="color:#00f">1</span>);                       }
<span style="color:#000080;font-weight:bold">int</span> even(<span style="color:#000080;font-weight:bold">int</span> n)    { <span style="color:#000080;font-weight:bold">return</span> collaz(n / <span style="color:#00f">2</span>);                 }
<span style="color:#000080;font-weight:bold">int</span> odd(<span style="color:#000080;font-weight:bold">int</span> n)     { <span style="color:#000080;font-weight:bold">return</span> collaz(<span style="color:#00f">3</span>*n + <span style="color:#00f">1</span>);               }
<span style="color:#000080;font-weight:bold">int</span> collatz(<span style="color:#000080;font-weight:bold">int</span> n) { <span style="color:#000080;font-weight:bold">return</span> is_odd(n) ? odd(n) : even(n) ; }
</code></pre></div><p>All the function calls (except to is_odd() that we expect to be inlined) are tail-calls. The Elvis-operator, <code>a ? b : c</code> is just a branch, only one of the branches is executed, so those are tail-calls as well. But they are not directly recursive calls. So we cannot immediately translate the code into a loop, at least not without inlining functions.</p>
<p>Let&rsquo;s check the generated assembler. With <code>gcc 11.2</code> we get:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm">even:
        mov     eax, edi
        shr     eax, <span style="color:#00f">31</span>
        add     edi, eax
        xor     eax, eax
        sar     edi
        jmp     collaz
odd:
        lea     edi, [rdi<span style="color:#a61717;background-color:#e3d2d2">+</span><span style="color:#00f">1</span><span style="color:#a61717;background-color:#e3d2d2">+</span>rdi*<span style="color:#00f">2</span>]
        xor     eax, eax
        jmp     collaz
collatz:
        test    dil, <span style="color:#00f">1</span>
        je      .L5
        lea     edi, [rdi<span style="color:#a61717;background-color:#e3d2d2">+</span><span style="color:#00f">1</span><span style="color:#a61717;background-color:#e3d2d2">+</span>rdi*<span style="color:#00f">2</span>]
        xor     eax, eax
        jmp     collaz
.L5:
        mov     eax, edi
        shr     eax, <span style="color:#00f">31</span>
        add     edi, eax
        xor     eax, eax
        sar     edi
        jmp     collaz
</code></pre></div><p>There is no <code>is_odd</code> function; it&rsquo;s been inlined as expected. In the <code>even</code> and <code>odd</code> functions we have a <code>jmp collaz</code> instead of <code>call collaz</code>, which is what we hoped for. In <code>collaz</code> we don&rsquo;t have jumps to <code>even</code> or <code>odd</code>, which we might have expected, but that is because the functions have been inlined.</p>
<p>This is to be expected when the functions are in the same compilation unit, and they are when I use godbolt.org. If you comment out the <code>even()</code> an <code>odd()</code> functions, though, the compiler cannot inline them, and then I get</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm">collatz:
        test    dil, <span style="color:#00f">1</span>
        je      .L2
        jmp     odd
.L2:
        jmp     even
</code></pre></div><p>with <code>jmp</code> instead of <code>call</code>.</p>
<p>With <code>clang 13.0.00</code> we get:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm">even:                                   <span style="color:#080;font-style:italic"># @even
</span><span style="color:#080;font-style:italic"></span>        mov     eax, edi
        shr     eax, <span style="color:#00f">31</span>
        add     eax, edi
        sar     eax
        mov     edi, eax
        xor     eax, eax
        jmp     collaz                          <span style="color:#080;font-style:italic"># TAILCALL
</span><span style="color:#080;font-style:italic"></span>odd:                                    <span style="color:#080;font-style:italic"># @odd
</span><span style="color:#080;font-style:italic"></span>        lea     edi, [rdi <span style="color:#a61717;background-color:#e3d2d2">+</span> <span style="color:#00f">2</span>*rdi]
        add     edi, <span style="color:#00f">1</span>
        xor     eax, eax
        jmp     collaz                          <span style="color:#080;font-style:italic"># TAILCALL
</span><span style="color:#080;font-style:italic"></span>collatz:                                <span style="color:#080;font-style:italic"># @collatz
</span><span style="color:#080;font-style:italic"></span>        mov     eax, edi
        test    al, <span style="color:#00f">1</span>
        jne     .LBB2_1
        mov     edi, eax
        shr     edi, <span style="color:#00f">31</span>
        add     edi, eax
        sar     edi
        xor     eax, eax
        jmp     collaz                          <span style="color:#080;font-style:italic"># TAILCALL
</span><span style="color:#080;font-style:italic"></span>.LBB2_1:
        lea     edi, [rax <span style="color:#a61717;background-color:#e3d2d2">+</span> <span style="color:#00f">2</span>*rax]
        add     edi, <span style="color:#00f">1</span>
        xor     eax, eax
        jmp     collaz                          <span style="color:#080;font-style:italic"># TAILCALL
</span><span style="color:#080;font-style:italic"></span>        
</code></pre></div><p>The calls in <code>even()</code> and <code>odd()</code> are translated into <code>jmp</code> (and then compiler is friendly to tell us in a comment). Once again, <code>even()</code> and <code>odd()</code> are inlined in <code>collatz</code>, but if I remove <code>even()</code> and <code>odd()</code> from the compilation unit, so the compiler cannot inline them, <code>collatz</code> becomes:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm">collatz:                                <span style="color:#080;font-style:italic"># @collatz
</span><span style="color:#080;font-style:italic"></span>        test    dil, <span style="color:#00f">1</span>
        jne     .LBB0_1
        jmp     even                            <span style="color:#080;font-style:italic"># TAILCALL
</span><span style="color:#080;font-style:italic"></span>.LBB0_1:
        jmp     odd                             <span style="color:#080;font-style:italic"># TAILCALL
</span><span style="color:#080;font-style:italic"></span>        
</code></pre></div><p><code>msvc 19.10</code> generates code for the inlined <code>is_odd()</code> (but still inline the function), and otherwise it is the same pattern:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm">n$ <span style="color:#a61717;background-color:#e3d2d2">=</span> <span style="color:#00f">8</span>
is_odd  PROC                                                <span style="color:#080;font-style:italic">; COMDAT
</span><span style="color:#080;font-style:italic"></span>        and     ecx, <span style="color:#00f">1</span>
        movzx   eax, cl
        ret     <span style="color:#00f">0</span>
is_odd  ENDP

n$ <span style="color:#a61717;background-color:#e3d2d2">=</span> <span style="color:#00f">8</span>
even    PROC                                            <span style="color:#080;font-style:italic">; COMDAT
</span><span style="color:#080;font-style:italic"></span>        mov     eax, ecx
        cdq
        sub     eax, edx
        sar     eax, <span style="color:#00f">1</span>
        mov     ecx, eax
        jmp     collaz
even    ENDP

n$ <span style="color:#a61717;background-color:#e3d2d2">=</span> <span style="color:#00f">8</span>
odd     PROC                                          <span style="color:#080;font-style:italic">; COMDAT
</span><span style="color:#080;font-style:italic"></span>        lea     ecx, DWORD PTR [rcx<span style="color:#a61717;background-color:#e3d2d2">+</span>rcx*<span style="color:#00f">2</span>]
        inc     ecx
        jmp     collaz
odd     ENDP

n$ <span style="color:#a61717;background-color:#e3d2d2">=</span> <span style="color:#00f">8</span>
collatz PROC                                          <span style="color:#080;font-style:italic">; COMDAT
</span><span style="color:#080;font-style:italic"></span>        test    cl, <span style="color:#00f">1</span>
        je      SHORT $LN3@collatz
        lea     ecx, DWORD PTR [rcx<span style="color:#a61717;background-color:#e3d2d2">+</span>rcx*<span style="color:#00f">2</span>]
        inc     ecx
        jmp     collaz
$LN3@collatz:
        mov     eax, ecx
        cdq
        sub     eax, edx
        sar     eax, <span style="color:#00f">1</span>
        mov     ecx, eax
        jmp     collaz
collatz ENDP
</code></pre></div><p>with</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm">n$ <span style="color:#a61717;background-color:#e3d2d2">=</span> <span style="color:#00f">8</span>
collatz PROC                                          <span style="color:#080;font-style:italic">; COMDAT
</span><span style="color:#080;font-style:italic"></span>        test    cl, <span style="color:#00f">1</span>
        jne     odd
$LN3@collatz:
        jmp     even
collatz ENDP
</code></pre></div><p>if we prevent inlining in <code>collatz()</code>.</p>
<p>It looks like we will get tail-call optimisation even if we call other functions.</p>
<p>This is promising.</p>
<h1 id="closures">Closures</h1>
<p>So, we can get tail-call optimisation, but for continuations to work, we need to store state together with functions, we need closures.</p>
<p>When we generate continuations, we are essentially moving the data that would normally go on the stack into closures (that we can have on the heap), but it is not a free ride. We need to store that data, and when we invoke a continuation later, we need to provide it with it.</p>
<p>It isn&rsquo;t that different from transforming a recursion into a loop with an explicit stack (although it is a bit more flexible because closures do not need to be invoked in a stack-like fashion). We need to store data in &ldquo;stack&rdquo; frames, in one form or another, but now we also need to associate the data with a function so we can call the right function with the right data when we need to invoke a continuation.</p>
<p>Since there is no built-in closures in C, we have to implement them ourselves, but that isn&rsquo;t much a problem. We need to associate a function with some data, we can use function pointers for functions, and then combine function and at a in a struct:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">struct</span> closure {
    <span style="color:#080;font-style:italic">/* ret type */</span> (*fn)(<span style="color:#080;font-style:italic">/* args */</span>, <span style="color:#000080;font-weight:bold">struct</span> closure *);
    <span style="color:#080;font-style:italic">/* stuff you need to remember */</span>
};
</code></pre></div><p>If we want to call such a closure, pick the function from it and call it with arguments and the struct.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">    cl-&gt;fn(<span style="color:#080;font-style:italic">/*args*/</span>, cl);
</code></pre></div><p>There are a million variations on this, if you want to separate the data from the function and only provide the encapsulated data and such, but this is simple, and it is good enough for the likes of you and me.</p>
<p>Here&rsquo;s an example where closures are functions from integers to integers. That means the result type should be an integer and the closure should take one integer argument and one closure argument.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">struct</span> closure {
    <span style="color:#000080;font-weight:bold">int</span> (*fn)(<span style="color:#000080;font-weight:bold">int</span>, <span style="color:#000080;font-weight:bold">struct</span> closure *);
    <span style="color:#000080;font-weight:bold">int</span> a;
};
</code></pre></div><p>To implement something like</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000080;font-weight:bold">def</span> add_a(a):
    <span style="color:#000080;font-weight:bold">return</span> <span style="color:#000080;font-weight:bold">lambda</span> b: a + b
</code></pre></div><p>we need a function that returns a closer, binding the variable <code>a</code>, and a function we wrap in the closure that takes <code>b</code> and add it to <code>a</code>.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#080;font-style:italic">/* create a closure that will add a to its argument */</span>
<span style="color:#000080;font-weight:bold">struct</span> closure *add_a(<span style="color:#000080;font-weight:bold">int</span> a);
<span style="color:#080;font-style:italic">/* add b to the a stored in the closure */</span>
<span style="color:#000080;font-weight:bold">int</span> add_b(<span style="color:#000080;font-weight:bold">int</span> b, <span style="color:#000080;font-weight:bold">struct</span> closure *cl);
</code></pre></div><p>Then we should be able to use it as this:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">int</span> main(<span style="color:#000080;font-weight:bold">void</span>)
{
    <span style="color:#080;font-style:italic">// Createt a closure, binding a to 2
</span><span style="color:#080;font-style:italic"></span>    <span style="color:#000080;font-weight:bold">struct</span> closure *cl = add_a(<span style="color:#00f">2</span>);
    <span style="color:#080;font-style:italic">// now call the closure to add 42 to 2
</span><span style="color:#080;font-style:italic"></span>    printf(<span style="color:#00f"></span><span style="color:#00f">&#34;</span><span style="color:#00f">%d</span><span style="color:#00f">\n</span><span style="color:#00f">&#34;</span>, cl-&gt;fn(<span style="color:#00f">42</span>, cl));
    
    free(cl); <span style="color:#080;font-style:italic">// closure was allocated on the heap
</span><span style="color:#080;font-style:italic"></span>    <span style="color:#000080;font-weight:bold">return</span> <span style="color:#00f">0</span>;
}
</code></pre></div><p>Which indeed we can.</p>
<p>The functions <code>add_b</code> and <code>add_a</code> could look like this:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">int</span> add_b(<span style="color:#000080;font-weight:bold">int</span> b, <span style="color:#000080;font-weight:bold">struct</span> closure *cl)
{
    <span style="color:#000080;font-weight:bold">return</span> b + cl-&gt;a;
}

<span style="color:#000080;font-weight:bold">struct</span> closure *add_a(<span style="color:#000080;font-weight:bold">int</span> a)
{
    <span style="color:#000080;font-weight:bold">struct</span> closure *cl = malloc(<span style="color:#000080;font-weight:bold">sizeof</span> *cl);
    *cl = (<span style="color:#000080;font-weight:bold">struct</span> closure){ .fn = add_b, .a = a };
    <span style="color:#000080;font-weight:bold">return</span> cl;
}
</code></pre></div><p>Easy-peasy.</p>
<p>What about continuations, then?</p>
<p>Let&rsquo;s do CPS factorial in C. The Python version was</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000080;font-weight:bold">def</span> fact(n, k = <span style="color:#000080;font-weight:bold">lambda</span> x: x):
    match n:
        case <span style="color:#00f">0</span>:
            <span style="color:#000080;font-weight:bold">return</span> k(<span style="color:#00f">1</span>)
        case _: 
            <span style="color:#000080;font-weight:bold">return</span> fact(n - <span style="color:#00f">1</span>, <span style="color:#000080;font-weight:bold">lambda</span> res: k(n * res))<span style="color:#00f">``</span><span style="color:#a61717;background-color:#e3d2d2">`</span>
</code></pre></div><p>The closures need to know <code>n</code> and the continuation <code>k</code>:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">struct</span> closure {
    <span style="color:#000080;font-weight:bold">int</span> (*fn)(<span style="color:#000080;font-weight:bold">int</span>, <span style="color:#000080;font-weight:bold">struct</span> closure *);
    <span style="color:#000080;font-weight:bold">int</span> n;
    <span style="color:#000080;font-weight:bold">struct</span> closure *k; <span style="color:#080;font-style:italic">// continuation
</span><span style="color:#080;font-style:italic"></span>};

<span style="color:#000080;font-weight:bold">struct</span> closure *new_closure(
    <span style="color:#000080;font-weight:bold">int</span> (*fn)(<span style="color:#000080;font-weight:bold">int</span>, <span style="color:#000080;font-weight:bold">struct</span> closure *),
    <span style="color:#000080;font-weight:bold">int</span> n, <span style="color:#000080;font-weight:bold">struct</span> closure *k)
{
    <span style="color:#000080;font-weight:bold">struct</span> closure *cl = malloc(<span style="color:#000080;font-weight:bold">sizeof</span> *cl);
    *cl = (<span style="color:#000080;font-weight:bold">struct</span> closure){ .fn = fn, .n = n, .k = k };
    <span style="color:#000080;font-weight:bold">return</span> cl;
}
</code></pre></div><p>I added a function for allocating closures. We cannot put them on the stack if we intent to reuse stack frames, so they need to be allocated elsewhere. With <code>malloc()</code> it is going to be a little slow and some things will be annoying, but I will fix that with a costom allocator shortly.</p>
<p>We need a function for the continuation-closure <code>lambda res: k(n * res)</code>, and it looks like this:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">int</span> fact_cont(<span style="color:#000080;font-weight:bold">int</span> res, <span style="color:#000080;font-weight:bold">struct</span> closure *cl)
{
    <span style="color:#000080;font-weight:bold">int</span> n = cl-&gt;n;
    <span style="color:#000080;font-weight:bold">struct</span> closure *k = cl-&gt;k;
    free(cl);

    <span style="color:#080;font-style:italic">// call continuation
</span><span style="color:#080;font-style:italic"></span>    <span style="color:#000080;font-weight:bold">return</span> k-&gt;fn(res * n, k);
}
</code></pre></div><p>The function frees its closure. We need to free the memory somewhere, and this is as good a place as any. It means that closures can only be called once—if you want more than that, you need better memory-management, and that is not the topic of this post.</p>
<p>Then we need the recursive function:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">int</span> fact_rec(<span style="color:#000080;font-weight:bold">int</span> n, <span style="color:#000080;font-weight:bold">struct</span> closure *k)
{
    <span style="color:#000080;font-weight:bold">if</span> (n &lt;= <span style="color:#00f">1</span>) <span style="color:#000080;font-weight:bold">return</span> k-&gt;fn(n, k);
    <span style="color:#000080;font-weight:bold">return</span> fact_rec(n - <span style="color:#00f">1</span>, new_closure(fact_cont, n, k));
}
</code></pre></div><p>When we call this function the first time, we must provide it with a continuation that will return the normal way to C. I&rsquo;ve called it <code>ret</code>:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">int</span> ret(<span style="color:#000080;font-weight:bold">int</span> n, <span style="color:#000080;font-weight:bold">struct</span> closure *cl)
{
    free(cl);
    <span style="color:#000080;font-weight:bold">return</span> n;
}
</code></pre></div><p>Now, we can wrap it all up in a normal C function that hides all the nasty closure/continuation stuff from the caller:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">int</span> fact(<span style="color:#000080;font-weight:bold">int</span> n)
{
    <span style="color:#000080;font-weight:bold">struct</span> closure *done = new_closure(ret, <span style="color:#00f">0</span>, <span style="color:#00f">0</span>);
    <span style="color:#000080;font-weight:bold">return</span> fact_rec(n, done);
}
</code></pre></div><p>Both <code>fact_rec</code> and <code>fact_cont</code> get a closure as their last argument, but they serve different purpose. For <code>fast_rec</code>, the closure is the continuation to call when it is done with its computation (or to pass along down the recursion if that is necessary). For <code>fast_cont</code>, the closure is the data for the function we invoke.</p>
<p>So, one is a continuation and the other is the closure for the continuation that we call. I just didn&rsquo;t bother with giving them different types, since it is exactly the same information we are passing along, and it is more hassle than it is worth to consider them separate things.</p>
<p>Still, there is a difference between continuations and the functions that use them. Some functions we call directly, but provide with a continuation, and other we invoke as closures. They do not do the same thing, one goes down the recursion and the other handles coming back up. And these functions do not need to take the same arguments. They do need to return the same type, the way we the recursive functions return the result of calling a continuation, but they can vary in their arguments.</p>
<p>If you are worried that we won&rsquo;t get tail-call optimisation when we muck about with function pointers, I&rsquo;ll put your worries to rest.</p>
<p>Here&rsquo;s <code>fact_cont</code> generated with <code>gcc</code></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm">fact_cont:
        push    r12
        push    rbp
        mov     ebp, edi
        mov     rdi, rsi
        push    rbx
        mov     ebx, DWORD PTR [rsi<span style="color:#a61717;background-color:#e3d2d2">+</span><span style="color:#00f">8</span>]
        mov     r12, QWORD PTR [rsi<span style="color:#a61717;background-color:#e3d2d2">+</span><span style="color:#00f">16</span>]
        imul    ebx, ebp
        call    free
        mov     rax, QWORD PTR [r12]
        mov     rsi, r12
        mov     edi, ebx
        pop     rbx
        pop     rbp
        pop     r12
        jmp     rax
</code></pre></div><p>There&rsquo;s a call to <code>free()</code>, when we free memory, but the call the the continuation is the <code>jmp rax</code> on the last line. It computes the function to jump to from the closure (so it can mess up the branch prediction), but it is still just a jump.</p>
<p>Here&rsquo;s <code>fact_cont</code> with <code>clang</code>:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm">fact_cont:                              <span style="color:#080;font-style:italic"># @fact_cont
</span><span style="color:#080;font-style:italic"></span>        push    r14
        push    rbx
        push    rax
        mov     ebx, edi
        mov     r14, qword ptr [rsi <span style="color:#a61717;background-color:#e3d2d2">+</span> <span style="color:#00f">16</span>]
        imul    ebx, dword ptr [rsi <span style="color:#a61717;background-color:#e3d2d2">+</span> <span style="color:#00f">8</span>]
        mov     rdi, rsi
        call    free
        mov     rax, qword ptr [r14]
        mov     edi, ebx
        mov     rsi, r14
        add     rsp, <span style="color:#00f">8</span>
        pop     rbx
        pop     r14
        jmp     rax                             <span style="color:#080;font-style:italic"># TAILCALL
</span><span style="color:#080;font-style:italic"></span>	
</code></pre></div><p>Again, you get a tail-call optimisation. Everything is fine.</p>
<h1 id="fibonacci">Fibonacci</h1>
<p>Turning the Fibonacci computation into CPS-style C follows the same pattern.</p>
<p>We need to store a bit more in the closures. It varies from closure to closure what variables we need to remember, but the easiest is to make space for all of them in all closures. It shouldn&rsquo;t be hard to change that, but when I am playing around, I go for the easy solutions.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">struct</span> closure {
    <span style="color:#000080;font-weight:bold">int</span> (*fn)(<span style="color:#000080;font-weight:bold">int</span>, <span style="color:#000080;font-weight:bold">struct</span> closure *cl);
    <span style="color:#000080;font-weight:bold">int</span> n, f1, f2;
    <span style="color:#000080;font-weight:bold">struct</span> closure *k;
};
</code></pre></div><p>I&rsquo;ll also add a macro for calling closures, just to make that easier.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#008080">#</span><span style="color:#008080">define call_closure(cl, n) cl-&gt;fn(n, cl)</span><span style="color:#008080">
</span></code></pre></div><p>For allocating closures I use this:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">struct</span> closure *
new_closure(<span style="color:#000080;font-weight:bold">int</span> (*fn)(<span style="color:#000080;font-weight:bold">int</span>, <span style="color:#000080;font-weight:bold">struct</span> closure *cl),
            <span style="color:#000080;font-weight:bold">struct</span> closure closure)
{
    <span style="color:#000080;font-weight:bold">struct</span> closure *cl = malloc(<span style="color:#000080;font-weight:bold">sizeof</span> *cl);
    *cl = closure;
    cl-&gt;fn = fn;
    <span style="color:#000080;font-weight:bold">return</span> cl;
}
</code></pre></div><p>It might look a bit odd that the function takes a closure <code>struct</code> as input, if that is what we are trying to allocate, but that <code>struct</code> will be stack allocated and it makes it easier to pass parameters to the closure using composite expressions. I can write code such as</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">    <span style="color:#000080;font-weight:bold">return</span> fib0(n - <span style="color:#00f">2</span>, new_closure(fib2,
               (<span style="color:#000080;font-weight:bold">struct</span> closure){
                  .f1 = f1, .k = k
               }));
</code></pre></div><p>that way, and only have to provide the arguments I need to remember.</p>
<p>It&rsquo;s not that it is hard to provide defaults for all other parameters, but when you are messing around with this, you (or at least I) tend to add and remove parameters, and then it is tedious to have to update all the calls to the allocation function. This way, I don&rsquo;t have to do that.</p>
<p>We are going to need these functions:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">int</span> fib0(<span style="color:#000080;font-weight:bold">int</span> n, <span style="color:#000080;font-weight:bold">struct</span> closure *k);
<span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">int</span> fib1(<span style="color:#000080;font-weight:bold">int</span> n, <span style="color:#000080;font-weight:bold">struct</span> closure *cl);
<span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">int</span> fib2(<span style="color:#000080;font-weight:bold">int</span> n, <span style="color:#000080;font-weight:bold">struct</span> closure *cl);
<span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">int</span> ret(<span style="color:#000080;font-weight:bold">int</span> n, <span style="color:#000080;font-weight:bold">struct</span> closure *cl);
</code></pre></div><p>The <code>fib0</code> function, that takes a continuation <code>k</code>, is the one we call directly, while the others, that take closures <code>cl</code> are the continuations.</p>
<p>The <code>ret</code> continuation is the same as before; it is responsible for terminating the chain of continuations.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">int</span> ret(<span style="color:#000080;font-weight:bold">int</span> n, <span style="color:#000080;font-weight:bold">struct</span> closure *cl)
{
    free(cl);
    <span style="color:#000080;font-weight:bold">return</span> n;
}
</code></pre></div><p>The <code>fib1()</code> continuation is the one that looked like this in Python:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">  <span style="color:#000080;font-weight:bold">lambda</span> f1: <span style="color:#000080;font-weight:bold">return</span> fib(n - <span style="color:#00f">2</span>, <span style="color:#a61717;background-color:#e3d2d2">…</span>)
</code></pre></div><p>and the <code>fib2()</code> is the one that does this:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">	<span style="color:#000080;font-weight:bold">lambda</span> f2: k(f1 + f2)
</code></pre></div><p>But first the <code>fib0()</code> function. It will handle the base case, and call its continuation if it sees that, and otherwise it will recurse with <code>fib0(n - 1)</code> using <code>fib1</code> as the continuation.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">int</span> fib0(<span style="color:#000080;font-weight:bold">int</span> n, <span style="color:#000080;font-weight:bold">struct</span> closure *k)
{
    <span style="color:#000080;font-weight:bold">if</span> (n &lt;= <span style="color:#00f">1</span>) {
        <span style="color:#000080;font-weight:bold">return</span> call_closure(k, n);
    } <span style="color:#000080;font-weight:bold">else</span> {
        <span style="color:#000080;font-weight:bold">return</span> fib0(n - <span style="color:#00f">1</span>, new_closure(fib1,
            (<span style="color:#000080;font-weight:bold">struct</span> closure){ .n = n, .k = k }));
    }
}
</code></pre></div><p>Since <code>fib1()</code> needs to know <code>n</code> and the continuation <code>k</code>, that is what we bind in the closure. It will be called with the result of <code>fib0(n - 1, …)</code>, and then it needs to handle the <code>fib0(n - 2, …)</code> case, using <code>fib2()</code> as the continuation.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">int</span> fib1(<span style="color:#000080;font-weight:bold">int</span> f1, <span style="color:#000080;font-weight:bold">struct</span> closure *cl)
{
    <span style="color:#000080;font-weight:bold">struct</span> closure *k = cl-&gt;k;
    <span style="color:#000080;font-weight:bold">int</span> n = cl-&gt;n;
    free(cl);
    
    <span style="color:#000080;font-weight:bold">return</span> fib0(n - <span style="color:#00f">2</span>, new_closure(fib2,
               (<span style="color:#000080;font-weight:bold">struct</span> closure){ .f1 = f1, .k = k }));
}
</code></pre></div><p>We give <code>fib2()</code> the value <code>f1</code> and the continuation <code>k</code>, because that is what it will need. It will be called with the result of <code>fib0(n - 2, …)</code>. Then all it has to do is add its argument to <code>f1</code> and call the continuation.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">int</span> fib2(<span style="color:#000080;font-weight:bold">int</span> f2, <span style="color:#000080;font-weight:bold">struct</span> closure *cl)
{
    <span style="color:#000080;font-weight:bold">struct</span> closure *k = cl-&gt;k;
    <span style="color:#000080;font-weight:bold">int</span> f1 = cl-&gt;f1;
    free(cl);

    <span style="color:#000080;font-weight:bold">return</span> call_closure(k, f1 + f2);
}
</code></pre></div><p>We can wrap all the CPS madness up in a function such as this:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">int</span> fib(<span style="color:#000080;font-weight:bold">int</span> n)
{
    <span style="color:#000080;font-weight:bold">return</span> fib0(n, new_closure(ret, (<span style="color:#000080;font-weight:bold">struct</span> closure){}));
}
</code></pre></div><h1 id="cleaning-up-a-bit">Cleaning up a bit…</h1>
<p>This stuff is working, and the tail-calls mean we don&rsquo;t fill up the stack. Still, there are a couple of things that bother me.</p>
<p>One, the memory management is a problem. If I have to remember to free closures every time I call one, I can guarantee you that I will leak. I&rsquo;m not good at remembering stuff like that, so I would prefer if I can get it more automated. Also, calling <code>malloc()</code> and <code>free()</code> for each closure creation/call is affecting performance. Those functions are a bit slow, and I think we can do better.</p>
<p>Another issue is the boilerplate code I write to handle closures. It is not that bad here, but while playing with different implementations, I kept changing which parameters the functions should take and how they should be called, and it was a drag changing practically the entire code every time I made a change. With a macro or two, I should be able to improve that. (I am not entirely sure if I improved things or made them worse, but I ended up making it different, at least).</p>
<p>First, I implemented an allocation pool. It handles chunks of memory of the same size, which makes it highly efficient, but there isn&rsquo;t anything particularly exciting about it, so I have put it in an appendix below.</p>
<p>The interface is this: you can create and free a pool</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">struct</span> mem_pool *new_mem_pool(size_t obj_size);
<span style="color:#000080;font-weight:bold">void</span> free_mem_pool(<span style="color:#000080;font-weight:bold">struct</span> mem_pool *pool);
</code></pre></div><p>and you can allocate and free chunks</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">void</span> *alloc_mem(<span style="color:#000080;font-weight:bold">struct</span> mem_pool *pool);
<span style="color:#000080;font-weight:bold">void</span> free_mem(<span style="color:#000080;font-weight:bold">struct</span> mem_pool *pool, <span style="color:#000080;font-weight:bold">void</span> *p);
</code></pre></div><p>There is a twist to <code>free_mem()</code>, though, that I exploit to the fullest. It doesn&rsquo;t touch the memory just yet. Until the next allocation, it leaves it alone. That means that I can free a closure when I call it, and the data is still available for the closure until it allocates a new closure. So, the memory is automatically freed, and you just have to be careful to get it before you allocate new closures (and I am nothing if not careful).</p>
<p>For the functions that we either call with continuations or invoke as closures, I made macros for defining them, so I could modify the arguments they get in a single location. They look like this:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#008080">#</span><span style="color:#008080">define closure_func(F, ...)          \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">    F(struct mem_pool *closure_pool_, \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">      struct closure *cl_             \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">      comma_if_not_nil(__VA_ARGS__)   \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">      __VA_ARGS__ )</span><span style="color:#008080">
</span><span style="color:#008080"></span>
<span style="color:#008080">#</span><span style="color:#008080">define cps_func(F, ...)                        \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">    F(struct mem_pool *closure_pool_,           \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">      __VA_ARGS__ comma_if_not_nil(__VA_ARGS__) \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">      struct closure *k_)</span><span style="color:#008080">
</span></code></pre></div><p>Closures will get the allocation pool and the closure as their first two arguments, and then any other arguments. The <code>comma_if_not_nil()</code> is to ensure that we only add a comma between the parameters we set here and the ones the user require if there actually are some user-defined arguments.</p>
<p>This is not as easy as you might think. The C standard doesn&rsquo;t have a way to detect zero or non-zero optional arguments. There are plenty of compiler extensions for it, because it is highly useful, but it isn&rsquo;t in the standard. Handling it here can be done with a bit of <a href="https://mailund.dk/posts/macro-metaprogramming/">macro hacking</a>.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#008080">#</span><span style="color:#008080">define first(a, ...) a</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">#</span><span style="color:#008080">define second(a, b, ...) b</span><span style="color:#008080">
</span><span style="color:#008080"></span>
<span style="color:#008080">#</span><span style="color:#008080">define empty()</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">#</span><span style="color:#008080">define comma() ,</span><span style="color:#008080">
</span><span style="color:#008080"></span>
<span style="color:#008080">#</span><span style="color:#008080">define probe(p) second(p, comma)()</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">#</span><span style="color:#008080">define push_empty() -, empty</span><span style="color:#008080">
</span><span style="color:#008080"></span>
<span style="color:#008080">#</span><span style="color:#008080">define comma_if_not_nil(...) \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">    probe(first(push_empty __VA_ARGS__)())</span><span style="color:#008080">
</span></code></pre></div><p>You might also have noticed that while closures get the closure as their second argument, functions that use continuations, the <code>cps_func()</code> functions, take the continuation as the last argument. There is a reason for that, and I&rsquo;ll get to it, but promise not to groan when we get there.</p>
<p>Then I added a macro for defining closures and an allocation function for them.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#008080">#</span><span style="color:#008080">define args(...) __VA_ARGS__</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">#</span><span style="color:#008080">define define_closure(RET, ARGS, ...)           \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">                                                 \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">    struct closure                               \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">    {                                            \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">        RET closure_func((*fn_), ARGS);          \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">        __VA_ARGS__;                             \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">    };                                           \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">                                                 \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">    static struct closure *                      \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">    alloc_closure(struct mem_pool *pool,         \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">                  RET closure_func((*fn), ARGS), \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">                  struct closure data)           \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">    {                                            \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">        struct closure *cl = alloc_mem(pool);    \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">        *cl = data;                              \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">        cl-&gt;fn_ = fn;                            \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">        return cl;                               \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">    }</span><span style="color:#008080">
</span></code></pre></div><p>The way my macros work, they need the name of the closure struct to be <code>struct closure</code>. I could easily change that, I suppose, but then I would need to add more parameters to the macros, and that would make them a bit ugly. If I ever need to handle different kinds of closures in the same compilation unit, I will come up with another solution.</p>
<p>The <code>alloc_closure()</code> function needs to know the type of the <code>struct closure</code> so I can invoke it with <code>.n = 1, .k = 42, .s = &quot;foo&quot;</code> syntax. I want that for the same reason as I mentioned above; it makes it a little easier to add or remove data from closures.</p>
<p>The memory pool, closure, and continuation have fixed names in the macros, <code>closure_pool_</code> <code>cl_</code>, and <code>k_</code>, respectively. That is also something I will exploit when I work with code. I don&rsquo;t want the user to access the closures directly, though. I might change how they are represented. So, I added a macro for that. Then I can change the layout and the macro, and the user code should still work.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#008080">#</span><span style="color:#008080">define cl(var) cl_-&gt;var</span><span style="color:#008080">
</span></code></pre></div><p>You can define the closure type for the Fibonacci example like this:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">define_closure(
    <span style="color:#000080;font-weight:bold">int</span>, args(<span style="color:#000080;font-weight:bold">int</span>),     <span style="color:#080;font-style:italic">/* int fib(int n) */</span>
    <span style="color:#000080;font-weight:bold">int</span> n;              <span style="color:#080;font-style:italic">/* when I need to remember the initial n. */</span>
    <span style="color:#000080;font-weight:bold">int</span> f1;             <span style="color:#080;font-style:italic">/* the result of fib(n - 1). */</span>
    <span style="color:#000080;font-weight:bold">int</span> f2;             <span style="color:#080;font-style:italic">/* the result of fib(n - 2). */</span>
    <span style="color:#000080;font-weight:bold">struct</span> closure * k; <span style="color:#080;font-style:italic">/* continuation */</span>
);
</code></pre></div><p>To allocate a closure, there is still some boilerplate code. When you call <code>alloc_closure</code> you need the pool (which we can get from <code>closure_pool_</code>) and you need to write <code>(struct closure){ … }</code> for the variables you want to store. We can use another macro to simplify this, or rather two macros, because I won&rsquo;t always use <code>closure_pool_</code> for the pool.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#008080">#</span><span style="color:#008080">define new_closure_from_pool(P, F, ...) \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">    alloc_closure(P, F, (struct closure){__VA_ARGS__})</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">#</span><span style="color:#008080">define new_closure(F, ...) \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">    new_closure_from_pool(closure_pool_, F, __VA_ARGS__)</span><span style="color:#008080">
</span></code></pre></div><p>With this, you can write</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">   new_closure(fib2, .f1 = f1, .k = cl(k))
</code></pre></div><p>to create a new <code>fib2()</code> closure that remembers <code>.f1 = f1</code> and <code>.k = cl(k)</code>, where <code>cl(k)</code> is the continuation <code>k</code> we get from the closure.</p>
<p>It&rsquo;s neat to simplify calls, but I am aware that if something goes wrong, it can go horribly wrong. In the long run, it might be a bad idea. But it is what I have right now.</p>
<p>When we call a closure we want to automatically free the memory (with the twist mentioned above), and we can also use a macro for that:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#008080">#</span><span style="color:#008080">define call_closure(K, ...) \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">    call_closure_with_pool(closure_pool_, K, __VA_ARGS__)</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">#</span><span style="color:#008080">define call_closure_with_pool(P, K, ...) \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">    (free_mem(P, K),                      \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">     (K)-&gt;fn_(P, K comma_if_not_nil(__VA_ARGS__) __VA_ARGS__))</span><span style="color:#008080">
</span></code></pre></div><p>The <code>call_closure_with_pool()</code> is for when we don&rsquo;t use a pool hardwired to the name <code>closure_pool_</code>, but that isn&rsquo;t often.</p>
<p>Now you can call a continuation simply like this</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">    call_closure(k_, n);
</code></pre></div><p>and the memory will automatically be freed in the process.</p>
<p>When you call functions with a continuation, I have this hack:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#008080">#</span><span style="color:#008080">define call(F) call_using_pool(closure_pool_, F)</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">#</span><span style="color:#008080">define call_using_pool(P, F) F(P, call_args_ </span><span style="color:#080;font-style:italic">/* beginning of args */</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">#</span><span style="color:#008080">define call_args_(...) __VA_ARGS__ comma_if_not_nil(__VA_ARGS__)</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">#</span><span style="color:#008080">define with_continuation(K) K)               </span><span style="color:#080;font-style:italic">/* end of args */</span><span style="color:#008080">
</span></code></pre></div><p>This is where you might start screaming. It lets you call a function with a continuation like this:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">    call(fib0)(n - <span style="color:#00f">1</span>) with_continuation(
        new_closure(fib1, .n = n, .k = k_));
</code></pre></div><p>and yes I realise that this is likely to bite me in my ass some day. But it ensures that the CPS are called with continuations, and it makes this explicit. (But to be honest, I just implemented it this way because I could).</p>
<p>This is the reason that the continuation goes last. Otherwise, I couldn&rsquo;t do this hack. (Which, admittedly, I probably shouldn&rsquo;t have done anyway).</p>
<p>Using these macros, the Fibonacci example looks like this:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">int</span> cps_func(fib0, <span style="color:#000080;font-weight:bold">int</span> n);
<span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">int</span> closure_func(fib1, <span style="color:#000080;font-weight:bold">int</span> f1);
<span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">int</span> closure_func(fib2, <span style="color:#000080;font-weight:bold">int</span> f2);
<span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">int</span> closure_func(ret, <span style="color:#000080;font-weight:bold">int</span> result);

<span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">int</span> closure_func(ret, <span style="color:#000080;font-weight:bold">int</span> result)
{
    <span style="color:#000080;font-weight:bold">return</span> result;
}

<span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">int</span> cps_func(fib0, <span style="color:#000080;font-weight:bold">int</span> n)
{
    <span style="color:#000080;font-weight:bold">if</span> (n &lt;= <span style="color:#00f">1</span>)
        <span style="color:#000080;font-weight:bold">return</span> call_closure(k_, n);

    <span style="color:#000080;font-weight:bold">return</span> call(fib0)(n - <span style="color:#00f">1</span>) with_continuation(
        new_closure(fib1, .n = n, .k = k_));
}

<span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">int</span> closure_func(fib1, <span style="color:#000080;font-weight:bold">int</span> f1)
{
    <span style="color:#000080;font-weight:bold">int</span> n = cl(n) - <span style="color:#00f">2</span>; <span style="color:#080;font-style:italic">// get cl(n) before we allocate new closure
</span><span style="color:#080;font-style:italic"></span>    <span style="color:#000080;font-weight:bold">return</span> call(fib0)(n) with_continuation(
        new_closure(fib2, .f1 = f1, .k = cl(k)));
}

<span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">int</span> closure_func(fib2, <span style="color:#000080;font-weight:bold">int</span> f2)
{
    <span style="color:#000080;font-weight:bold">return</span> call_closure(cl(k), cl(f1) + f2);
}

<span style="color:#000080;font-weight:bold">int</span> fib(<span style="color:#000080;font-weight:bold">int</span> n)
{
    <span style="color:#000080;font-weight:bold">struct</span> mem_pool *closure_pool_ = new_mem_pool(<span style="color:#000080;font-weight:bold">sizeof</span>(<span style="color:#000080;font-weight:bold">struct</span> closure));
    <span style="color:#000080;font-weight:bold">int</span> result = call(fib0)(n) with_continuation(new_closure(ret, ));
    free_mem_pool(closure_pool_);
    <span style="color:#000080;font-weight:bold">return</span> result;
}
</code></pre></div><p>The <code>fib()</code> function needs to set up the closure pool and free it after use, so it is not a tail-call, but it is just the setup frame. The rest of the functions are tail calls.</p>
<h1 id="traversing-trees">Traversing trees</h1>
<p>Despite what you might have been lead to believe, I am not particularly interested in computing Fibonacci numbers. But I am interested in traversing trees, without using the call-stack if I can avoid it. And it is because of this, that I started thinking about continuations.</p>
<p>I usually implement a tree traversal with an explicit stack and some <code>enum</code> that keeps track of what I have to do every time I get a stack frame.</p>
<p>But it can get tricky. You have to remember to push frames on the explicit stack in reverse order from how you would recurse, and there is always some book-keeping you didn&rsquo;t consider, and generally it is a mess if you need to do something complicated, like recursive edit-searching on a tree or in a suffix array.</p>
<p>Just implementing a stack is surely simpler than the continuation brouhaha, but it does get complicated at some point. With CPS code, maybe I could handle all the complexity once, like with the macros above, and then have a better solution?</p>
<p>I don&rsquo;t know. I haven&rsquo;t gotten that far. But it is what I intend to try.</p>
<p>Anyway, before I get ahead of myself, let&rsquo;s do a simple tree traversal.</p>
<p>We could implement a tree like this</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">struct</span> tree
{
    <span style="color:#000080;font-weight:bold">int</span> i;
    <span style="color:#000080;font-weight:bold">struct</span> tree *left, *right;
};

<span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">struct</span> tree *
new_tree(<span style="color:#000080;font-weight:bold">int</span> i, <span style="color:#000080;font-weight:bold">struct</span> tree *left, <span style="color:#000080;font-weight:bold">struct</span> tree *right)
{
    <span style="color:#000080;font-weight:bold">struct</span> tree *t = malloc(<span style="color:#000080;font-weight:bold">sizeof</span> *t);
    *t = (<span style="color:#000080;font-weight:bold">struct</span> tree){.i = i, .left = left, .right = right};
    <span style="color:#000080;font-weight:bold">return</span> t;
}
</code></pre></div><p>and traverse it recursively</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">void</span> recursive_traverse(<span style="color:#000080;font-weight:bold">struct</span> tree *t)
{
    <span style="color:#000080;font-weight:bold">if</span> (!t)
        <span style="color:#000080;font-weight:bold">return</span>;

    recursive_traverse(t-&gt;left);
    printf(<span style="color:#00f"></span><span style="color:#00f">&#34;</span><span style="color:#00f">&lt;%d&gt; </span><span style="color:#00f">&#34;</span>, t-&gt;i);
    recursive_traverse(t-&gt;right);
}
</code></pre></div><p>and that way output the values in all the nodes</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">int</span> main(<span style="color:#000080;font-weight:bold">int</span> argc, <span style="color:#000080;font-weight:bold">const</span> <span style="color:#000080;font-weight:bold">char</span> *argv[])
{
    <span style="color:#000080;font-weight:bold">struct</span> tree *t = new_tree(<span style="color:#00f">3</span>,
                              new_tree(<span style="color:#00f">2</span>,
                                       new_tree(<span style="color:#00f">1</span>, <span style="color:#00f">0</span>, <span style="color:#00f">0</span>),
                                       <span style="color:#00f">0</span>),
                              new_tree(<span style="color:#00f">5</span>,
                                       new_tree(<span style="color:#00f">4</span>, <span style="color:#00f">0</span>, <span style="color:#00f">0</span>),
                                       new_tree(<span style="color:#00f">7</span>, <span style="color:#00f">0</span>, <span style="color:#00f">0</span>)));
    recursive_traverse(t);
    putchar(<span style="color:#00f"></span><span style="color:#800080">&#39;</span><span style="color:#800080">\n</span><span style="color:#800080">&#39;</span>);

    <span style="color:#000080;font-weight:bold">return</span> <span style="color:#00f">0</span>;
}
</code></pre></div><p>If you feel up to it, you can implement a recursive function that applies a closure to each tree node. That&rsquo;s pretty simple to do. But I want to move on the more interesting things.</p>
<p>You can implement the same thing using an explicit stack. Here&rsquo;s a simple solution to that idea:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">enum</span> state { VISIT, REPORT };
<span style="color:#000080;font-weight:bold">struct</span> stack {
    <span style="color:#000080;font-weight:bold">enum</span> state state;
    <span style="color:#000080;font-weight:bold">struct</span> tree *t;
    <span style="color:#000080;font-weight:bold">struct</span> stack *next;
};

<span style="color:#000080;font-weight:bold">void</span> push(<span style="color:#000080;font-weight:bold">struct</span> stack **stack,
           <span style="color:#000080;font-weight:bold">enum</span> state state,
           <span style="color:#000080;font-weight:bold">struct</span> tree *t)
{
    <span style="color:#000080;font-weight:bold">struct</span> stack *s = malloc(<span style="color:#000080;font-weight:bold">sizeof</span> *s);
    *s = (<span style="color:#000080;font-weight:bold">struct</span> stack){ .state = state, .t = t, .next = *stack };
    *stack = s;
}

<span style="color:#000080;font-weight:bold">struct</span> stack *pop(<span style="color:#000080;font-weight:bold">struct</span> stack **stack)
{
    <span style="color:#000080;font-weight:bold">struct</span> stack *s = *stack;
    *stack = s-&gt;next;
    <span style="color:#000080;font-weight:bold">return</span> s;
}

<span style="color:#000080;font-weight:bold">void</span> stack_traverse(<span style="color:#000080;font-weight:bold">struct</span> tree *t)
{
    <span style="color:#000080;font-weight:bold">struct</span> stack *stack = <span style="color:#00f">0</span>;
    push(&amp;stack, VISIT, t);
    <span style="color:#000080;font-weight:bold">while</span> (stack) {
        <span style="color:#000080;font-weight:bold">struct</span> stack *next = pop(&amp;stack);
        <span style="color:#000080;font-weight:bold">switch</span> (next-&gt;state) {
            <span style="color:#000080;font-weight:bold">case</span> VISIT:
                <span style="color:#000080;font-weight:bold">if</span> (!next-&gt;t) <span style="color:#000080;font-weight:bold">break</span>; <span style="color:#080;font-style:italic">// done
</span><span style="color:#080;font-style:italic"></span>                
                <span style="color:#080;font-style:italic">// after we go left we should report.
</span><span style="color:#080;font-style:italic"></span>                push(&amp;stack, REPORT, next-&gt;t);
                push(&amp;stack, VISIT, next-&gt;t-&gt;left);
                <span style="color:#000080;font-weight:bold">break</span>;
                
            <span style="color:#000080;font-weight:bold">case</span> REPORT:
                printf(<span style="color:#00f"></span><span style="color:#00f">&#34;</span><span style="color:#00f">&lt;%d&gt; </span><span style="color:#00f">&#34;</span>, next-&gt;t-&gt;i);

                <span style="color:#080;font-style:italic">// after reporting, we go right
</span><span style="color:#080;font-style:italic"></span>                push(&amp;stack, VISIT, next-&gt;t-&gt;right);
                <span style="color:#000080;font-weight:bold">break</span>;
        }
        free(next);
    }
}
</code></pre></div><p>(I&rsquo;m using <code>malloc()</code> and <code>free()</code> to implement a linked-list stack, but that is pure laziness. It is easy enough to get a faster solution.)</p>
<p>You will notice that it is not quite as simple as the recursion, and keep that in mind if you feel like complaining about the CPS solution later. When the language doesn&rsquo;t support what you want to do, you end up with a messier solution than if you go with what you have readily available.</p>
<p>You can implement the recursion with an explicit stack, of course you can, but there is some work to it. And I am not sure that the simple stack is easier than CPS. Especially when things get more complicated.</p>
<p>Let&rsquo;s do a CPS version. Our CPS functions will be called with a tree and a continuation, but the continuations won&rsquo;t take arguments. They will have everything they need in their closure, and &ldquo;everthing they need&rdquo; will be a tree and a continuation.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">define_closure(
    <span style="color:#000080;font-weight:bold">void</span>, args(),        <span style="color:#080;font-style:italic">/* void traverse() (no arg for closures) */</span>
    <span style="color:#000080;font-weight:bold">struct</span> tree *t;      <span style="color:#080;font-style:italic">/* tree we are currently handling */</span>
    <span style="color:#000080;font-weight:bold">struct</span> closure * k;  <span style="color:#080;font-style:italic">/* continuation */</span>
);
</code></pre></div><p>We will have a <code>visit()</code> CPS function and two closures, <code>report</code> for printing the node integer, and the usual <code>ret</code> to terminate the string of continuations.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">void</span> cps_func(visit, <span style="color:#000080;font-weight:bold">struct</span> tree *t);
<span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">void</span> closure_func(ret);
<span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">void</span> closure_func(report);
</code></pre></div><p>The <code>ret</code> continuation is as simple as they come:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">void</span> closure_func(ret)
{
    ; <span style="color:#080;font-style:italic">// done
</span><span style="color:#080;font-style:italic"></span>}
</code></pre></div><p>The <code>visit(t,k)</code> function will call the continuation if <code>t</code> is empty, and otherwise it will recurse on the left tree, creating a closure for reporting the node once this recursion is done.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">void</span> cps_func(visit, <span style="color:#000080;font-weight:bold">struct</span> tree *t)
{
    <span style="color:#000080;font-weight:bold">if</span> (!t)
        <span style="color:#000080;font-weight:bold">return</span> call_closure(k_);
    <span style="color:#000080;font-weight:bold">else</span>
        <span style="color:#000080;font-weight:bold">return</span> call(visit)(t-&gt;left) with_continuation(
            new_closure(report, .t = t, .k = k_));
}
</code></pre></div><p>Finally, the report continuation will print the value in the tree it remembers in its closure and then recurse to the right, giving the recursion the continuation it has in its closure.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">void</span> closure_func(report)
{
    printf(<span style="color:#00f"></span><span style="color:#00f">&#34;</span><span style="color:#00f">&lt;%d&gt; </span><span style="color:#00f">&#34;</span>, cl(t)-&gt;i);
    <span style="color:#000080;font-weight:bold">struct</span> tree *t = cl(t);
    call(visit)(t-&gt;right) with_continuation(cl(k));
}
</code></pre></div><p>As always, we need a function for setting up and tearing down all the closure stuff.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">void</span> cps_traverse(<span style="color:#000080;font-weight:bold">struct</span> tree *t)
{
    <span style="color:#000080;font-weight:bold">struct</span> mem_pool *closure_pool_ = new_mem_pool(<span style="color:#000080;font-weight:bold">sizeof</span>(<span style="color:#000080;font-weight:bold">struct</span> closure));
    call(visit)(t) with_continuation(new_closure(ret, ));
    free_mem_pool(closure_pool_);
}
</code></pre></div><p>This is the full CPS implementation:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">define_closure(
    <span style="color:#000080;font-weight:bold">void</span>, args(),        <span style="color:#080;font-style:italic">/* void traverse() (no arg for closures) */</span>
    <span style="color:#000080;font-weight:bold">struct</span> tree *t;      <span style="color:#080;font-style:italic">/* tree we are currently handling */</span>
    <span style="color:#000080;font-weight:bold">struct</span> closure * k;  <span style="color:#080;font-style:italic">/* continuation */</span>
);

<span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">void</span> closure_func(ret) { <span style="color:#080;font-style:italic">/* nothing */</span> }
<span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">void</span> closure_func(report);

<span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">void</span> cps_func(visit, <span style="color:#000080;font-weight:bold">struct</span> tree *t)
{
    <span style="color:#000080;font-weight:bold">if</span> (!t)
        <span style="color:#000080;font-weight:bold">return</span> call_closure(k_);
    <span style="color:#000080;font-weight:bold">else</span>
        <span style="color:#000080;font-weight:bold">return</span> call(visit)(t-&gt;left) with_continuation(
            new_closure(report, .t = t, .k = k_));
}

<span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">void</span> closure_func(report)
{
    printf(<span style="color:#00f"></span><span style="color:#00f">&#34;</span><span style="color:#00f">&lt;%d&gt; </span><span style="color:#00f">&#34;</span>, cl(t)-&gt;i);
    <span style="color:#000080;font-weight:bold">struct</span> tree *t = cl(t);
    call(visit)(t-&gt;right) with_continuation(cl(k));
}

<span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">void</span> cps_traverse(<span style="color:#000080;font-weight:bold">struct</span> tree *t)
{
    <span style="color:#000080;font-weight:bold">struct</span> mem_pool *closure_pool_ = new_mem_pool(<span style="color:#000080;font-weight:bold">sizeof</span>(<span style="color:#000080;font-weight:bold">struct</span> closure));
    call(visit)(t) with_continuation(new_closure(ret, ));
    free_mem_pool(closure_pool_);
}
</code></pre></div><p>It is 32 lines, including prototypes.</p>
<p>In comparison, the full stack implementation is 47 lines:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">enum</span> state { VISIT, REPORT };
<span style="color:#000080;font-weight:bold">struct</span> stack {
    <span style="color:#000080;font-weight:bold">enum</span> state state;
    <span style="color:#000080;font-weight:bold">struct</span> tree *t;
    <span style="color:#000080;font-weight:bold">struct</span> stack *next;
};

<span style="color:#000080;font-weight:bold">void</span> push(<span style="color:#000080;font-weight:bold">struct</span> stack **stack,
           <span style="color:#000080;font-weight:bold">enum</span> state state,
           <span style="color:#000080;font-weight:bold">struct</span> tree *t)
{
    <span style="color:#000080;font-weight:bold">struct</span> stack *s = malloc(<span style="color:#000080;font-weight:bold">sizeof</span> *s);
    *s = (<span style="color:#000080;font-weight:bold">struct</span> stack){ .state = state, .t = t, .next = *stack };
    *stack = s;
}

<span style="color:#000080;font-weight:bold">struct</span> stack *pop(<span style="color:#000080;font-weight:bold">struct</span> stack **stack)
{
    <span style="color:#000080;font-weight:bold">struct</span> stack *s = *stack;
    *stack = s-&gt;next;
    <span style="color:#000080;font-weight:bold">return</span> s;
}

<span style="color:#000080;font-weight:bold">void</span> stack_traverse(<span style="color:#000080;font-weight:bold">struct</span> tree *t)
{
    <span style="color:#000080;font-weight:bold">struct</span> stack *stack = <span style="color:#00f">0</span>;
    push(&amp;stack, VISIT, t);
    <span style="color:#000080;font-weight:bold">while</span> (stack) {
        <span style="color:#000080;font-weight:bold">struct</span> stack *next = pop(&amp;stack);
        <span style="color:#000080;font-weight:bold">switch</span> (next-&gt;state) {
            <span style="color:#000080;font-weight:bold">case</span> VISIT:
                <span style="color:#000080;font-weight:bold">if</span> (!next-&gt;t) <span style="color:#000080;font-weight:bold">break</span>; <span style="color:#080;font-style:italic">// done
</span><span style="color:#080;font-style:italic"></span>                
                <span style="color:#080;font-style:italic">// after we go left we should report.
</span><span style="color:#080;font-style:italic"></span>                push(&amp;stack, REPORT, next-&gt;t);
                push(&amp;stack, VISIT, next-&gt;t-&gt;left);
                <span style="color:#000080;font-weight:bold">break</span>;
                
            <span style="color:#000080;font-weight:bold">case</span> REPORT:
                printf(<span style="color:#00f"></span><span style="color:#00f">&#34;</span><span style="color:#00f">&lt;%d&gt; </span><span style="color:#00f">&#34;</span>, next-&gt;t-&gt;i);
                <span style="color:#080;font-style:italic">// after reporting, we go right
</span><span style="color:#080;font-style:italic"></span>                push(&amp;stack, VISIT, next-&gt;t-&gt;right);
                <span style="color:#000080;font-weight:bold">break</span>;
        }
        free(next);
    }
}
</code></pre></div><p>(If you find it unfair that I count the stack implementation here, but not the closure implementation for the CPS code, you could have a point. But the stack needs to contain these types, and there is no generic stacks in C. Still, it could be shortened a bit with a code-generating macro for the stack, and that might bring the line counts closer together. Still, the <code>stack_traverse()</code> function alone is 27 lines, so the stack solution will never be much smaller).</p>
<p>So, assuming we have the macros and allocators and all that jive, the CPS solution is not longer than the stack implementation. There shouldn&rsquo;t be much of a difference in performance either (I haven&rsquo;t tested because I haven&rsquo;t spent time properly optimising either solution).</p>
<p>Which solution is conceptually more difficult to work with is somewhat subjective, of course. Neither have the simple control flow of the direct recursion. But I will make the point that we shouldn&rsquo;t discard CPS solutions off-hand, for applications such as this.</p>
<h1 id="iterators">Iterators</h1>
<p>There is another reason, beyond using less stack space, that I am interested in CPS or using an explicit stack. Sometimes, I want to suspend a traversal to report something, and then be able to resume it again.</p>
<p>When you traverse a data structure, searching for something perhaps, you want to report what you find. There are multiple options. Have a data structure you can write the results to, perhaps, but that ties the data structure tightly to the usages. Or use a call-back function (or even one of my closures) to call when you need to report something.</p>
<p>There is nothing <em>a priori</em> bad with that, but I often find it hard to follow the control flow if I use call-backs. Not a simple call-back for a tree traversal, I can wrap my head around that, but it never stays that simple.</p>
<p>Say I want to map reads to a genome, so I have a function that will read a FASTQ file and invoke a call-back for each read. For each read, I then search in some index structure to find all approximate occurrences of the read. That&rsquo;s another call-back. So I need to provide a callback to the FASTQ parser, and that callback should provide another callback to the search algorithm, and you bet there will be more callbacks before I am done with this application.</p>
<p>Closures, if the language supports them, can help a lot here. But if you don&rsquo;t have closures where you can call a function with an anonymous function that can see the current scope, it is a <em>nightmare</em> to get such a callback based design to run smoothly.</p>
<p>No, I generally don&rsquo;t like this approach, and in languages like C, it is a no-go for iterating over data structures, search hits, or whatever.</p>
<p>In C, I want iterators. C doesn&rsquo;t provide that, so I want data that implements the iterator pattern instead.</p>
<p>Leaving continuations and closures for a second, here is an example of what I mean. I have a number of string search algorithms. They all search for a pattern <code>p</code> in a string <code>x</code>. They vary in complexity, but I have wrapped it all in an iterator structure, <code>cstr_exact_matcher</code> with a uniform interface. If I want to search using the algorithm <code>search(x, p)</code>, I can write:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">cstr_exact_matcher *matcher = search(x, p);
<span style="color:#000080;font-weight:bold">for</span> (<span style="color:#000080;font-weight:bold">int</span> m = cstr_exact_next_match(matcher);
     m != -<span style="color:#00f">1</span>;
     m = cstr_exact_next_match(matcher)) {
    cstr_sslice match = CSTR_SUBSLICE(x, m, m + p.len);
    <span style="color:#080;font-style:italic">// do stuff with the match at index m
</span><span style="color:#080;font-style:italic"></span>}
cstr_free_exact_matcher(matcher);
</code></pre></div><p>The <code>search(x, p)</code> call will create an iterator for me. When I call <code>cstr_exact_next_match(matcher)</code> I get the next match, or -1 if there are no more matches. And once I am done, I free the matcher with <code>cstr_free_exact_matcher(matcher)</code>.</p>
<p>Since both <code>next()</code> and <code>free()</code> operation is polymorphic, I implement it using function pointers.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">typedef</span> int (*exact_next_fn)(cstr_exact_matcher *);
<span style="color:#000080;font-weight:bold">typedef</span> void (*exact_free_fn)(cstr_exact_matcher *);

<span style="color:#000080;font-weight:bold">struct</span> cstr_exact_matcher
{
    exact_next_fn next;
    exact_free_fn free;
    cstr_sslice x, p;
};
</code></pre></div><p>Concrete implementations will have this struct at the top of their data, so the polymorphic functions can get at it.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">int</span> cstr_exact_next_match(cstr_exact_matcher *matcher)
{
    <span style="color:#000080;font-weight:bold">return</span> matcher-&gt;next(matcher);
}

<span style="color:#000080;font-weight:bold">void</span> cstr_free_exact_matcher(cstr_exact_matcher *matcher)
{
    matcher-&gt;free(matcher);
}
</code></pre></div><p>I have a macro for initialising the generic part</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#008080">#</span><span style="color:#008080">define MATCHER(NEXT, FREE, X, P)          \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">    .matcher = (struct cstr_exact_matcher) \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">    {                                      \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">        .next = (exact_next_fn)(NEXT),     \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">        .free = (exact_free_fn)(FREE),     \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">        .x = (X),                          \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">        .p = (P)                           \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">    }</span><span style="color:#008080">
</span></code></pre></div><p>although that might be over-kill. The only useful thing it does is casting the function pointers to the polymorphic type.</p>
<p>Anyway, I can use it to initialise different search algorithms. Here&rsquo;s a naive O(nm) time algorithm:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#080;font-style:italic">// macros for readability
</span><span style="color:#080;font-style:italic"></span><span style="color:#008080">#</span><span style="color:#008080">define x(S) ((S)-&gt;matcher.x.buf)</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">#</span><span style="color:#008080">define p(S) ((S)-&gt;matcher.p.buf)</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">#</span><span style="color:#008080">define n(S) ((int)(S)-&gt;matcher.x.len)</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">#</span><span style="color:#008080">define m(S) ((int)(S)-&gt;matcher.p.len)</span><span style="color:#008080">
</span><span style="color:#008080"></span>
<span style="color:#080;font-style:italic">// Naive O(nm) algorithm
</span><span style="color:#080;font-style:italic"></span><span style="color:#000080;font-weight:bold">struct</span> naive_matcher_state
{
    cstr_exact_matcher matcher;
    <span style="color:#000080;font-weight:bold">int</span> i;
};

<span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">int</span> naive_next(<span style="color:#000080;font-weight:bold">struct</span> naive_matcher_state *s)
{
    <span style="color:#000080;font-weight:bold">for</span> (; s-&gt;i &lt; n(s); s-&gt;i++)
    {
        <span style="color:#000080;font-weight:bold">for</span> (<span style="color:#000080;font-weight:bold">int</span> j = <span style="color:#00f">0</span>; j &lt; m(s); j++)
        {
            <span style="color:#000080;font-weight:bold">if</span> (x(s)[s-&gt;i + j] != p(s)[j])
                <span style="color:#000080;font-weight:bold">break</span>;
            <span style="color:#000080;font-weight:bold">if</span> (j == m(s) - <span style="color:#00f">1</span>)
            {
                <span style="color:#080;font-style:italic">// a match
</span><span style="color:#080;font-style:italic"></span>                s-&gt;i++; <span style="color:#080;font-style:italic">// next time, start from here
</span><span style="color:#080;font-style:italic"></span>                <span style="color:#000080;font-weight:bold">return</span> s-&gt;i - <span style="color:#00f">1</span>;
            }
        }
    }
    <span style="color:#000080;font-weight:bold">return</span> -<span style="color:#00f">1</span>; <span style="color:#080;font-style:italic">// If we get here, we are done.
</span><span style="color:#080;font-style:italic"></span>}

cstr_exact_matcher *
cstr_naive_matcher(cstr_sslice x, cstr_sslice p)
{
    <span style="color:#000080;font-weight:bold">struct</span> naive_matcher_state *state = cstr_malloc(<span style="color:#000080;font-weight:bold">sizeof</span> *state);
    *state = (<span style="color:#000080;font-weight:bold">struct</span> naive_matcher_state){
        MATCHER(naive_next, free, x, p),
        .i = <span style="color:#00f">0</span>};
    <span style="color:#000080;font-weight:bold">return</span> (<span style="color:#000080;font-weight:bold">struct</span> cstr_exact_matcher *)state;
}
</code></pre></div><p>and here&rsquo;s Knuth-Morris-Pratt:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">struct</span> kmp_matcher_state
{
    <span style="color:#000080;font-weight:bold">struct</span> cstr_exact_matcher matcher;
    <span style="color:#000080;font-weight:bold">int</span> i, j;
    <span style="color:#000080;font-weight:bold">int</span> ba[];
};

<span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">int</span> kmp_next(<span style="color:#000080;font-weight:bold">struct</span> kmp_matcher_state *s)
{
    <span style="color:#000080;font-weight:bold">int</span> i = s-&gt;i;
    <span style="color:#000080;font-weight:bold">int</span> j = s-&gt;j;

    <span style="color:#000080;font-weight:bold">for</span> (; i &lt; n(s); ++i)
    {
        <span style="color:#080;font-style:italic">// move pattern down...
</span><span style="color:#080;font-style:italic"></span>        <span style="color:#000080;font-weight:bold">while</span> (j &gt; <span style="color:#00f">0</span> &amp;&amp; x(s)[i] != p(s)[j])
            j = s-&gt;ba[j - <span style="color:#00f">1</span>];

        <span style="color:#080;font-style:italic">// match...
</span><span style="color:#080;font-style:italic"></span>        <span style="color:#000080;font-weight:bold">if</span> (x(s)[i] == p(s)[j])
        {
            j++;
            <span style="color:#000080;font-weight:bold">if</span> (j == m(s))
            {
                <span style="color:#080;font-style:italic">// we have a match!
</span><span style="color:#080;font-style:italic"></span>                s-&gt;j = s-&gt;ba[j - <span style="color:#00f">1</span>];
                s-&gt;i = i + <span style="color:#00f">1</span>;
                <span style="color:#000080;font-weight:bold">return</span> i - m(s) + <span style="color:#00f">1</span>;
            }
        }
    }

    <span style="color:#000080;font-weight:bold">return</span> -<span style="color:#00f">1</span>;
}

cstr_exact_matcher *
cstr_kmp_matcher(cstr_sslice x, cstr_sslice p)
{
    <span style="color:#000080;font-weight:bold">struct</span> kmp_matcher_state *state =
        CSTR_MALLOC_FLEX_ARRAY(state, ba, (size_t)p.len);
    *state = (<span style="color:#000080;font-weight:bold">struct</span> kmp_matcher_state){
        MATCHER(kmp_next, free, x, p),
        .i = <span style="color:#00f">0</span>, .j = <span style="color:#00f">0</span>};
    compute_border_array(p, state-&gt;ba);
    <span style="color:#000080;font-weight:bold">return</span> (<span style="color:#000080;font-weight:bold">struct</span> cstr_exact_matcher *)state;
}
</code></pre></div><p>The important bit is not so much that I can get polymorphism, it is that I get an iterator over hits. I don&rsquo;t need to provide a data structure where the search algorithms put the results. I might not want all of them, or I don&rsquo;t want to allocate a structure if I have to move the data elsewhere afterwards. I just want to iterate over all the hits.</p>
<p>Iterators are a wonderful pattern, and for something as simple as searching for hits in a string, they are fairly simple to implement. You need to store a little bit of state in them, and whenever you are asked for the next element, you start from that search and move forward.</p>
<p>But it can get tricky if you want to traverse a recursive data structure (which, I suppose, is why we use the visitor pattern so much instead).</p>
<p>The state, when you suspend and resume a recursive traversal, includes the stack. If you cannot save the call stack, then you must use an explicit stack (or CPS, as we shall see).</p>
<p>Conceptually, there is no difference between saving a stack-state or any other type of state, but you do need to store it. Which means you have to do the traversal with an explicit stack. Direct recursion, even if you do not have stack overflow issues, is out the window.</p>
<p>I have implemented my share of explicit-stack-iterators, and it has never been fun. I hope that CPS can make it easier for me to implement suspend/resume iterators. And I think it does.</p>
<p>Here&rsquo;s a simple idea: make the functions return closures. When there is something to report, a <code>suspend()</code> closure will return control-flow to the caller. It will return a closure, from which we can get the value we wish the iterator to report, and which, if we call it, will resume the computation.</p>
<p>For traversing trees, closures could be defined like this:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">define_closure(
    <span style="color:#000080;font-weight:bold">struct</span> closure *, args(),  <span style="color:#080;font-style:italic">/* closure *traverse() */</span>
    <span style="color:#000080;font-weight:bold">struct</span> tree *t;            <span style="color:#080;font-style:italic">/* tree we are currently handling */</span>
    <span style="color:#000080;font-weight:bold">struct</span> closure * k;        <span style="color:#080;font-style:italic">/* continuation */</span>
);
</code></pre></div><p>It is the same as for the traversal, except that closures return closures now.</p>
<p>These are the functions and closures we need:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">struct</span> closure *cps_func(visit, <span style="color:#000080;font-weight:bold">struct</span> tree *t);
<span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">struct</span> closure *closure_func(suspend);
<span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">struct</span> closure *closure_func(resume);
<span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">struct</span> closure *closure_func(ret)
{
    <span style="color:#000080;font-weight:bold">return</span> <span style="color:#00f">0</span>; <span style="color:#080;font-style:italic">// no further processing
</span><span style="color:#080;font-style:italic"></span>}
</code></pre></div><p>The <code>ret</code> continuation will return 0, indicating that there are no more closures to call. We will use that to recognise that the iteration is done.</p>
<p>The <code>visit()</code> function works as before, except that when it calls recursively it will pass along a continuation that will suspend.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">struct</span> closure *cps_func(visit, <span style="color:#000080;font-weight:bold">struct</span> tree *t)
{
    <span style="color:#000080;font-weight:bold">if</span> (!t)
        <span style="color:#000080;font-weight:bold">return</span> call_closure(k_);
    <span style="color:#000080;font-weight:bold">else</span>
        <span style="color:#000080;font-weight:bold">return</span> call(visit)(t-&gt;left) with_continuation(
            new_closure(suspend, .t = t, .k = k_));
}
</code></pre></div><p>That means that when we return to a node from recursion to the left, <code>suspend()</code> is called. It will return a <code>resume()</code> closure.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">struct</span> closure *closure_func(suspend)
{
    <span style="color:#000080;font-weight:bold">return</span> new_closure(resume, .t = cl(t), .k = cl(k));
}
</code></pre></div><p>The closure will hold the current tree, so we can get hold of it to report the node, and it will hold the closure <code>suspend</code> got <code>visit</code>—the one we need to call to return from the full recursion of the current tree.</p>
<p>When we resume, we have (probably) just reported the value in a node, so we need to recurse to the right, and the continuation we need to pass along is the one that will return to the function that called the recursion on the current tree. The <code>suspend</code> function stored that one in the closure.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">struct</span> closure *closure_func(resume)
{
    <span style="color:#000080;font-weight:bold">struct</span> tree *right = cl(t)-&gt;right;
    <span style="color:#000080;font-weight:bold">return</span> call(visit)(right) with_continuation(cl(k));
}
</code></pre></div><p>So, a call to <code>visit(t)</code> will, when we return from the recursion on the left, call <code>suspend()</code> so we can report the current node, and when we call the <code>resume()</code> closure we will recurse on the right and then return further up the recursion.</p>
<p>We can wrap all this up in an iterator. The iterator will hold the closure allocation pool and the closure to call to get the next value. That closure will also hold the current node.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">struct</span> tree_itr
{
    <span style="color:#000080;font-weight:bold">struct</span> mem_pool *pool;
    <span style="color:#000080;font-weight:bold">struct</span> closure *next;
};

<span style="color:#000080;font-weight:bold">struct</span> tree_itr *tree_iterator(<span style="color:#000080;font-weight:bold">struct</span> tree *t);
<span style="color:#000080;font-weight:bold">bool</span> has_more(<span style="color:#000080;font-weight:bold">struct</span> tree_itr *itr);
<span style="color:#000080;font-weight:bold">int</span> current_value(<span style="color:#000080;font-weight:bold">struct</span> tree_itr *itr);
<span style="color:#000080;font-weight:bold">void</span> next_value(<span style="color:#000080;font-weight:bold">struct</span> tree_itr *itr);
<span style="color:#000080;font-weight:bold">void</span> free_iterator(<span style="color:#000080;font-weight:bold">struct</span> tree_itr *itr);

<span style="color:#000080;font-weight:bold">struct</span> tree_itr *tree_iterator(<span style="color:#000080;font-weight:bold">struct</span> tree *t)
{
    <span style="color:#000080;font-weight:bold">struct</span> tree_itr *itr = malloc(<span style="color:#000080;font-weight:bold">sizeof</span> *itr);
    itr-&gt;pool = new_mem_pool(<span style="color:#000080;font-weight:bold">sizeof</span>(<span style="color:#000080;font-weight:bold">struct</span> closure));
    <span style="color:#080;font-style:italic">// Run the first bit of the traversal.
</span><span style="color:#080;font-style:italic"></span>    <span style="color:#080;font-style:italic">// This will run down to the left-most tree, collecting
</span><span style="color:#080;font-style:italic"></span>    <span style="color:#080;font-style:italic">// closures along the way.
</span><span style="color:#080;font-style:italic"></span>    itr-&gt;next = call_using_pool(itr-&gt;pool, visit)(t)
        with_continuation(new_closure_from_pool(itr-&gt;pool, ret, ));

    <span style="color:#000080;font-weight:bold">return</span> itr;
}

<span style="color:#000080;font-weight:bold">bool</span> has_more(<span style="color:#000080;font-weight:bold">struct</span> tree_itr *itr)
{
    <span style="color:#000080;font-weight:bold">return</span> !!itr-&gt;next;
}

<span style="color:#000080;font-weight:bold">int</span> current_value(<span style="color:#000080;font-weight:bold">struct</span> tree_itr *itr)
{
    <span style="color:#080;font-style:italic">// okay, admittedly, this is a bit ugly.
</span><span style="color:#080;font-style:italic"></span>    <span style="color:#000080;font-weight:bold">return</span> itr-&gt;next-&gt;t-&gt;i;
}

<span style="color:#000080;font-weight:bold">void</span> next_value(<span style="color:#000080;font-weight:bold">struct</span> tree_itr *itr)
{
    assert(itr-&gt;next);
    itr-&gt;next = call_closure_with_pool(itr-&gt;pool, itr-&gt;next);
}

<span style="color:#000080;font-weight:bold">void</span> free_iterator(<span style="color:#000080;font-weight:bold">struct</span> tree_itr *itr)
{
    free_mem_pool(itr-&gt;pool);
    free(itr);
}
</code></pre></div><p>With this machinery, you can iterate through all the nodes in the tree:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">struct</span> tree_itr *itr = tree_iterator(t);
<span style="color:#000080;font-weight:bold">for</span> (; has_more(itr); next_value(itr))
{
    printf(<span style="color:#00f"></span><span style="color:#00f">&#34;</span><span style="color:#00f">&lt;%d&gt; </span><span style="color:#00f">&#34;</span>, current_value(itr));
}
printf(<span style="color:#00f"></span><span style="color:#00f">&#34;</span><span style="color:#00f">\n</span><span style="color:#00f">&#34;</span>);
free_iterator(itr);
</code></pre></div><p>The code might not be trivial, but (trust me) it is no worse than keeping track of an explicit stack.</p>
<p>And I can imagine the CPS approach being much simpler when you need to nest various types of recursions in a search. At least, it will be my first attempt when I need to implement that.</p>
<h1 id="appendix-allocator">Appendix: allocator</h1>
<p>The closure pool allocator is quite simple, but I won&rsquo;t guarantee that it works perfectly. I have just whipped it up for these experiments and I have not tested it beyond running the code above.</p>
<p>Nevertheless, here it is.</p>
<p>An allocation pool consists of chunks of memory that look like this:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">struct</span> mem_chunk
{
    <span style="color:#080;font-style:italic">// link to next free chunk
</span><span style="color:#080;font-style:italic"></span>    <span style="color:#000080;font-weight:bold">struct</span> mem_chunk *free;
    <span style="color:#080;font-style:italic">// the data in the chunk, max aligned so we can
</span><span style="color:#080;font-style:italic"></span>    <span style="color:#080;font-style:italic">// put anything here.
</span><span style="color:#080;font-style:italic"></span>    _Alignas(<span style="color:#000080;font-weight:bold">sizeof</span>(max_align_t)) <span style="color:#000080;font-weight:bold">char</span> data[];
};
</code></pre></div><p>There is a <code>free</code> pointer, so I can link the chunks into a free list, and then there is some data. In the structure, the data doesn&rsquo;t take up any memory, it will when we allocate blocks. We get the size as an argument to the allocation pool, and all we have to do here, is make sure that we can align the data. That is what the <code>_Alignas()</code> line is for.</p>
<p>The chunks are stored in a linked list of sub-pools. I use the sub-pools to extend the memory the pool can hold.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#008080">#</span><span style="color:#008080">define SUBPOOL_SIZE 1024</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#000080;font-weight:bold">struct</span> mem_subpool
{
    <span style="color:#000080;font-weight:bold">struct</span> mem_subpool *next;  <span style="color:#080;font-style:italic">/* next sub-pool */</span>
    <span style="color:#000080;font-weight:bold">struct</span> mem_chunk chunks[]; <span style="color:#080;font-style:italic">/* the sub-pool&#39;s chunks. */</span>
    <span style="color:#080;font-style:italic">/* flex array because we don&#39;t know the size of chunks yet. */</span>
};

<span style="color:#000080;font-weight:bold">struct</span> mem_pool
{
    size_t obj_size;
    <span style="color:#000080;font-weight:bold">struct</span> mem_subpool *pools;
    <span style="color:#000080;font-weight:bold">struct</span> mem_chunk *free;
};
</code></pre></div><p>Then I have some macros to compute sizes of various things.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#008080">#</span><span style="color:#008080">define HEADER_SIZE \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">    offsetof(struct mem_chunk, data)</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">#</span><span style="color:#008080">define CHUNK_SIZE(OBJ_SIZE) \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">    (HEADER_SIZE + OBJ_SIZE)</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">#</span><span style="color:#008080">define NEXT_CHUNK(P, OBJ_SIZE) \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">    (struct mem_chunk *)((char *)P + CHUNK_SIZE(OBJ_SIZE))</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">#</span><span style="color:#008080">define CHUNK_TO_DATA(P) \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">    ((void *)&amp;(P)-&gt;data)</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">#</span><span style="color:#008080">define DATA_TO_CHUNK(P) \</span><span style="color:#008080">
</span><span style="color:#008080"></span><span style="color:#008080">    ((struct mem_chunk *)((char *)(P)-HEADER_SIZE))</span><span style="color:#008080">
</span></code></pre></div><p><code>HEADER_SIZE</code> is the size of a chunk down to <code>data</code>, so the space used for the pointer and to get the data aligned. I suspect that this is just a pointer on most platforms, but I&rsquo;m not sure.</p>
<p><code>CHUNK_SIZE</code> gives us the size of a chunk. That is the size of the header and the size we need for the data.</p>
<p><code>NEXT_CHUNK</code> gets us from a pointer to a chunk to the next chunk in contiguous memory. You need to cast <code>P</code> to <code>char *</code> because that is the unit the sizes are in.</p>
<p><code>CHUNK_TO_DATA</code> gets you the data inside a chunk, while <code>DATA_TO_CHUNK</code> takes a pointer to the data in a chunk and gives us a pointer to the chunk.</p>
<p>I inline <code>alloc_mem()</code> and <code>free_mem()</code>, and they look like this:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">inline</span> <span style="color:#000080;font-weight:bold">void</span> *
alloc_mem(<span style="color:#000080;font-weight:bold">struct</span> mem_pool *pool)
{
    <span style="color:#000080;font-weight:bold">if</span> (!pool-&gt;free)
    {
        <span style="color:#000080;font-weight:bold">struct</span> mem_subpool *spool =
            new_subpool(pool-&gt;obj_size, pool-&gt;pools);
        pool-&gt;free = (<span style="color:#000080;font-weight:bold">struct</span> mem_chunk *)spool-&gt;chunks;
    }

    <span style="color:#000080;font-weight:bold">struct</span> mem_chunk *p = pool-&gt;free;
    pool-&gt;free = pool-&gt;free-&gt;free;

    <span style="color:#000080;font-weight:bold">return</span> CHUNK_TO_DATA(p);
}

<span style="color:#000080;font-weight:bold">static</span> <span style="color:#000080;font-weight:bold">inline</span> <span style="color:#000080;font-weight:bold">void</span> free_mem(<span style="color:#000080;font-weight:bold">struct</span> mem_pool *pool, <span style="color:#000080;font-weight:bold">void</span> *p)
{
    <span style="color:#000080;font-weight:bold">struct</span> mem_chunk *chunk = DATA_TO_CHUNK(p);
    chunk-&gt;free = pool-&gt;free;
    pool-&gt;free = chunk;
}
</code></pre></div><p>For allocating, if there are no free chunks I allocate a new sub-pool, and the top of the sub-pool is the new free list. Then I take the first free chunk, update the free list, and return a pointer to the data in chunk. For freeing, I get the chunk that contains the data and I add it to the free list.</p>
<p>I don&rsquo;t embed the user data and the free list in the same memory, something I would usually do. The reason, of course, is that I don&rsquo;t want to touch the user data until the next allocation. That is, kinda, something the closure code relies on.</p>
<p>Allocating a sub-pool is the trickiest code, but it is not too bad.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">struct</span> mem_subpool *
new_subpool(size_t obj_size, <span style="color:#000080;font-weight:bold">struct</span> mem_subpool *next)
{
    <span style="color:#000080;font-weight:bold">struct</span> mem_subpool *pool =
        malloc(offsetof(<span style="color:#000080;font-weight:bold">struct</span> mem_subpool, chunks) +
               SUBPOOL_SIZE * CHUNK_SIZE(obj_size));

    <span style="color:#000080;font-weight:bold">struct</span> mem_chunk *chunk = (<span style="color:#000080;font-weight:bold">struct</span> mem_chunk *)pool-&gt;chunks;
    <span style="color:#000080;font-weight:bold">for</span> (<span style="color:#000080;font-weight:bold">int</span> i = <span style="color:#00f">0</span>; i &lt; SUBPOOL_SIZE - <span style="color:#00f">1</span>;
         chunk = NEXT_CHUNK(chunk, obj_size), i++)
    {
        chunk-&gt;free = NEXT_CHUNK(chunk, obj_size);
    }
    chunk-&gt;free = <span style="color:#00f">0</span>;

    pool-&gt;next = next;
    <span style="color:#000080;font-weight:bold">return</span> pool;
}
</code></pre></div><p>The size calculation is the tricky bit (and it might be wrong, so don&rsquo;t use this code for something important). Then we need to initialises the free-list in the sub-pool, which means jumping from chunk to chunk. Here we need <code>NEXT_CHUNK</code> to work out the distance between chunks. Other than that, I don&rsquo;t think there is much to it.</p>
<p>Allocating and freeing a full pool is trivial.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000080;font-weight:bold">struct</span> mem_pool *new_mem_pool(size_t obj_size)
{
    <span style="color:#000080;font-weight:bold">struct</span> mem_pool *pool = malloc(<span style="color:#000080;font-weight:bold">sizeof</span> *pool);
    pool-&gt;obj_size = obj_size;
    pool-&gt;pools = new_subpool(obj_size, NULL);
    pool-&gt;free = (<span style="color:#000080;font-weight:bold">struct</span> mem_chunk *)pool-&gt;pools-&gt;chunks;
    <span style="color:#000080;font-weight:bold">return</span> pool;
}


<span style="color:#000080;font-weight:bold">void</span> free_mem_pool(<span style="color:#000080;font-weight:bold">struct</span> mem_pool *pool)
{
    <span style="color:#000080;font-weight:bold">struct</span> mem_subpool *sp = pool-&gt;pools;
    <span style="color:#000080;font-weight:bold">while</span> (sp)
    {
        <span style="color:#000080;font-weight:bold">struct</span> mem_subpool *next = sp-&gt;next;
        free(sp);
        sp = next;
    }
    free(pool);
}
</code></pre></div>

</article>


<section class="post-nav">
    <ul>
        
        <li>
            <a href="https://mailund.dk/posts/cstr-slices/"><i class="fa fa-chevron-circle-left"></i> C Slices</a>
        </li>
        
        
        <li>
            <a href="https://mailund.dk/posts/prefix-doubling-attemps/">Prefix Doubling Attempts <i class="fa fa-chevron-circle-right"></i> </a>
        </li>
        
    </ul>
</section>
    
        <section class="comments-block">
      <button id="show-comments" style="display: none;"><i class="fa fa-comments-o"></i> Add/View Comments</button>
</section>

<section id="disqus_thread"></section>

<script>
      (function () {
            
            
            if (window.location.hostname == "localhost")
                  return;

            var disqus_loaded = false;
            var disqus_shortname = 'mailund-dk';
            var disqus_button = document.getElementById("show-comments");

            disqus_button.style.display = "";
            disqus_button.addEventListener("click", disqus, false);

            function disqus() {

                  if (!disqus_loaded) {
                        disqus_loaded = true;

                        var e = document.createElement("script");
                        e.type = "text/javascript";
                        e.async = true;
                        e.src = "//" + disqus_shortname + ".disqus.com/embed.js";
                        (document.getElementsByTagName("head")[0] ||
                              document.getElementsByTagName("body")[0])
                        .appendChild(e);

                        
                        document.getElementById("show-comments").style.display = "none";
                  }
            }

            
            var hash = window.location.hash.substr(1);
            if (hash.length > 8) {
                  if (hash.substring(0, 8) == "comment-") {
                        disqus();
                  }
            }

            
            if (/bot|google|baidu|bing|msn|duckduckgo|slurp|yandex/i.test(navigator.userAgent)) {
                  disqus();
            }
      })();
</script>
    





</main>
    <footer>
        <h6>Copyright © 2020 - Thomas Mailund |
            Rendered by <a href="https://gohugo.io" title="Hugo">Hugo</a> |
            <a href="https://mailund.dk/index.xml">Subscribe</a></h6>
    </footer>
</div>
<script src="https://mailund.dk/js/scripts.js"></script>
</body>
<div id="amzn-assoc-ad-04956520-8388-43ab-9b6e-fbe758d208f8"></div>
<script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=04956520-8388-43ab-9b6e-fbe758d208f8"></script>

<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

</html>
