<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on Mailund on the Internet</title>
    <link>https://mailund.dk/tags/go/</link>
    <description>Recent content in Go on Mailund on the Internet</description>
    <generator>Hugo</generator>
    <language>en</language>
    <copyright>Copyright &amp;copy; 2020-2025 - Thomas Mailund</copyright>
    <lastBuildDate>Mon, 17 Feb 2025 17:56:54 +0100</lastBuildDate>
    <atom:link href="https://mailund.dk/tags/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>KMP Implementations</title>
      <link>https://mailund.dk/posts/kmp-implementations/</link>
      <pubDate>Mon, 17 Feb 2025 17:56:54 +0100</pubDate>
      <guid>https://mailund.dk/posts/kmp-implementations/</guid>
      <description>&lt;p&gt;Following on my &lt;a href=&#34;https://mailund.dk/posts/some-simple-string-search-implementations/&#34;&gt;previous post&lt;/a&gt; I set out to implement the Knuth-Morris-Pratt algorithm.&lt;/p&gt;&#xA;&lt;p&gt;This algorithm shifts the pattern &lt;code&gt;p&lt;/code&gt; along &lt;code&gt;x&lt;/code&gt;, exploiting the structure in &lt;code&gt;p&lt;/code&gt; to skip positions we know cannot match. To do this, it uses a so-called &lt;em&gt;border array&lt;/em&gt; that we need to pre-compute.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Simple String Search Implementations</title>
      <link>https://mailund.dk/posts/some-simple-string-search-implementations/</link>
      <pubDate>Sun, 16 Feb 2025 06:39:39 +0100</pubDate>
      <guid>https://mailund.dk/posts/some-simple-string-search-implementations/</guid>
      <description>&lt;p&gt;I’ll get back to playing with Scala soon, but since I don’t know which skills to brush up on, I also decided to play with a few other things.&lt;/p&gt;&#xA;&lt;p&gt;I have taught string algorithms for over a decade, so I figured that using a few simple algorithms I know very well would be an interesting way to play with how the same goal can be achieved in different languages.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Starting Up Exercises: Burrows-Wheeler Transform</title>
      <link>https://mailund.dk/posts/starting-up-exercises-bwt/</link>
      <pubDate>Fri, 05 Feb 2021 10:19:43 +0100</pubDate>
      <guid>https://mailund.dk/posts/starting-up-exercises-bwt/</guid>
      <description>&lt;p&gt;I am supervising some projects this spring, on algorithms for read-mapping. It&amp;rsquo;s different projects that all involve implementing a working, but primitive, read mapper.&lt;/p&gt;&#xA;&lt;p&gt;There is nothing new there, I have a class every year where we do that, but now it is individual projects. The content doesn&amp;rsquo;t change much; just the teaching format.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Chinese Remainder in Go</title>
      <link>https://mailund.dk/posts/crt-go/</link>
      <pubDate>Wed, 06 Jan 2021 10:56:53 +0100</pubDate>
      <guid>https://mailund.dk/posts/crt-go/</guid>
      <description>&lt;p&gt;In between exams, I plan to learn &lt;a href=&#34;https://golang.org&#34;&gt;Go&lt;/a&gt; in January. I have a book I plan to follow, but today I wanted to get started by just jumping into it, so I picked the &lt;a href=&#34;https://en.wikipedia.org/wiki/Chinese_remainder_theorem&#34;&gt;Chinese Remainder Theorem&lt;/a&gt; we used for 2020&amp;rsquo;s Advent of Code &lt;a href=&#34;https://mailund.dk/posts/aoc-2020-4/&#34;&gt;Day 13&lt;/a&gt;. There, I implemented it in Python (before I found out that it was already in SymPy). It is a simple numerical algorithm, so it should be easy to implement in Go. Or so I thought.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
